<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/data/skillManager.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/data/skillManager.js" />
              <option name="originalContent" value="import Skill from './skill.js';&#10;&#10;// 技能管理器类&#10;class SkillManager {&#10;  constructor() {&#10;    this.skills = [];&#10;    this.skillRegistry = new Map(); // 新增技能注册表&#10;    &#10;  }&#10;  // 注册技能&#10;  registerSkill(SkillClass) {&#10;    const skillName = (new SkillClass()).name;&#10;    this.skillRegistry.set(skillName, SkillClass);&#10;  }&#10;&#10;  static async loadAllSkills() {&#10;    &#10;    const skillManager = SkillManager.getInstance();&#10;&#10;    // 动态导入所有技能文件&#10;    const skillModules = [&#10;      await import('./skills/martial_arts/agilePunch.js'),&#10;      await import('./skills/martial_arts/block.js'),&#10;      await import('./skills/martial_arts/guardHit.js'),&#10;      await import('./skills/martial_arts/heavySmash.js'),&#10;      await import('./skills/martial_arts/machete.js'),&#10;      await import('./skills/martial_arts/martialArtPose.js'),&#10;      await import('./skills/martial_arts/misc.js'),&#10;      await import('./skills/martial_arts/onePunch.js'),&#10;      await import('./skills/martial_arts/peakMartialArt.js'),&#10;      await import('./skills/martial_arts/precise.js'),&#10;      await import('./skills/martial_arts/preparedHit.js'),&#10;      await import('./skills/martial_arts/punch.js'),&#10;      await import('./skills/martial_arts/roundSlash.js'),&#10;      await import('./skills/martial_arts/shielding.js'),&#10;      await import('./skills/martial_arts/slash.js'),&#10;      await import('./skills/martial_arts/shapelessPunch.js'),&#10;      await import('./skills/martial_arts/taiji.js'),&#10;      // await import('./skills/blast.js'),&#10;      // await import('./skills/cMinus.js'),&#10;      // await import('./skills/concentration.js'),&#10;      // await import('./skills/fireAssist.js'),&#10;      // await import('./skills/fireControl.js'),&#10;      // await import('./skills/heal.js'),&#10;      // await import('./skills/levitation.js'),&#10;      // await import('./skills/punchKicks.js'),&#10;      // await import('./skills/refuelWeky.js'),&#10;      // await import('./skills/shielding.js'),&#10;      // await import('./skills/speedThinking.js'),&#10;      // await import('./skills/curses.js'),&#10;      // await import('./skills/matialArts')&#10;      // await import('./skills/remi.js'),&#10;      // await import('./skills/lumi.js')&#10;    ];&#10;    &#10;    // 遍历所有模块并注册其中的技能&#10;    for (const module of skillModules) {&#10;      // 遍历模块中的所有导出&#10;      for (const [key, SkillClass] of Object.entries(module)) {&#10;        // 检查是否为Skill类的子类&#10;        if (typeof SkillClass === 'function' &amp;&amp; SkillClass !== Skill &amp;&amp; SkillClass.prototype instanceof Skill) {&#10;          try {&#10;            skillManager.registerSkill(SkillClass);&#10;          } catch (error) {&#10;            console.error(`Failed to register skill: ${key}`, error);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;  &#10;  // 创建技能实例&#10;  createSkill(skillName) {&#10;    // 使用注册表创建技能实例&#10;    const SkillClass = this.skillRegistry.get(skillName);&#10;    if (SkillClass) {&#10;      const obj = new SkillClass();&#10;      obj.description = obj.regenerateDescription();&#10;      return obj;&#10;    }&#10;    throw new Error(`Unknown skill: ${skillName}`);&#10;  }&#10;  &#10;  // 获取SkillManager实例&#10;  static getInstance() {&#10;    if (!this.instance) {&#10;      this.instance = new SkillManager();&#10;    }&#10;    return this.instance;&#10;  }&#10;  &#10;  // 获取随机技能&#10;  getRandomSkills(count, playerLeino= {}, playerSkillSlots = [], playerTier = 0, bestQuality = false) {&#10;    // ---- 收集所有技能的元数据（扩展: precessor, leinoModifiers） ----&#10;    const allSkills = Array.from(this.skillRegistry.entries()).map(([name, SkillClass]) =&gt; {&#10;      const tempSkill = new SkillClass();&#10;      return {&#10;        name: name,&#10;        type: tempSkill.type,&#10;        series: tempSkill.skillSeriesName,&#10;        tier: tempSkill.tier,&#10;        canSpawnAsReward_: tempSkill.canSpawnAsReward_,&#10;        spawnWeight: tempSkill.spawnWeight,&#10;        precessor: tempSkill.precessor, // 可能是字符串 / 数组 / null&#10;        leinoModifiers: tempSkill.leinoModifiers // 可能是字符串 / 数组 / null&#10;      };&#10;    });&#10;&#10;    const playerNonEmptySkillSlots = playerSkillSlots.filter(skill =&gt; skill !== null);&#10;    const playerSkills = playerNonEmptySkillSlots.map(slot =&gt; slot);&#10;    // console.log(playerSkills);&#10;&#10;    // 获取玩家已有的技能系列&#10;    const playerSkillSeries = playerSkills.map(skill =&gt; skill.skillSeriesName);&#10;    const playerSkillNames = playerSkills.map(skill =&gt; skill.name);&#10;&#10;    // 过滤掉不可生成为奖励的技能，有前置技能的技能，以及等阶大于玩家等阶的技能&#10;    const baseAvailableSkills = allSkills.filter(skill =&gt;&#10;      skill.tier &lt;= playerTier &amp;&amp;&#10;      skill.canSpawnAsReward_ &amp;&amp;&#10;      skill.precessor === null &amp;&amp; // 只能是自由出现的技能&#10;      skill.tier &gt;= 0 // 不能是（-1）特殊卡&#10;    );&#10;&#10;    // —— 新升级候选逻辑：根据 precessor 反向推导 ——&#10;    // precessor: 表示此技能的前置技能（或前置技能数组）。如果玩家拥有前置技能，则该技能加入奖池&#10;    const upgradeCandidates = [];&#10;    for (const meta of allSkills) {&#10;      if (playerSkillNames.includes(meta.name)) continue; // 已拥有不加入&#10;      if (meta.tier &gt; playerTier) continue; // 等阶限制（保持与旧逻辑一致）&#10;      if (!meta.precessor) continue; // 没有前置技能&#10;&#10;      let matchedSource = null;&#10;      if (Array.isArray(meta.precessor)) {&#10;        matchedSource = meta.precessor.find(p =&gt; playerSkillNames.includes(p)) || null;&#10;      } else if (typeof meta.precessor === 'string') {&#10;        matchedSource = playerSkillNames.includes(meta.precessor) ? meta.precessor : null;&#10;      }&#10;      if (!matchedSource) continue; // 玩家没有其任意前置技能&#10;&#10;      // 避免重复添加（如果之前 baseAvailable 已包含则跳过）&#10;      if (baseAvailableSkills.some(s =&gt; s.name === meta.name)) continue;&#10;&#10;      upgradeCandidates.push({ ...meta, isUpgradeCandidate: true, upgradedFrom: matchedSource });&#10;    }&#10;&#10;    // 合并（升级候选可以绕过“同系列排除”限制）&#10;    const availableSkills = [...baseAvailableSkills];&#10;    for (const u of upgradeCandidates) {&#10;      if (!availableSkills.some(s =&gt; s.name === u.name)) availableSkills.push(u);&#10;    }&#10;&#10;    // 计算每个技能的出现权重&#10;    const weightedSkills = availableSkills.map(skill =&gt; {&#10;      const tierDifference = playerTier - skill.tier;&#10;      let modifyFactor = 1;&#10;&#10;      // 高等级技能出现权重降低&#10;      if (skill.tier &gt;= 8) modifyFactor *= 0.7;&#10;      if (skill.tier &gt;= 5) modifyFactor *= 0.8;&#10;&#10;      // 等级太低的技能出现权重大幅降低&#10;      if (tierDifference &gt; 7) {&#10;        modifyFactor = 0.15;&#10;      }  else if (tierDifference &gt; 6) {&#10;        modifyFactor = 0.40;&#10;      } else if (tierDifference &gt; 5) {&#10;        modifyFactor = 0.70;&#10;      }&#10;&#10;      // 高质量奖励中，贴近玩家等级上限技能概率大幅提升&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 1) modifyFactor *= 5;&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 2) modifyFactor *= 3;&#10;&#10;      // 基础：技能主类型与玩家灵脉的耦合权重&#10;      {&#10;        let leinoFactor = Math.max(playerLeino[skill.type] || 0.2, 0); // 没有该属性时，给予一个较低的基础值&#10;        if (skill.type === 'normal') leinoFactor = Math.max(leinoFactor, 1); // 普通技能（非灵御技能）至少保证有 1 倍权重&#10;        modifyFactor *= leinoFactor;&#10;      }&#10;&#10;      // 新增：leinoModifiers 进一步影响（表示此卡受多种灵脉影响）&#10;      if (skill.leinoModifiers) {&#10;        const list = Array.isArray(skill.leinoModifiers) ? skill.leinoModifiers : [skill.leinoModifiers];&#10;        // 采用 “平均值” 模型，避免多元素乘积导致爆炸或极端衰减&#10;        const factors = list.map(key =&gt; {&#10;          const v = playerLeino[key];&#10;            // 若玩家该灵脉因子缺失，则视为 1（中性，不放大不缩小）&#10;          return (typeof v === 'number' &amp;&amp; v &gt; 0) ? v : 1;&#10;        });&#10;        if (factors.length &gt; 0) {&#10;          const avg = factors.reduce((a,b)=&gt;a+b,0) / factors.length;&#10;          modifyFactor *= avg;&#10;        }&#10;      }&#10;&#10;      // 升级候选技能稍微再提升一点（避免被其它随机权重稀释）&#10;      if(skill.isUpgradeCandidate) modifyFactor *= 2;&#10;&#10;      return {&#10;        ...skill,&#10;        weight: skill.spawnWeight * modifyFactor&#10;      };&#10;    });&#10;    &#10;    const selectedSkills = [];&#10;    &#10;    // 确保不会选择超过可用技能数量的技能&#10;    const actualCount = Math.min(count, weightedSkills.length);&#10;    &#10;    // 带权不放回抽选&#10;    for (let i = 0; i &lt; actualCount; i++) {&#10;      // 计算总权重&#10;      const totalWeight = weightedSkills.reduce((sum, skill) =&gt; sum + skill.weight, 0);&#10;      &#10;      // 如果没有权重可供选择，提前跳出&#10;      if(totalWeight &lt;= 0) break;&#10;&#10;      // 生成随机数&#10;      const random = Math.random() * totalWeight;&#10;      &#10;      // 选择技能&#10;      let currentWeight = 0;&#10;      let selectedIndex = 0;&#10;      &#10;      for (let j = 0; j &lt; weightedSkills.length; j++) {&#10;        currentWeight += weightedSkills[j].weight;&#10;        if (random &lt;= currentWeight) {&#10;          selectedIndex = j;&#10;          break;&#10;        }&#10;      }&#10;      &#10;      // 获取选中的技能&#10;      const skillInfo = weightedSkills[selectedIndex];&#10;      const skill = this.createSkill(skillInfo.name);&#10;      if(skillInfo.isUpgradeCandidate) {&#10;        skill.isUpgradeCandidate = true; // 标记（目前 UI 未使用或用于展示）&#10;        if(skillInfo.upgradedFrom) skill.upgradedFrom = skillInfo.upgradedFrom; // 记录来源技能名称&#10;      }&#10;      selectedSkills.push(skill);&#10;      &#10;      // 从可选技能中移除已选择的技能&#10;      weightedSkills.splice(selectedIndex, 1);&#10;    }&#10;    &#10;    return selectedSkills;&#10;  }&#10;}&#10;&#10;export default SkillManager;&#10;" />
              <option name="updatedContent" value="import Skill from './skill.js';&#10;&#10;// 技能管理器类&#10;class SkillManager {&#10;  constructor() {&#10;    this.skills = [];&#10;    this.skillRegistry = new Map(); // 新增技能注册表&#10;    &#10;  }&#10;  // 注册技能&#10;  registerSkill(SkillClass) {&#10;    const skillName = (new SkillClass()).name;&#10;    this.skillRegistry.set(skillName, SkillClass);&#10;  }&#10;&#10;  static async loadAllSkills() {&#10;    &#10;    const skillManager = SkillManager.getInstance();&#10;&#10;    // 动态导入所有技能文件&#10;    const skillModules = [&#10;      await import('./skills/martial_arts/agilePunch.js'),&#10;      await import('./skills/martial_arts/block.js'),&#10;      await import('./skills/martial_arts/guardHit.js'),&#10;      await import('./skills/martial_arts/heavySmash.js'),&#10;      await import('./skills/martial_arts/machete.js'),&#10;      await import('./skills/martial_arts/martialArtPose.js'),&#10;      await import('./skills/martial_arts/misc.js'),&#10;      await import('./skills/martial_arts/onePunch.js'),&#10;      await import('./skills/martial_arts/peakMartialArt.js'),&#10;      await import('./skills/martial_arts/precise.js'),&#10;      await import('./skills/martial_arts/preparedHit.js'),&#10;      await import('./skills/martial_arts/punch.js'),&#10;      await import('./skills/martial_arts/roundSlash.js'),&#10;      await import('./skills/martial_arts/shielding.js'),&#10;      await import('./skills/martial_arts/slash.js'),&#10;      await import('./skills/martial_arts/shapelessPunch.js'),&#10;      await import('./skills/martial_arts/taiji.js'),&#10;      // await import('./skills/blast.js'),&#10;      // await import('./skills/cMinus.js'),&#10;      // await import('./skills/concentration.js'),&#10;      // await import('./skills/fireAssist.js'),&#10;      // await import('./skills/fireControl.js'),&#10;      // await import('./skills/heal.js'),&#10;      // await import('./skills/levitation.js'),&#10;      // await import('./skills/punchKicks.js'),&#10;      // await import('./skills/refuelWeky.js'),&#10;      // await import('./skills/shielding.js'),&#10;      // await import('./skills/speedThinking.js'),&#10;      // await import('./skills/curses.js'),&#10;      // await import('./skills/matialArts')&#10;      // await import('./skills/remi.js'),&#10;      // await import('./skills/lumi.js')&#10;    ];&#10;    &#10;    // 遍历所有模块并注册其中的技能&#10;    for (const module of skillModules) {&#10;      // 遍历模块中的所有导出&#10;      for (const [key, SkillClass] of Object.entries(module)) {&#10;        // 检查是否为Skill类的子类&#10;        if (typeof SkillClass === 'function' &amp;&amp; SkillClass !== Skill &amp;&amp; SkillClass.prototype instanceof Skill) {&#10;          try {&#10;            skillManager.registerSkill(SkillClass);&#10;          } catch (error) {&#10;            console.error(`Failed to register skill: ${key}`, error);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;  &#10;  // 创建技能实例&#10;  createSkill(skillName) {&#10;    // 使用注册表创建技能实例&#10;    const SkillClass = this.skillRegistry.get(skillName);&#10;    if (SkillClass) {&#10;      const obj = new SkillClass();&#10;      obj.description = obj.regenerateDescription();&#10;      return obj;&#10;    }&#10;    throw new Error(`Unknown skill: ${skillName}`);&#10;  }&#10;  &#10;  // 获取SkillManager实例&#10;  static getInstance() {&#10;    if (!this.instance) {&#10;      this.instance = new SkillManager();&#10;    }&#10;    return this.instance;&#10;  }&#10;  &#10;  // 获取随机技能&#10;  getRandomSkills(count, playerLeino= {}, playerSkillSlots = [], playerTier = 0, bestQuality = false) {&#10;    // ---- 收集所有技能的元数据（扩展: precessor, leinoModifiers） ----&#10;    const allSkills = Array.from(this.skillRegistry.entries()).map(([name, SkillClass]) =&gt; {&#10;      const tempSkill = new SkillClass();&#10;      return {&#10;        name: name,&#10;        type: tempSkill.type,&#10;        series: tempSkill.skillSeriesName,&#10;        tier: tempSkill.tier,&#10;        canSpawnAsReward_: tempSkill.canSpawnAsReward_,&#10;        spawnWeight: tempSkill.spawnWeight,&#10;        precessor: tempSkill.precessor, // 可能是字符串 / 数组 / null&#10;        leinoModifiers: tempSkill.leinoModifiers // 可能是字符串 / 数组 / null&#10;      };&#10;    });&#10;&#10;    const playerNonEmptySkillSlots = playerSkillSlots.filter(skill =&gt; skill !== null);&#10;    const playerSkills = playerNonEmptySkillSlots.map(slot =&gt; slot);&#10;    // console.log(playerSkills);&#10;&#10;    // 获取玩家已有的技能系列&#10;    const playerSkillSeries = playerSkills.map(skill =&gt; skill.skillSeriesName);&#10;    const playerSkillNames = playerSkills.map(skill =&gt; skill.name);&#10;&#10;    // 过滤掉不可生成为奖励的技能，有前置技能的技能，以及等阶大于玩家等阶的技能&#10;    const baseAvailableSkills = allSkills.filter(skill =&gt;&#10;      skill.tier &lt;= playerTier &amp;&amp;&#10;      skill.canSpawnAsReward_ &amp;&amp;&#10;      skill.precessor === null &amp;&amp; // 只能是自由出现的技能&#10;      skill.tier &gt;= 0 // 不能是（-1）特殊卡&#10;    );&#10;&#10;    // —— 新升级候选逻辑：根据 precessor 反向推导 ——&#10;    // precessor: 表示此技能的前置技能（或前置技能数组）。如果玩家拥有前置技能，则该技能加入奖池&#10;    const upgradeCandidates = [];&#10;    for (const meta of allSkills) {&#10;      if (playerSkillNames.includes(meta.name)) continue; // 已拥有不加入&#10;      if (meta.tier &gt; playerTier) continue; // 等阶限制（保持与旧逻辑一致）&#10;      if (!meta.precessor) continue; // 没有前置技能&#10;&#10;      let matchedSource = null;&#10;      if (Array.isArray(meta.precessor)) {&#10;        matchedSource = meta.precessor.find(p =&gt; playerSkillNames.includes(p)) || null;&#10;      } else if (typeof meta.precessor === 'string') {&#10;        matchedSource = playerSkillNames.includes(meta.precessor) ? meta.precessor : null;&#10;      }&#10;      if (!matchedSource) continue; // 玩家没有其任意前置技能&#10;&#10;      // 避免重复添加（如果之前 baseAvailable 已包含则跳过）&#10;      if (baseAvailableSkills.some(s =&gt; s.name === meta.name)) continue;&#10;&#10;      upgradeCandidates.push({ ...meta, isUpgradeCandidate: true, upgradedFrom: matchedSource });&#10;    }&#10;&#10;    // 合并（升级候选可以绕过“同系列排除”限制）&#10;    const availableSkills = [...baseAvailableSkills];&#10;    for (const u of upgradeCandidates) {&#10;      if (!availableSkills.some(s =&gt; s.name === u.name)) availableSkills.push(u);&#10;    }&#10;&#10;    // 计算每个技能的出现权重&#10;    const weightedSkills = availableSkills.map(skill =&gt; {&#10;      const tierDifference = playerTier - skill.tier;&#10;      let modifyFactor = 1;&#10;&#10;      // 高等级技能出现权重降低&#10;      if (skill.tier &gt;= 8) modifyFactor *= 0.7;&#10;      if (skill.tier &gt;= 5) modifyFactor *= 0.8;&#10;&#10;      // 等级太低的技能出现权重大幅降低&#10;      if (tierDifference &gt; 7) {&#10;        modifyFactor = 0.15;&#10;      }  else if (tierDifference &gt; 6) {&#10;        modifyFactor = 0.40;&#10;      } else if (tierDifference &gt; 5) {&#10;        modifyFactor = 0.70;&#10;      }&#10;&#10;      // 高质量奖励中，贴近玩家等级上限技能概率大幅提升&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 1) modifyFactor *= 5;&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 2) modifyFactor *= 3;&#10;&#10;      // 基础：技能主类型与玩家灵脉的耦合权重&#10;      {&#10;        let leinoFactor = Math.max(playerLeino[skill.type] || 0.2, 0); // 没有该属性时，给予一个较低的基础值&#10;        if (skill.type === 'normal') leinoFactor = Math.max(leinoFactor, 1); // 普通技能（非灵御技能）至少保证有 1 倍权重&#10;        modifyFactor *= leinoFactor;&#10;      }&#10;&#10;      // 新增：leinoModifiers 进一步影响（表示此卡受多种灵脉影响）&#10;      if (skill.leinoModifiers) {&#10;        const list = Array.isArray(skill.leinoModifiers) ? skill.leinoModifiers : [skill.leinoModifiers];&#10;        // 采用 “平均值” 模型，避免多元素乘积导致爆炸或极端衰减&#10;        const factors = list.map(key =&gt; {&#10;          const v = playerLeino[key];&#10;            // 若玩家该灵脉因子缺失，则视为 1（中性，不放大不缩小）&#10;          return (typeof v === 'number' &amp;&amp; v &gt; 0) ? v : 1;&#10;        });&#10;        if (factors.length &gt; 0) {&#10;          const avg = factors.reduce((a,b)=&gt;a+b,0) / factors.length;&#10;          modifyFactor *= avg;&#10;        }&#10;      }&#10;&#10;      // 升级候选技能稍微再提升一点（避免被其它随机权重稀释）&#10;      if(skill.isUpgradeCandidate) modifyFactor *= 2;&#10;&#10;      return {&#10;        ...skill,&#10;        weight: skill.spawnWeight * modifyFactor&#10;      };&#10;    });&#10;    &#10;    const selectedSkills = [];&#10;    &#10;    // 确保不会选择超过可用技能数量的技能&#10;    const actualCount = Math.min(count, weightedSkills.length);&#10;    &#10;    // 带权不放回抽选&#10;    for (let i = 0; i &lt; actualCount; i++) {&#10;      // 计算总权重&#10;      const totalWeight = weightedSkills.reduce((sum, skill) =&gt; sum + skill.weight, 0);&#10;      &#10;      // 如果没有权重可供选择，提前跳出&#10;      if(totalWeight &lt;= 0) break;&#10;&#10;      // 生成随机数&#10;      const random = Math.random() * totalWeight;&#10;      &#10;      // 选择技能&#10;      let currentWeight = 0;&#10;      let selectedIndex = 0;&#10;      &#10;      for (let j = 0; j &lt; weightedSkills.length; j++) {&#10;        currentWeight += weightedSkills[j].weight;&#10;        if (random &lt;= currentWeight) {&#10;          selectedIndex = j;&#10;          break;&#10;        }&#10;      }&#10;      &#10;      // 获取选中的技能&#10;      const skillInfo = weightedSkills[selectedIndex];&#10;      const skill = this.createSkill(skillInfo.name);&#10;      if(skillInfo.isUpgradeCandidate) {&#10;        skill.isUpgradeCandidate = true; // 标记（目前 UI 未使用或用于展示）&#10;        if(skillInfo.upgradedFrom) skill.upgradedFrom = skillInfo.upgradedFrom; // 记录来源技能名称&#10;      }&#10;      selectedSkills.push(skill);&#10;      &#10;      // 从可选技能中移除已选择的技能&#10;      weightedSkills.splice(selectedIndex, 1);&#10;    }&#10;    &#10;    return selectedSkills;&#10;  }&#10;}&#10;&#10;export default SkillManager;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>