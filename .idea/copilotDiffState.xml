<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/RestScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/RestScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;rest-screen&quot; :class=&quot;{'remi-present-rest-screen': gameState.isRemiPresent}&quot;&gt;&#10;    &lt;div class=&quot;rest-screen-content&quot;&gt;&#10;      &lt;h1 class=&quot;rest-title&quot;&gt;{{ gameState.isRemiPresent ? '好好休息！' : '休整阶段'}}&lt;/h1&gt;&#10;      &#10;      &lt;div class=&quot;content-wrapper&quot;&gt;&#10;        &lt;!-- 左侧固定大小面板容器 --&gt;&#10;        &lt;div class=&quot;left-panel-container&quot;&gt;&#10;          &lt;!-- 金钱奖励面板 --&gt;&#10;          &lt;MoneyRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'money'&quot;&#10;            :amount=&quot;gameState.rewards.money&quot;&#10;            @claimed=&quot;onMoneyRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 突破奖励面板 --&gt;&#10;          &lt;BreakthroughRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'breakthrough'&quot;&#10;            @claimed=&quot;onBreakthroughRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 技能奖励面板 --&gt;&#10;          &lt;SkillRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'skill'&quot;&#10;            :skills=&quot;gameState.rewards.skills&quot;&#10;            @close=&quot;closeSkillRewardPanel&quot;&#10;            @selected-skill-reward=&quot;onSkillRewardSelected&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 能力奖励面板 --&gt;&#10;          &lt;AbilityRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'ability'&quot;&#10;            :abilities=&quot;gameState.rewards.abilities&quot;&#10;            @selected-ability-reward=&quot;onAbilityRewardSelected&quot;&#10;            @close=&quot;closeAbilityRewardPanel&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 商店面板 --&gt;&#10;          &lt;ShopPanel&#10;        :is-visible=&quot;currentRewardPanel === 'shop'&quot;&#10;        :shop-items=&quot;gameState.shopItems&quot;&#10;        :game-state=&quot;gameState&quot;&#10;        @close=&quot;closeShopPanel&quot;&#10;      /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;!-- 右侧玩家状态面板 --&gt;&#10;        &lt;PlayerStatusPanel :player=&quot;gameState.player&quot; :restScreen=&quot;true&quot;/&gt;&#10;      &lt;/div&gt;&#10;      &#10;      &lt;SkillSlotSelectionPanel&#10;        :is-visible=&quot;skillSlotSelectionPanelVisible&quot;&#10;        :skill-slots=&quot;gameState.player.skillSlots&quot;&#10;        :skill=&quot;claimingSkill&quot;&#10;        @select-slot=&quot;onSkillSlotSelected&quot;&#10;        @close=&quot;closeSkillSlotSelectionPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import AbilityRewardPanel from './AbilityRewardPanel.vue';&#10;import SkillRewardPanel from './SkillRewardPanel.vue';&#10;import SkillSlotSelectionPanel from './SkillSlotSelectionPanel.vue';&#10;import ShopPanel from './ShopPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import MoneyRewardPanel from './MoneyRewardPanel.vue';&#10;import BreakthroughRewardPanel from './BreakthroughRewardPanel.vue';&#10;import frontendEventBus from &quot;../frontendEventBus&quot;;&#10;import backendEventBus, { EventNames } from &quot;../backendEventBus&quot;;&#10;&#10;export default {&#10;  name: 'RestScreen',&#10;  components: {&#10;    ColoredText,&#10;    AbilityRewardPanel,&#10;    SkillRewardPanel,&#10;    SkillSlotSelectionPanel,&#10;    ShopPanel,&#10;    PlayerStatusPanel,&#10;    MoneyRewardPanel,&#10;    BreakthroughRewardPanel&#10;  },&#10;  props: {&#10;    gameState: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      currentRewardPanel: '', // 'money', 'breakthrough', 'skill', 'ability', 'shop' or empty&#10;      skillSlotSelectionPanelVisible: false,&#10;      claimingSkill: null,&#10;      rewardPanels: [],&#10;      currentRewardIndex: 0&#10;    }&#10;  },&#10;  mounted() {&#10;    // 初始化奖励面板队列&#10;    this.initRewardPanels();&#10;    // 显示第一个奖励面板&#10;    this.showNextRewardPanel();&#10;    // 监听后端商品购买，弹出UI消息&#10;    backendEventBus.on(EventNames.Shop.ITEM_PURCHASED, (purchasedItem) =&gt; {&#10;      frontendEventBus.emit(&quot;pop-message&quot;, {&#10;        id: 'item-purchased',&#10;        text: `购买了物品：${purchasedItem.name}`&#10;      });&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    backendEventBus.off &amp;&amp; backendEventBus.off(EventNames.Shop.ITEM_PURCHASED);&#10;  },&#10;  methods: {&#10;    initRewardPanels() {&#10;      this.rewardPanels = [];&#10;      &#10;      // 按顺序添加奖励面板&#10;      if (this.gameState.rewards.money &gt; 0) {&#10;        this.rewardPanels.push('money');&#10;      }&#10;      &#10;      if (this.gameState.rewards.breakthrough) {&#10;        this.rewardPanels.push('breakthrough');&#10;      }&#10;      &#10;      if (this.gameState.rewards.skills.length &gt; 0) {&#10;        this.rewardPanels.push('skill');&#10;      }&#10;      &#10;      if (this.gameState.rewards.abilities.length &gt; 0) {&#10;        this.rewardPanels.push('ability');&#10;      }&#10;      &#10;      // 总是添加商店面板&#10;      this.rewardPanels.push('shop'); &#10;    },&#10;    &#10;    showNextRewardPanel() {&#10;      // 先隐藏当前面板&#10;      this.currentRewardPanel = 'none';&#10;      // 稍等片刻后，再显示下一个面板&#10;      setTimeout(()=&gt; {&#10;        if (this.currentRewardIndex &lt; this.rewardPanels.length) {&#10;          this.currentRewardPanel = this.rewardPanels[this.currentRewardIndex];&#10;        } else {&#10;          // 所有奖励面板都已显示完毕&#10;          this.currentRewardPanel = '';&#10;        }&#10;      }, 500);&#10;    },&#10;    &#10;    onMoneyRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    onBreakthroughRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeSkillRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeAbilityRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;&#10;    onSkillRewardSelected(currentSkill) {&#10;      this.claimingSkill = currentSkill;&#10;      // 稍等片刻后打开SkillSlotSelectionPanel，让动画放完&#10;      setTimeout(() =&gt; {&#10;        this.skillSlotSelectionPanelVisible = true;&#10;      }, 300);&#10;    },&#10;    closeSkillSlotSelectionPanel() {&#10;      this.skillSlotSelectionPanelVisible = false;&#10;    },&#10;    onSkillSlotSelected(slotIndex) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;        skill: this.claimingSkill,&#10;        slotIndex,&#10;        clearRewards: false&#10;      });&#10;      // 关闭面板&#10;      this.closeSkillSlotSelectionPanel();&#10;      this.closeSkillRewardPanel();&#10;    },&#10;    onAbilityRewardSelected(ability) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_ABILITY, {&#10;        ability,&#10;        clearRewards: false&#10;      });&#10;      this.closeAbilityRewardPanel();&#10;    },&#10;    closeShopPanel() {&#10;      // 结束休整阶段，开始下一场战斗（后端流程监听）&#10;      backendEventBus.emit(EventNames.Rest.FINISH);&#10;    }&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.rest-screen {&#10;  height: 100%;&#10;  width: 100%;&#10;  background-size: cover;&#10;}&#10;&#10;.remi-present-rest-screen {&#10;  background-image: url('@assets/images/shop-background.png');&#10;}&#10;&#10;.rest-screen-content {&#10;  margin: 0 auto;&#10;  padding: 20px;&#10;  max-width: 1200px;&#10;}&#10;&#10;.content-wrapper {&#10;  display: flex;&#10;  flex-direction: row;&#10;  gap: 20px;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;}&#10;&#10;.rest-title {&#10;  font-size: 2em;&#10;  margin-bottom: 20px;&#10;  color: #eef7ff;&#10;}&#10;&#10;.left-panel-container {&#10;  width: 800px;&#10;  height: 220px;&#10;  position: relative;&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;rest-screen&quot; :class=&quot;{'remi-present-rest-screen': gameState.isRemiPresent}&quot;&gt;&#10;    &lt;div class=&quot;rest-screen-content&quot;&gt;&#10;      &lt;h1 class=&quot;rest-title&quot;&gt;{{ gameState.isRemiPresent ? '好好休息！' : '休整阶段'}}&lt;/h1&gt;&#10;      &#10;      &lt;div class=&quot;content-wrapper&quot;&gt;&#10;        &lt;!-- 左侧固定大小面板容器 --&gt;&#10;        &lt;div class=&quot;left-panel-container&quot;&gt;&#10;          &lt;!-- 金钱奖励面板 --&gt;&#10;          &lt;MoneyRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'money'&quot;&#10;            :amount=&quot;gameState.rewards.money&quot;&#10;            @claimed=&quot;onMoneyRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 突破奖励面板 --&gt;&#10;          &lt;BreakthroughRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'breakthrough'&quot;&#10;            @claimed=&quot;onBreakthroughRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 技能奖励面板 --&gt;&#10;          &lt;SkillRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'skill'&quot;&#10;            :skills=&quot;gameState.rewards.skills&quot;&#10;            @close=&quot;closeSkillRewardPanel&quot;&#10;            @selected-skill-reward=&quot;onSkillRewardSelected&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 能力奖励面板 --&gt;&#10;          &lt;AbilityRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'ability'&quot;&#10;            :abilities=&quot;gameState.rewards.abilities&quot;&#10;            @selected-ability-reward=&quot;onAbilityRewardSelected&quot;&#10;            @close=&quot;closeAbilityRewardPanel&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 商店面板 --&gt;&#10;          &lt;ShopPanel&#10;        :is-visible=&quot;currentRewardPanel === 'shop'&quot;&#10;        :shop-items=&quot;gameState.shopItems&quot;&#10;        :game-state=&quot;gameState&quot;&#10;        @close=&quot;closeShopPanel&quot;&#10;      /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;!-- 右侧玩家状态面板 --&gt;&#10;        &lt;PlayerStatusPanel :player=&quot;gameState.player&quot; :restScreen=&quot;true&quot;/&gt;&#10;      &lt;/div&gt;&#10;      &#10;      &lt;SkillSlotSelectionPanel&#10;        :is-visible=&quot;skillSlotSelectionPanelVisible&quot;&#10;        :skill-slots=&quot;gameState.player.skillSlots&quot;&#10;        :skill=&quot;claimingSkill&quot;&#10;        @select-slot=&quot;onSkillSlotSelected&quot;&#10;        @close=&quot;closeSkillSlotSelectionPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import AbilityRewardPanel from './AbilityRewardPanel.vue';&#10;import SkillRewardPanel from './SkillRewardPanel.vue';&#10;import SkillSlotSelectionPanel from './SkillSlotSelectionPanel.vue';&#10;import ShopPanel from './ShopPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import MoneyRewardPanel from './MoneyRewardPanel.vue';&#10;import BreakthroughRewardPanel from './BreakthroughRewardPanel.vue';&#10;import frontendEventBus from &quot;../frontendEventBus&quot;;&#10;import backendEventBus, { EventNames } from &quot;../backendEventBus&quot;;&#10;&#10;export default {&#10;  name: 'RestScreen',&#10;  components: {&#10;    ColoredText,&#10;    AbilityRewardPanel,&#10;    SkillRewardPanel,&#10;    SkillSlotSelectionPanel,&#10;    ShopPanel,&#10;    PlayerStatusPanel,&#10;    MoneyRewardPanel,&#10;    BreakthroughRewardPanel&#10;  },&#10;  props: {&#10;    gameState: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      currentRewardPanel: '', // 'money', 'breakthrough', 'skill', 'ability', 'shop' or empty&#10;      skillSlotSelectionPanelVisible: false,&#10;      claimingSkill: null,&#10;      rewardPanels: [],&#10;      currentRewardIndex: 0&#10;    }&#10;  },&#10;  mounted() {&#10;    // 初始化奖励面板队列&#10;    this.initRewardPanels();&#10;    // 显示第一个奖励面板&#10;    this.showNextRewardPanel();&#10;    // 监听后端商品购买，弹出UI消息&#10;    backendEventBus.on(EventNames.Shop.ITEM_PURCHASED, (purchasedItem) =&gt; {&#10;      frontendEventBus.emit(&quot;pop-message&quot;, {&#10;        id: 'item-purchased',&#10;        text: `购买了物品：${purchasedItem.name}`&#10;      });&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    backendEventBus.off &amp;&amp; backendEventBus.off(EventNames.Shop.ITEM_PURCHASED);&#10;  },&#10;  methods: {&#10;    initRewardPanels() {&#10;      this.rewardPanels = [];&#10;      &#10;      // 按顺序添加奖励面板&#10;      if (this.gameState.rewards.money &gt; 0) {&#10;        this.rewardPanels.push('money');&#10;      }&#10;      &#10;      if (this.gameState.rewards.breakthrough) {&#10;        this.rewardPanels.push('breakthrough');&#10;      }&#10;      &#10;      if (this.gameState.rewards.skills.length &gt; 0) {&#10;        this.rewardPanels.push('skill');&#10;      }&#10;      &#10;      if (this.gameState.rewards.abilities.length &gt; 0) {&#10;        this.rewardPanels.push('ability');&#10;      }&#10;      &#10;      // 总是添加商店面板&#10;      this.rewardPanels.push('shop'); &#10;    },&#10;    &#10;    showNextRewardPanel() {&#10;      // 先隐藏当前面板&#10;      this.currentRewardPanel = 'none';&#10;      // 稍等片刻后，再显示下一个面板&#10;      setTimeout(()=&gt; {&#10;        if (this.currentRewardIndex &lt; this.rewardPanels.length) {&#10;          this.currentRewardPanel = this.rewardPanels[this.currentRewardIndex];&#10;        } else {&#10;          // 所有奖励面板都已显示完毕&#10;          this.currentRewardPanel = '';&#10;        }&#10;      }, 500);&#10;    },&#10;    &#10;    onMoneyRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    onBreakthroughRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeSkillRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeAbilityRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;&#10;    onSkillRewardSelected(currentSkill) {&#10;      // 简化后的自动升级逻辑：如果奖励技能带有 upgradedFrom，直接替换来源技能&#10;      if(currentSkill.isUpgradeCandidate &amp;&amp; currentSkill.upgradedFrom) {&#10;        const slots = this.gameState.player.skillSlots;&#10;        const sourceSlotIndex = slots.findIndex(s =&gt; s &amp;&amp; s.name === currentSkill.upgradedFrom);&#10;        if(sourceSlotIndex !== -1) {&#10;          const oldSkill = slots[sourceSlotIndex];&#10;          backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;            skill: currentSkill,&#10;            slotIndex: sourceSlotIndex,&#10;            clearRewards: false&#10;          });&#10;          frontendEventBus.emit('pop-message', {&#10;            id: 'skill-upgraded',&#10;            text: `技能升级：${oldSkill.name} -&gt; ${currentSkill.name}`&#10;          });&#10;          this.closeSkillRewardPanel();&#10;          return;&#10;        }&#10;      }&#10;      // 回退：未能自动升级则进入槽位选择&#10;      this.claimingSkill = currentSkill;&#10;      setTimeout(() =&gt; { this.skillSlotSelectionPanelVisible = true; }, 300);&#10;    },&#10;    closeSkillSlotSelectionPanel() {&#10;      this.skillSlotSelectionPanelVisible = false;&#10;    },&#10;    onSkillSlotSelected(slotIndex) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;        skill: this.claimingSkill,&#10;        slotIndex,&#10;        clearRewards: false&#10;      });&#10;      // 关闭面板&#10;      this.closeSkillSlotSelectionPanel();&#10;      this.closeSkillRewardPanel();&#10;    },&#10;    onAbilityRewardSelected(ability) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_ABILITY, {&#10;        ability,&#10;        clearRewards: false&#10;      });&#10;      this.closeAbilityRewardPanel();&#10;    },&#10;    closeShopPanel() {&#10;      // 结束休整阶段，开始下一场战斗（后端流程监听）&#10;      backendEventBus.emit(EventNames.Rest.FINISH);&#10;    }&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.rest-screen {&#10;  height: 100%;&#10;  width: 100%;&#10;  background-size: cover;&#10;}&#10;&#10;.remi-present-rest-screen {&#10;  background-image: url('@assets/images/shop-background.png');&#10;}&#10;&#10;.rest-screen-content {&#10;  margin: 0 auto;&#10;  padding: 20px;&#10;  max-width: 1200px;&#10;}&#10;&#10;.content-wrapper {&#10;  display: flex;&#10;  flex-direction: row;&#10;  gap: 20px;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;}&#10;&#10;.rest-title {&#10;  font-size: 2em;&#10;  margin-bottom: 20px;&#10;  color: #eef7ff;&#10;}&#10;&#10;.left-panel-container {&#10;  width: 800px;&#10;  height: 220px;&#10;  position: relative;&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SkillCard.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SkillCard.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div &#10;    :class=&quot;['skill-card', { disabled: disabled }]&quot;&#10;    @click=&quot;onClick&quot;&#10;    @mouseenter=&quot;onMouseEnter&quot;&#10;    @mouseleave=&quot;onMouseLeave&quot;&#10;    :style=&quot;skillCardStyle&quot;&#10;  &gt;&#10;    &lt;div class=&quot;skill-card-background-paper&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;skill-card-background-image&quot; :style=&quot;{backgroundImage:`url(${skillCardImageUrl})`}&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;mana-cost&quot; v-if=&quot;skill.manaCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;mana-icon&quot;&gt;&lt;/span&gt;&#10;      &lt;span class=&quot;mana-value&quot; :class=&quot;{ 'insufficient-mana': playerMana &lt; skill.manaCost }&quot;&gt;{{ skill.manaCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;action-cost&quot; v-if=&quot;skill.actionPointCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;action-icon&quot;&gt;⚡&lt;/span&gt;&#10;      &lt;span class=&quot;action-value&quot;&gt;{{ skill.actionPointCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;skill-tier&quot;&gt;{{ getSkillTierLabel(skill.tier) }}&lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-subtitle', {'hovered': hovered}]&quot; v-if=&quot;skill.subtitle&quot;&gt; {{skill.subtitle}} &lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-card-panel']&quot;&gt;&#10;      &lt;div class=&quot;skill-name&quot; :style=&quot;{color: skillNameColor, borderColor: skillBackgroundColor}&quot;&gt;&#10;        {{ skill.name + (skill.power &lt; 0 ? '（' + skill.power + '）' : '') + (skill.power &gt; 0 ? '（+' + skill.power + '）' : '') }}&lt;/div&gt;&#10;      &lt;div class=&quot;skill-description&quot;&gt;&#10;        &lt;ColoredText :text=&quot;skillDescription&quot; /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;skill-uses&quot;&gt;&#10;        &lt;ColoredText v-if=&quot;skill.coldDownTurns != 0 &amp;&amp; skill.remainingUses != skill.maxUses &amp;&amp; !previewMode&quot; :text=&quot;`/named{重整} ${skill.remainingColdDownTurns}/${skill.coldDownTurns}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.coldDownTurns != 0&quot; :text=&quot;`/named{重整} ${skill.coldDownTurns} 回合`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.remainingUses != Infinity&quot; :text=&quot;`/named{消耗}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;br /&gt;&#10;        &lt;strong v-if=&quot;skill.maxUses === Infinity &amp;&amp; skill.coldDownTurns == 0&quot;&gt;无限&lt;/strong&gt;&#10;        &lt;span v-else-if=&quot;previewMode&quot;&gt;(装填 {{ skill.maxUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;        &lt;span v-else&gt;(装填 {{ skill.remainingUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import {getSkillTierColor, getSkillTierLabel} from '../utils/tierUtils.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;&#10;export default {&#10;  name: 'SkillCard',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    skill: {&#10;      type: Object,&#10;      required: true&#10;    },&#10;    player: {&#10;      type: Object,&#10;      required: false,&#10;      default: null&#10;    },&#10;    disabled: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    playerMana: {&#10;      type: Number,&#10;      default: Infinity&#10;    },&#10;    previewMode: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      hovered: false,&#10;    };&#10;  },&#10;  computed: {&#10;    skillDescription() {&#10;      // 动态根据玩家/技能当前状态生成描述&#10;      if (this.player &amp;&amp; typeof this.skill?.regenerateDescription === 'function') {&#10;        return this.skill.regenerateDescription(this.player);&#10;      }&#10;      if (typeof this.skill?.getDescription === 'function') {&#10;        return this.skill.getDescription();&#10;      }&#10;      return this.skill?.description || '';&#10;    },&#10;    skillNameColor() {&#10;      if(this.skill.power &lt; 0) {&#10;        return 'red';&#10;      } else if(this.skill.power &gt; 0) {&#10;        return 'green';&#10;      } else {&#10;        return 'black';&#10;      }&#10;    },&#10;    skillCardStyle () {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      const backgroundColor = this.adjustColorBrightness(color, 40);&#10;      const borderColor = this.adjustColorBrightness(color, -40);&#10;      return {&#10;        backgroundColor: backgroundColor,&#10;        borderColor: borderColor&#10;      };&#10;    },&#10;    skillBackgroundColor() {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      return this.adjustColorBrightness(color, 50);&#10;    },&#10;    skillCardImageUrl () {&#10;      let imageName = this.skill.image;&#10;      if(imageName) {} else {&#10;        imageName = `0`;&#10;        if (this.skill.tier &gt;= 2) imageName = '1';&#10;        if (this.skill.tier &gt;= 4) imageName = '2';&#10;        if (this.skill.tier &gt;= 6) imageName = '3';&#10;        if (this.skill.tier &gt;= 8) imageName = '4';&#10;        imageName = `${this.skill.type}-${imageName}.png`;&#10;      }&#10;      return new URL(`../assets/cards/${imageName}`, import.meta.url).href;&#10;    }&#10;  },&#10;  mounted() {&#10;    // 不再监听update-skill-descriptions事件，改由computed自动更新&#10;  },&#10;  beforeUnmount() {&#10;    // 无事件需要移除&#10;  },&#10;  methods: {&#10;    getSkillTierLabel,&#10;    adjustColorBrightness(color, percent) {&#10;      // 移除可能存在的#号&#10;      let hex = color.replace(/#/g, '');&#10;&#10;      // 验证颜色格式是否正确&#10;      if (hex.length !== 6) {&#10;        throw new Error('无效的颜色格式，请使用6位十六进制颜色，如&quot;#AACC12&quot;');&#10;      }&#10;&#10;      // 将十六进制转换为RGB分量&#10;      let r = parseInt(hex.substring(0, 2), 16);&#10;      let g = parseInt(hex.substring(2, 4), 16);&#10;      let b = parseInt(hex.substring(4, 6), 16);&#10;&#10;      // 计算调整值（基于百分比）&#10;      const factor = percent / 100;&#10;&#10;      // 调整每个颜色分量的亮度&#10;      r = Math.round(r + (255 - r) * factor);&#10;      g = Math.round(g + (255 - g) * factor);&#10;      b = Math.round(b + (255 - b) * factor);&#10;&#10;      // 确保值在0-255范围内&#10;      r = Math.min(255, Math.max(0, r));&#10;      g = Math.min(255, Math.max(0, g));&#10;      b = Math.min(255, Math.max(0, b));&#10;&#10;      // 将RGB转回十六进制，并确保两位表示&#10;      const toHex = (c) =&gt; {&#10;        const hex = c.toString(16);&#10;        return hex.length === 1 ? '0' + hex : hex;&#10;      };&#10;&#10;      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();&#10;    },&#10;    onClick(event) {&#10;      if (!this.disabled) {&#10;        // 播放技能激活动画&#10;        this.playActivationAnimation();&#10;        &#10;        this.$emit('skill-card-clicked', this.skill, event);&#10;      }&#10;    },&#10;    &#10;    onMouseEnter() {&#10;      this.hovered = true;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-start', this.skill);&#10;    },&#10;    &#10;    onMouseLeave() {&#10;      this.hovered = false;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-end', this.skill);&#10;    },&#10;    // 播放技能激活动画&#10;    playActivationAnimation() {&#10;      const card = this.$el;&#10;      if (!card) return;&#10;      &#10;      // 根据技能tier确定动画强度&#10;      const tier = this.skill.tier || 0;&#10;      const intensity = 2;&#10;      &#10;      // 添加动画类&#10;      card.classList.add('activating');&#10;      &#10;      // 设置动画样式&#10;      card.style.animationDuration = `${0.25 / intensity}s`;&#10;      &#10;      // 播放粒子特效&#10;      this.playParticleEffect(tier, card);&#10;      &#10;      // 动画结束后清理&#10;      setTimeout(() =&gt; {&#10;        card.classList.remove('activating');&#10;        card.style.animationDuration = '';&#10;      }, 500 / intensity);&#10;    },&#10;    // 播放粒子特效&#10;    playParticleEffect(tier, card) {&#10;      // 根据tier确定粒子参数&#10;      const tierSettings = {&#10;        '-1': { count: 5, size: 3, color: '#333333' },   // curses&#10;        '0': { count: 15, size: 3, color: '#000000' },     // D&#10;        '1': { count: 20, size: 4, color: '#41db39' },     // C-&#10;        '2': { count: 30, size: 5, color: '#41db39' },    // C+&#10;        '3': { count: 40, size: 6, color: '#759eff' },    // B-&#10;        '4': { count: 50, size: 7, color: '#759eff' },    // B&#10;        '5': { count: 60, size: 8, color: '#d072ff' },    // B+&#10;        '6': { count: 60, size: 9, color: '#d072ff' },    // A-&#10;        '7': { count: 60, size: 10, color: '#ff9059' },   // A&#10;        '8': { count: 60, size: 11, color: '#ff9059' },   // A+&#10;        '9': { count: 60, size: 12, color: '#ff0000' }    // S&#10;      };&#10;      &#10;      const settings = tierSettings[tier] || tierSettings['0'];&#10;      &#10;      // 创建粒子数组&#10;      const particles = [];&#10;      &#10;      // 获取卡片的绝对位置&#10;      const cardRect = card.getBoundingClientRect();&#10;      &#10;      // 生成粒子&#10;      for (let i = 0; i &lt; settings.count; i++) {&#10;        // 随机运动方向和距离，确保粒子向四周逸散&#10;        const distance = 30 + Math.random() * 70; // 随机距离(30-100px)&#10;        const velocity = 10 + Math.random() * 20; // 随机速度&#10;        &#10;        // 计算卡牌边缘的随机起始位置（相对坐标）&#10;        const edge = Math.floor(Math.random() * 4); // 0:上, 1:右, 2:下, 3:左&#10;        let startX, startY;&#10;        &#10;        switch (edge) {&#10;          case 0: // 上边缘&#10;            startX = Math.random() * cardRect.width; // 使用实际卡片宽度&#10;            startY = 0;&#10;            break;&#10;          case 1: // 右边缘&#10;            startX = cardRect.width;&#10;            startY = Math.random() * cardRect.height; // 使用实际卡片高度&#10;            break;&#10;          case 2: // 下边缘&#10;            startX = Math.random() * cardRect.width;&#10;            startY = cardRect.height;&#10;            break;&#10;          case 3: // 左边缘&#10;            startX = 0;&#10;            startY = Math.random() * cardRect.height;&#10;            break;&#10;        }&#10;&#10;        // 计算飞离卡牌的方向&#10;        const deltaCenterX = startX - cardRect.width / 2;&#10;        const deltaCenterY = startY - cardRect.height / 2;&#10;        const angle = Math.random() * 0.2 + Math.atan2(deltaCenterY, deltaCenterX); // 随机角度&#10;        &#10;        // 将相对坐标转换为绝对坐标&#10;        const absoluteX = cardRect.left + startX;&#10;        const absoluteY = cardRect.top + startY;&#10;        &#10;        const particle = {&#10;          x: absoluteX, // 绝对位置&#10;          y: absoluteY, // 绝对位置&#10;          vx: Math.cos(angle) * velocity,&#10;          vy: Math.sin(angle) * velocity,&#10;          life: 1000, // 生命周期1秒&#10;          color: settings.color,&#10;          size: settings.size,&#10;          opacity: 1,&#10;          opacityFade: true,&#10;          gravity: 0, // 可以根据需要添加重力&#10;          zIndex: 0 // 刚好能被skill card panel遮住&#10;        };&#10;        &#10;        particles.push(particle);&#10;      }&#10;      &#10;      // 通过事件总线触发粒子特效&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-card-panel {&#10;  z-index: 1;&#10;  width: 150px;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 16px;&#10;  padding:2px;&#10;  border-radius: 8px;&#10;  border-width: 3px;&#10;  border-style: solid;&#10;  margin: 0 auto 8px auto;&#10;}&#10;&#10;.skill-description {&#10;  font-size: 14px;&#10;  margin-bottom: 8px;&#10;  text-align: center;&#10;}&#10;&#10;.skill-uses {&#10;  font-size: 12px;&#10;  color: #666;&#10;}&#10;&#10;.skill-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.mana-cost {&#10;  position: absolute;&#10;  top: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.mana-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.mana-value {&#10;  font-weight: bold;&#10;  color: #2196f3;&#10;  font-size: 16px;&#10;}&#10;&#10;.mana-value.insufficient-mana {&#10;  color: #f44336;&#10;}&#10;&#10;.action-cost {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.action-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.action-value {&#10;  font-weight: bold;&#10;  color: #ff9800;&#10;  font-size: 16px;&#10;}&#10;&#10;.skill-subtitle {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  right: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  color: rgba(200, 200, 200, 0.7);&#10;  font-size: 12px;&#10;  font-style: italic;&#10;  transition: 0.5s ease;&#10;}&#10;.skill-subtitle.hovered {&#10;  color: black;&#10;  background-color: rgba(255, 255, 255, 0.7);&#10;}&#10;&#10;.skill-card {&#10;  width: 192px;&#10;  height: 260px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  /* transition: all 0.3s ease; */&#10;  position: relative;&#10;  transition: all 0.3s ease;&#10;&#10;  border: 3px solid #eee;&#10;  border-radius: 5px;&#10;}&#10;&#10;.skill-card:hover {&#10;  transform: translateY(-2px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.skill-card.disabled {&#10;  opacity: 0.5;&#10;  cursor: not-allowed;&#10;  transform: none;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;}&#10;&#10;/* 垫在skill-card上，用来铺上一个白色背景*/&#10;.skill-card-background-paper {&#10;  position: absolute;&#10;  width: 180px;&#10;  height: 240px;&#10;  background-color: white;&#10;}&#10;&#10;.skill-card-background-image {&#10;  position: absolute;&#10;  width: 212px;&#10;  height: 280px;&#10;  background-origin: content-box;&#10;  background-position: center;&#10;  background-repeat: no-repeat;&#10;  background-size: cover;&#10;}&#10;&#10;/* 技能激活动画关键帧 */&#10;@keyframes skillActivation {&#10;  0% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;  50% {&#10;    transform: scale(1.1);&#10;    box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);&#10;    filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;}&#10;&#10;.skill-card.activating {&#10;  z-index: 100;&#10;  animation-name: skillActivation;&#10;  animation-timing-function: ease-in-out;&#10;  animation-fill-mode: forwards;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div &#10;    :class=&quot;['skill-card', { disabled: disabled }]&quot;&#10;    @click=&quot;onClick&quot;&#10;    @mouseenter=&quot;onMouseEnter&quot;&#10;    @mouseleave=&quot;onMouseLeave&quot;&#10;    :style=&quot;skillCardStyle&quot;&#10;  &gt;&#10;    &lt;div class=&quot;skill-card-background-paper&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;skill-card-background-image&quot; :style=&quot;{backgroundImage:`url(${skillCardImageUrl})`}&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;upgrade-badge&quot; v-if=&quot;skill.isUpgradeCandidate&quot;&gt;升级&lt;/div&gt;&#10;    &lt;div &#10;      v-if=&quot;hovered &amp;&amp; skill.isUpgradeCandidate &amp;&amp; skill.upgradedFrom&quot;&#10;      class=&quot;upgrade-replace-tooltip&quot;&#10;    &gt;将替换：{{ skill.upgradedFrom }}&lt;/div&gt;&#10;    &lt;div class=&quot;mana-cost&quot; v-if=&quot;skill.manaCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;mana-icon&quot;&gt;&lt;/span&gt;&#10;      &lt;span class=&quot;mana-value&quot; :class=&quot;{ 'insufficient-mana': playerMana &lt; skill.manaCost }&quot;&gt;{{ skill.manaCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;action-cost&quot; v-if=&quot;skill.actionPointCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;action-icon&quot;&gt;⚡&lt;/span&gt;&#10;      &lt;span class=&quot;action-value&quot;&gt;{{ skill.actionPointCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;skill-tier&quot;&gt;{{ getSkillTierLabel(skill.tier) }}&lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-subtitle', {'hovered': hovered}]&quot; v-if=&quot;skill.subtitle&quot;&gt; {{skill.subtitle}} &lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-card-panel']&quot;&gt;&#10;      &lt;div class=&quot;skill-name&quot; :style=&quot;{color: skillNameColor, borderColor: skillBackgroundColor}&quot;&gt;&#10;        {{ skill.name + (skill.power &lt; 0 ? '（' + skill.power + '）' : '') + (skill.power &gt; 0 ? '（+' + skill.power + '）' : '') }}&lt;/div&gt;&#10;      &lt;div class=&quot;skill-description&quot;&gt;&#10;        &lt;ColoredText :text=&quot;skillDescription&quot; /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;skill-uses&quot;&gt;&#10;        &lt;ColoredText v-if=&quot;skill.coldDownTurns != 0 &amp;&amp; skill.remainingUses != skill.maxUses &amp;&amp; !previewMode&quot; :text=&quot;`/named{重整} ${skill.remainingColdDownTurns}/${skill.coldDownTurns}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.coldDownTurns != 0&quot; :text=&quot;`/named{重整} ${skill.coldDownTurns} 回合`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.remainingUses != Infinity&quot; :text=&quot;`/named{消耗}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;br /&gt;&#10;        &lt;strong v-if=&quot;skill.maxUses === Infinity &amp;&amp; skill.coldDownTurns == 0&quot;&gt;无限&lt;/strong&gt;&#10;        &lt;span v-else-if=&quot;previewMode&quot;&gt;(装填 {{ skill.maxUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;        &lt;span v-else&gt;(装填 {{ skill.remainingUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import {getSkillTierColor, getSkillTierLabel} from '../utils/tierUtils.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;&#10;export default {&#10;  name: 'SkillCard',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    skill: {&#10;      type: Object,&#10;      required: true&#10;    },&#10;    player: {&#10;      type: Object,&#10;      required: false,&#10;      default: null&#10;    },&#10;    disabled: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    playerMana: {&#10;      type: Number,&#10;      default: Infinity&#10;    },&#10;    previewMode: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      hovered: false,&#10;    };&#10;  },&#10;  computed: {&#10;    skillDescription() {&#10;      // 动态根据玩家/技能当前状态生成描述&#10;      if (this.player &amp;&amp; typeof this.skill?.regenerateDescription === 'function') {&#10;        return this.skill.regenerateDescription(this.player);&#10;      }&#10;      if (typeof this.skill?.getDescription === 'function') {&#10;        return this.skill.getDescription();&#10;      }&#10;      return this.skill?.description || '';&#10;    },&#10;    skillNameColor() {&#10;      if(this.skill.power &lt; 0) {&#10;        return 'red';&#10;      } else if(this.skill.power &gt; 0) {&#10;        return 'green';&#10;      } else {&#10;        return 'black';&#10;      }&#10;    },&#10;    skillCardStyle () {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      const backgroundColor = this.adjustColorBrightness(color, 40);&#10;      const borderColor = this.adjustColorBrightness(color, -40);&#10;      return {&#10;        backgroundColor: backgroundColor,&#10;        borderColor: borderColor&#10;      };&#10;    },&#10;    skillBackgroundColor() {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      return this.adjustColorBrightness(color, 50);&#10;    },&#10;    skillCardImageUrl () {&#10;      let imageName = this.skill.image;&#10;      if(imageName) {} else {&#10;        imageName = `0`;&#10;        if (this.skill.tier &gt;= 2) imageName = '1';&#10;        if (this.skill.tier &gt;= 4) imageName = '2';&#10;        if (this.skill.tier &gt;= 6) imageName = '3';&#10;        if (this.skill.tier &gt;= 8) imageName = '4';&#10;        imageName = `${this.skill.type}-${imageName}.png`;&#10;      }&#10;      return new URL(`../assets/cards/${imageName}`, import.meta.url).href;&#10;    }&#10;  },&#10;  mounted() {&#10;    // 不再监听update-skill-descriptions事件，改由computed自动更新&#10;  },&#10;  beforeUnmount() {&#10;    // 无事件需要移除&#10;  },&#10;  methods: {&#10;    getSkillTierLabel,&#10;    adjustColorBrightness(color, percent) {&#10;      // 移除可能存在的#号&#10;      let hex = color.replace(/#/g, '');&#10;&#10;      // 验证颜色格式是否正确&#10;      if (hex.length !== 6) {&#10;        throw new Error('无效的颜色格式，请使用6位十六进制颜色，如&quot;#AACC12&quot;');&#10;      }&#10;&#10;      // 将十六进制转换为RGB分量&#10;      let r = parseInt(hex.substring(0, 2), 16);&#10;      let g = parseInt(hex.substring(2, 4), 16);&#10;      let b = parseInt(hex.substring(4, 6), 16);&#10;&#10;      // 计算调整值（基于百分比）&#10;      const factor = percent / 100;&#10;&#10;      // 调整每个颜色分量的亮度&#10;      r = Math.round(r + (255 - r) * factor);&#10;      g = Math.round(g + (255 - g) * factor);&#10;      b = Math.round(b + (255 - b) * factor);&#10;&#10;      // 确保值在0-255范围内&#10;      r = Math.min(255, Math.max(0, r));&#10;      g = Math.min(255, Math.max(0, g));&#10;      b = Math.min(255, Math.max(0, b));&#10;&#10;      // 将RGB转回十六进制，并确保两位表示&#10;      const toHex = (c) =&gt; {&#10;        const hex = c.toString(16);&#10;        return hex.length === 1 ? '0' + hex : hex;&#10;      };&#10;&#10;      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();&#10;    },&#10;    onClick(event) {&#10;      if (!this.disabled) {&#10;        // 播放技能激活动画&#10;        this.playActivationAnimation();&#10;        &#10;        this.$emit('skill-card-clicked', this.skill, event);&#10;      }&#10;    },&#10;    &#10;    onMouseEnter() {&#10;      this.hovered = true;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-start', this.skill);&#10;    },&#10;    &#10;    onMouseLeave() {&#10;      this.hovered = false;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-end', this.skill);&#10;    },&#10;    // 播放技能激活动画&#10;    playActivationAnimation() {&#10;      const card = this.$el;&#10;      if (!card) return;&#10;      &#10;      // 根据技能tier确定动画强度&#10;      const tier = this.skill.tier || 0;&#10;      const intensity = 2;&#10;      &#10;      // 添加动画类&#10;      card.classList.add('activating');&#10;      &#10;      // 设置动画样式&#10;      card.style.animationDuration = `${0.25 / intensity}s`;&#10;      &#10;      // 播放粒子特效&#10;      this.playParticleEffect(tier, card);&#10;      &#10;      // 动画结束后清理&#10;      setTimeout(() =&gt; {&#10;        card.classList.remove('activating');&#10;        card.style.animationDuration = '';&#10;      }, 500 / intensity);&#10;    },&#10;    // 播放粒子特效&#10;    playParticleEffect(tier, card) {&#10;      // 根据tier确定粒子参数&#10;      const tierSettings = {&#10;        '-1': { count: 5, size: 3, color: '#333333' },   // curses&#10;        '0': { count: 15, size: 3, color: '#000000' },     // D&#10;        '1': { count: 20, size: 4, color: '#41db39' },     // C-&#10;        '2': { count: 30, size: 5, color: '#41db39' },    // C+&#10;        '3': { count: 40, size: 6, color: '#759eff' },    // B-&#10;        '4': { count: 50, size: 7, color: '#759eff' },    // B&#10;        '5': { count: 60, size: 8, color: '#d072ff' },    // B+&#10;        '6': { count: 60, size: 9, color: '#d072ff' },    // A-&#10;        '7': { count: 60, size: 10, color: '#ff9059' },   // A&#10;        '8': { count: 60, size: 11, color: '#ff9059' },   // A+&#10;        '9': { count: 60, size: 12, color: '#ff0000' }    // S&#10;      };&#10;      &#10;      const settings = tierSettings[tier] || tierSettings['0'];&#10;      &#10;      // 创建粒子数组&#10;      const particles = [];&#10;      &#10;      // 获取卡片的绝对位置&#10;      const cardRect = card.getBoundingClientRect();&#10;      &#10;      // 生成粒子&#10;      for (let i = 0; i &lt; settings.count; i++) {&#10;        // 随机运动方向和距离，确保粒子向四周逸散&#10;        const distance = 30 + Math.random() * 70; // 随机距离(30-100px)&#10;        const velocity = 10 + Math.random() * 20; // 随机速度&#10;        &#10;        // 计算卡牌边缘的随机起始位置（相对坐标）&#10;        const edge = Math.floor(Math.random() * 4); // 0:上, 1:右, 2:下, 3:左&#10;        let startX, startY;&#10;        &#10;        switch (edge) {&#10;          case 0: // 上边缘&#10;            startX = Math.random() * cardRect.width; // 使用实际卡片宽度&#10;            startY = 0;&#10;            break;&#10;          case 1: // 右边缘&#10;            startX = cardRect.width;&#10;            startY = Math.random() * cardRect.height; // 使用实际卡片高度&#10;            break;&#10;          case 2: // 下边缘&#10;            startX = Math.random() * cardRect.width;&#10;            startY = cardRect.height;&#10;            break;&#10;          case 3: // 左边缘&#10;            startX = 0;&#10;            startY = Math.random() * cardRect.height;&#10;            break;&#10;        }&#10;&#10;        // 计算飞离卡牌的方向&#10;        const deltaCenterX = startX - cardRect.width / 2;&#10;        const deltaCenterY = startY - cardRect.height / 2;&#10;        const angle = Math.random() * 0.2 + Math.atan2(deltaCenterY, deltaCenterX); // 随机角度&#10;        &#10;        // 将相对坐标转换为绝对坐标&#10;        const absoluteX = cardRect.left + startX;&#10;        const absoluteY = cardRect.top + startY;&#10;        &#10;        const particle = {&#10;          x: absoluteX, // 绝对位置&#10;          y: absoluteY, // 绝对位置&#10;          vx: Math.cos(angle) * velocity,&#10;          vy: Math.sin(angle) * velocity,&#10;          life: 1000, // 生命周期1秒&#10;          color: settings.color,&#10;          size: settings.size,&#10;          opacity: 1,&#10;          opacityFade: true,&#10;          gravity: 0, // 可以根据需要添加重力&#10;          zIndex: 0 // 刚好能被skill card panel遮住&#10;        };&#10;        &#10;        particles.push(particle);&#10;      }&#10;      &#10;      // 通过事件总线触发粒子特效&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-card-panel {&#10;  z-index: 1;&#10;  width: 150px;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 16px;&#10;  padding:2px;&#10;  border-radius: 8px;&#10;  border-width: 3px;&#10;  border-style: solid;&#10;  margin: 0 auto 8px auto;&#10;}&#10;&#10;.skill-description {&#10;  font-size: 14px;&#10;  margin-bottom: 8px;&#10;  text-align: center;&#10;}&#10;&#10;.skill-uses {&#10;  font-size: 12px;&#10;  color: #666;&#10;}&#10;&#10;.skill-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.mana-cost {&#10;  position: absolute;&#10;  top: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.mana-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.mana-value {&#10;  font-weight: bold;&#10;  color: #2196f3;&#10;  font-size: 16px;&#10;}&#10;&#10;.mana-value.insufficient-mana {&#10;  color: #f44336;&#10;}&#10;&#10;.action-cost {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.action-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.action-value {&#10;  font-weight: bold;&#10;  color: #ff9800;&#10;  font-size: 16px;&#10;}&#10;&#10;.skill-subtitle {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  right: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  color: rgba(200, 200, 200, 0.7);&#10;  font-size: 12px;&#10;  font-style: italic;&#10;  transition: 0.5s ease;&#10;}&#10;.skill-subtitle.hovered {&#10;  color: black;&#10;  background-color: rgba(255, 255, 255, 0.7);&#10;}&#10;&#10;.skill-card {&#10;  width: 192px;&#10;  height: 260px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  /* transition: all 0.3s ease; */&#10;  position: relative;&#10;  transition: all 0.3s ease;&#10;&#10;  border: 3px solid #eee;&#10;  border-radius: 5px;&#10;}&#10;&#10;.skill-card:hover {&#10;  transform: translateY(-2px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.skill-card.disabled {&#10;  opacity: 0.5;&#10;  cursor: not-allowed;&#10;  transform: none;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;}&#10;&#10;/* 垫在skill-card上，用来铺上一个白色背景*/&#10;.skill-card-background-paper {&#10;  position: absolute;&#10;  width: 180px;&#10;  height: 240px;&#10;  background-color: white;&#10;}&#10;&#10;.skill-card-background-image {&#10;  position: absolute;&#10;  width: 212px;&#10;  height: 280px;&#10;  background-origin: content-box;&#10;  background-position: center;&#10;  background-repeat: no-repeat;&#10;  background-size: cover;&#10;}&#10;&#10;/* 技能激活动画关键帧 */&#10;@keyframes skillActivation {&#10;  0% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;  50% {&#10;    transform: scale(1.1);&#10;    box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);&#10;    filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;}&#10;&#10;.skill-card.activating {&#10;  z-index: 100;&#10;  animation-name: skillActivation;&#10;  animation-timing-function: ease-in-out;&#10;  animation-fill-mode: forwards;&#10;}&#10;&#10;.upgrade-badge {&#10;  position: absolute;&#10;  top: 4px;&#10;  left: 4px;&#10;  background: linear-gradient(135deg, #ffcc33, #ff8800);&#10;  color: #222;&#10;  font-weight: bold;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  font-size: 12px;&#10;  box-shadow: 0 0 4px rgba(0,0,0,0.4);&#10;  z-index: 2;&#10;}&#10;.upgrade-replace-tooltip {&#10;  position: absolute;&#10;  bottom: -6px;&#10;  left: 50%;&#10;  transform: translate(-50%, 100%);&#10;  background: rgba(255,255,255,0.95);&#10;  color: #222;&#10;  padding: 4px 8px;&#10;  border-radius: 6px;&#10;  font-size: 12px;&#10;  font-weight: 600;&#10;  white-space: nowrap;&#10;  box-shadow: 0 2px 6px rgba(0,0,0,0.25);&#10;  border: 1px solid #e0e0e0;&#10;  z-index: 10;&#10;  pointer-events: none;&#10;  animation: fadeIn 0.18s ease-out;&#10;}&#10;@keyframes fadeIn {&#10;  from { opacity: 0; transform: translate(-50%, 120%); }&#10;  to { opacity: 1; transform: translate(-50%, 100%); }&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SkillRewardPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SkillRewardPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;skill-reward-panel-wrapper&quot;&gt;&#10;    &lt;div class=&quot;skill-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#10;      &lt;h2&gt;选择一个技能！&lt;/h2&gt;&#10;      &lt;div class=&quot;skill-cards&quot;&gt;&#10;        &lt;SkillCard&#10;          v-for=&quot;(skill, index) in skills&quot; &#10;          :key=&quot;'skill-' + index&quot;&#10;          :skill=&quot;skill&quot;&#10;          :preview-mode=&quot;true&quot;&#10;          @skill-card-clicked=&quot;onSkillCardClicked&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition-group&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import SkillCard from './SkillCard.vue';&#10;export default {&#10;  name: 'SkillRewardPanel',&#10;  components: {&#10;    SkillCard&#10;  },&#10;  props: {&#10;    skills: {&#10;      type: Array,&#10;      default: () =&gt; []&#10;    },&#10;    isVisible: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  methods: {&#10;    onSkillCardClicked(skill) {&#10;      this.$emit('selected-skill-reward', skill);&#10;    },&#10;    closePanel() {&#10;      this.$emit('close');&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-reward-panel {&#10;  border: 1px solid #4caf50; /* 绿色边框 */&#10;  padding: 20px;&#10;  background: linear-gradient(135deg, #e8f5e9, #c8e6c9); /* 绿色渐变背景 */&#10;  max-width: 80%;&#10;  margin: 20px auto;&#10;  box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);&#10;  border-radius: 8px;&#10;}&#10;&#10;.skill-reward-panel h2 {&#10;  text-align: center;&#10;  margin-bottom: 20px;&#10;  color: #2e7d32; /* 深绿色文字 */&#10;}&#10;&#10;.skill-cards {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 20px;&#10;  margin: 20px 0;&#10;  justify-content: center;&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 1.2em;&#10;  margin-bottom: 10px;&#10;  color: #333;&#10;}&#10;&#10;.skill-description {&#10;  color: #666;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.skill-tier {&#10;  font-style: italic;&#10;  color: #999;&#10;}&#10;&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;  background-color: #4caf50; /* 绿色按钮 */&#10;  color: white;&#10;  border: none;&#10;  border-radius: 4px;&#10;}&#10;&#10;button:hover:not(:disabled) {&#10;  background-color: #43a047; /* 深一点的绿色 */&#10;}&#10;&#10;/* 滑动进入和退出动画 */&#10;.slide-enter-active, .slide-leave-active {&#10;  transition: all 0.5s ease;&#10;}&#10;&#10;.slide-enter-from {&#10;  transform: translateY(100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-leave-to {&#10;  transform: translateY(-100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-enter-to, .slide-leave-from {&#10;  transform: translateY(0);&#10;  opacity: 1;&#10;}&#10;&#10;/* 为transition-group添加样式 */&#10;.skill-reward-panel-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;skill-reward-panel-wrapper&quot;&gt;&#13;&#10;    &lt;div class=&quot;skill-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#13;&#10;      &lt;h2&gt;选择一个技能！&lt;/h2&gt;&#13;&#10;      &lt;div class=&quot;skill-cards&quot;&gt;&#13;&#10;        &lt;SkillCard&#13;&#10;          v-for=&quot;(skill, index) in skills&quot; &#13;&#10;          :key=&quot;skill.uniqueID&quot;&#13;&#10;          :skill=&quot;skill&quot;&#13;&#10;          :preview-mode=&quot;true&quot;&#13;&#10;          @skill-card-clicked=&quot;onSkillCardClicked&quot;&#13;&#10;        /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  &lt;/transition-group&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import SkillCard from './SkillCard.vue';&#13;&#10;export default {&#13;&#10;  name: 'SkillRewardPanel',&#13;&#10;  components: {&#13;&#10;    SkillCard&#13;&#10;  },&#13;&#10;  props: {&#13;&#10;    skills: {&#13;&#10;      type: Array,&#13;&#10;      default: () =&gt; []&#13;&#10;    },&#13;&#10;    isVisible: {&#13;&#10;      type: Boolean,&#13;&#10;      default: false&#13;&#10;    }&#13;&#10;  },&#13;&#10;  methods: {&#13;&#10;    onSkillCardClicked(skill) {&#13;&#10;      this.$emit('selected-skill-reward', skill);&#13;&#10;    },&#13;&#10;    closePanel() {&#13;&#10;      this.$emit('close');&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.skill-reward-panel {&#13;&#10;  border: 1px solid #4caf50; /* 绿色边框 */&#13;&#10;  padding: 20px;&#13;&#10;  background: linear-gradient(135deg, #e8f5e9, #c8e6c9); /* 绿色渐变背景 */&#13;&#10;  max-width: 80%;&#13;&#10;  margin: 20px auto;&#13;&#10;  box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);&#13;&#10;  border-radius: 8px;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-reward-panel h2 {&#13;&#10;  text-align: center;&#13;&#10;  margin-bottom: 20px;&#13;&#10;  color: #2e7d32; /* 深绿色文字 */&#13;&#10;}&#13;&#10;&#13;&#10;.skill-cards {&#13;&#10;  display: flex;&#13;&#10;  flex-wrap: wrap;&#13;&#10;  gap: 20px;&#13;&#10;  margin: 20px 0;&#13;&#10;  justify-content: center;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-name {&#13;&#10;  font-weight: bold;&#13;&#10;  font-size: 1.2em;&#13;&#10;  margin-bottom: 10px;&#13;&#10;  color: #333;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-description {&#13;&#10;  color: #666;&#13;&#10;  margin-bottom: 10px;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-tier {&#13;&#10;  font-style: italic;&#13;&#10;  color: #999;&#13;&#10;}&#13;&#10;&#13;&#10;button {&#13;&#10;  padding: 10px 15px;&#13;&#10;  margin: 5px;&#13;&#10;  cursor: pointer;&#13;&#10;  background-color: #4caf50; /* 绿色按钮 */&#13;&#10;  color: white;&#13;&#10;  border: none;&#13;&#10;  border-radius: 4px;&#13;&#10;}&#13;&#10;&#13;&#10;button:hover:not(:disabled) {&#13;&#10;  background-color: #43a047; /* 深一点的绿色 */&#13;&#10;}&#13;&#10;&#13;&#10;/* 滑动进入和退出动画 */&#13;&#10;.slide-enter-active, .slide-leave-active {&#13;&#10;  transition: all 0.5s ease;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-enter-from {&#13;&#10;  transform: translateY(100%);&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-leave-to {&#13;&#10;  transform: translateY(-100%);&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-enter-to, .slide-leave-from {&#13;&#10;  transform: translateY(0);&#13;&#10;  opacity: 1;&#13;&#10;}&#13;&#10;&#13;&#10;/* 为transition-group添加样式 */&#13;&#10;.skill-reward-panel-wrapper {&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/data/ability.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/data/ability.js" />
              <option name="originalContent" value="import { upgradePlayerTier } from &quot;./player.js&quot;;&#10;&#10;// 能力抽象类&#10;class Ability {&#10;  constructor(name, description, tier, spawnWeight = 1) {&#10;    this.name = name; // 能力名称&#10;    this.description = description; // 能力描述&#10;    this.tier = tier || 1; // 能力等阶，默认为1&#10;    this.spawnWeight = spawnWeight; // 能力生成权重，默认为1&#10;  // 应用能力效果&#10;  apply(player) {&#10;    // 子类需要实现具体逻辑&#10;  }&#10;}&#10;&#10;// 突破能力&#10;class Breakthrough extends Ability {&#10;  constructor() {&#10;    super('额外突破', '再/named{突破}一次！', 5, 0.2);&#10;  }&#10;&#10;  apply(player) {&#10;    upgradePlayerTier(player);&#10;  }&#10;}&#10;&#10;// 强化能力&#10;class Strengthen extends Ability {&#10;  constructor() {&#10;    super('全面强化', '/named{防御}、/named{灵能}各增1。', 5, 0.8);&#10;  }&#10;&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.baseDefense += 1;&#10;    player.baseMagic += 1;&#10;  }&#10;}&#10;&#10;// 成长能力&#10;class Growth extends Ability {&#10;  constructor() {&#10;    super('成长', '/named{生命}上限增15。', 4, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.maxHp += 15;&#10;    player.hp += 15; // 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 小睡&#10;export class NapRest extends Ability {&#10;  constructor() {&#10;    super('小睡', '/named{生命}恢复10%，上限增加5。', 1, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 5;&#10;    player.hp = Math.min(player.maxHp, player.hp + &#10;      Math.floor(player.maxHp * 0.1)&#10;    );&#10;  }&#10;}&#10;&#10;// 休养&#10;export class WellRest extends Ability {&#10;  constructor() {&#10;    super('休养', '/named{生命}恢复40%，上限增加2。', 1, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 2;&#10;    player.hp = Math.min(&#10;      player.maxHp, &#10;      player.hp + Math.floor(player.maxHp * 0.4));&#10;  }&#10;}&#10;&#10;// 锻炼&#10;class Exercise extends Ability {&#10;  constructor() {&#10;    super('锻炼', '/named{生命}上限增8。', 2, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 7;&#10;    player.hp += 7; // 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 专业锻炼&#10;class ExpertExercise extends Ability {&#10;  constructor() {&#10;    super('专业锻炼', '/named{生命}上限增15。', 2, 0.5);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 15;&#10;    player.hp += 15;// 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 冥想&#10;class MindExercise extends Ability {&#10;  constructor() {&#10;    super('冥想', '获得1/named{灵能}。', 3, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseMagic += 1;&#10;  }&#10;}&#10;&#10;// 龟缩训练&#10;class TurtoiseExercise extends Ability {&#10;  constructor() {&#10;    super('龟缩训练', '/named{防御}增1，最大/named{生命}减12。', 3, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseDefense += 1;&#10;    player.maxHp = Math.max(1, player.maxHp - 12);&#10;    player.hp = Math.min(player.maxHp, player.hp);&#10;  }&#10;}&#10;&#10;// 修炼&#10;class Cultivation extends Ability {&#10;  constructor() {&#10;    super('修炼', '/named{灵能}增1，获得1魏启上限，恢复所有/named{魏启}。', 4, 0.5);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseMagic += 1;&#10;    player.maxMana += 1;&#10;    player.mana = player.maxMana; // 恢复所有魏启&#10;  }&#10;}&#10;&#10;export { Ability, Breakthrough, Strengthen, Growth, Cultivation,&#10;   MindExercise, TurtoiseExercise, Exercise, ExpertExercise}&#10;&#10;export class BitterCultivation extends Ability {&#10;  constructor() {&#10;    super('苦修', '/named{灵能}增2。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseMagic += 2;&#10;    // player.baseAttack = Math.max(0, player.baseAttack - 1);&#10;  }&#10;}&#10;&#10;export class BitterBodyCultivation extends Ability {&#10;  constructor() {&#10;    super('爆发训练', '/named{灵能}增1，/named{防御}减1。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.baseMagic += 1;&#10;    player.baseDefense = Math.max(0, player.baseDefense - 1);&#10;  }&#10;}&#10;&#10;export class DefenseCultivation extends Ability {&#10;  constructor() {&#10;    super('防御训练', '/named{防御}增1。', 4, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseDefense += 1;&#10;  }&#10;}&#10;&#10;export class SpecialDefenseCultivation extends Ability {&#10;  constructor() {&#10;    super('特化防御训练', '/named{防御}增2，/named{灵能}减1。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseDefense += 2;&#10;    player.baseMagic = Math.max(0, player.baseMagic - 1);&#10;  }&#10;}" />
              <option name="updatedContent" value="import { upgradePlayerTier } from &quot;./player.js&quot;;&#10;&#10;// 能力抽象类&#10;class Ability {&#10;  constructor(name, description, tier, spawnWeight = 1) {&#10;    this.name = name; // 能力名称&#10;    this.description = description; // 能力描述&#10;    this.tier = tier || 1; // 能力等级，默认为1&#10;    this.spawnWeight = spawnWeight; // 能力生成权重，默认为1&#10;    // 为每个实例生成唯一ID（用于动画同步与列表key）&#10;    this.uniqueID = Math.random().toString(36).substring(2, 10);&#10;  }&#10;  // 应用能力效果&#10;  apply(player) {&#10;    // 子类需要实现具体逻辑&#10;  }&#10;}&#10;&#10;// 突破能力&#10;class Breakthrough extends Ability {&#10;  constructor() {&#10;    super('额外突破', '再/named{突破}一次！', 5, 0.2);&#10;  }&#10;&#10;  apply(player) {&#10;    upgradePlayerTier(player);&#10;  }&#10;}&#10;&#10;// 强化能力&#10;class Strengthen extends Ability {&#10;  constructor() {&#10;    super('全面强化', '/named{防御}、/named{灵能}各增1。', 5, 0.8);&#10;  }&#10;&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.baseDefense += 1;&#10;    player.baseMagic += 1;&#10;  }&#10;}&#10;&#10;// 成长能力&#10;class Growth extends Ability {&#10;  constructor() {&#10;    super('成长', '/named{生命}上限增15。', 4, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.maxHp += 15;&#10;    player.hp += 15; // 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 小睡&#10;export class NapRest extends Ability {&#10;  constructor() {&#10;    super('小睡', '/named{生命}恢复10%，上限增加5。', 1, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 5;&#10;    player.hp = Math.min(player.maxHp, player.hp + &#10;      Math.floor(player.maxHp * 0.1)&#10;    );&#10;  }&#10;}&#10;&#10;// 休养&#10;export class WellRest extends Ability {&#10;  constructor() {&#10;    super('休养', '/named{生命}恢复40%，上限增加2。', 1, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 2;&#10;    player.hp = Math.min(&#10;      player.maxHp, &#10;      player.hp + Math.floor(player.maxHp * 0.4));&#10;  }&#10;}&#10;&#10;// 锻炼&#10;class Exercise extends Ability {&#10;  constructor() {&#10;    super('锻炼', '/named{生命}上限增8。', 2, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 7;&#10;    player.hp += 7; // 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 专业锻炼&#10;class ExpertExercise extends Ability {&#10;  constructor() {&#10;    super('专业锻炼', '/named{生命}上限增15。', 2, 0.5);&#10;  }&#10;&#10;  apply(player) {&#10;    player.maxHp += 15;&#10;    player.hp += 15;// 同时恢复增加的生命值&#10;  }&#10;}&#10;&#10;// 冥想&#10;class MindExercise extends Ability {&#10;  constructor() {&#10;    super('冥想', '获得1/named{灵能}。', 3, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseMagic += 1;&#10;  }&#10;}&#10;&#10;// 龟缩训练&#10;class TurtoiseExercise extends Ability {&#10;  constructor() {&#10;    super('龟缩训练', '/named{防御}增1，最大/named{生命}减12。', 3, 1.0);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseDefense += 1;&#10;    player.maxHp = Math.max(1, player.maxHp - 12);&#10;    player.hp = Math.min(player.maxHp, player.hp);&#10;  }&#10;}&#10;&#10;// 修炼&#10;class Cultivation extends Ability {&#10;  constructor() {&#10;    super('修炼', '/named{灵能}增1，获得1魏启上限，恢复所有/named{魏启}。', 4, 0.5);&#10;  }&#10;&#10;  apply(player) {&#10;    player.baseMagic += 1;&#10;    player.maxMana += 1;&#10;    player.mana = player.maxMana; // 恢复所有魏启&#10;  }&#10;}&#10;&#10;export { Ability, Breakthrough, Strengthen, Growth, Cultivation,&#10;   MindExercise, TurtoiseExercise, Exercise, ExpertExercise}&#10;&#10;export class BitterCultivation extends Ability {&#10;  constructor() {&#10;    super('苦修', '/named{灵能}增2。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseMagic += 2;&#10;    // player.baseAttack = Math.max(0, player.baseAttack - 1);&#10;  }&#10;}&#10;&#10;export class BitterBodyCultivation extends Ability {&#10;  constructor() {&#10;    super('爆发训练', '/named{灵能}增1，/named{防御}减1。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    // player.baseAttack += 1;&#10;    player.baseMagic += 1;&#10;    player.baseDefense = Math.max(0, player.baseDefense - 1);&#10;  }&#10;}&#10;&#10;export class DefenseCultivation extends Ability {&#10;  constructor() {&#10;    super('防御训练', '/named{防御}增1。', 4, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseDefense += 1;&#10;  }&#10;}&#10;&#10;export class SpecialDefenseCultivation extends Ability {&#10;  constructor() {&#10;    super('特化防御训练', '/named{防御}增2，/named{灵能}减1。', 3, 1);&#10;  }&#10;  apply(player) {&#10;    player.baseDefense += 2;&#10;    player.baseMagic = Math.max(0, player.baseMagic - 1);&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/data/animationDispatcher.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/data/animationDispatcher.js" />
              <option name="originalContent" value="// 动画系统（animationDispatcher）— 设计说明与用法&#10;//&#10;// 核心目标&#10;// - 以“队列 + 节拍”的方式，把后端状态（backendGameState）的变化按动画节奏映射到显示层（displayGameState）。&#10;// - 保证每一次关键状态变化（S 子集）都有独立的可控展示顺序；纯 UI 动作（如日志、声音）也在同一队列中顺序播放。&#10;//&#10;// 核心机制&#10;// 1) 三类队列项&#10;//    - { kind: 'state', snapshot, duration? }：将“后端状态的投影快照”应用到显示层（见 S 规范）。&#10;//    - { kind: 'ui', name, payload, duration? }：纯 UI 行为（日志、音效、飘字等），通过前端事件总线驱动。&#10;//    - { kind: 'delay', duration }：纯延时，用于拉开动画节奏。&#10;//&#10;// 2) 入队策略（性能优化版）&#10;//    - 初始仅在 init 时入队一次 S 投影快照，以完成首次同步。&#10;//    - 使用 watch(() =&gt; backendGameState, { deep:true, flush:'sync' }) 仅标记 dirty=true，不立即入队；&#10;//      当有“非零延时”的 UI 或 delay 入队时，若 dirty==true，则在它之前入队一条 state 快照（duration=0），随后将 dirty 置为 false。&#10;//    - 在每个 macro tick 结束（setTimeout 0）也会检查 dirty；若仍为 true，则强制入队一条 state 快照（duration=0），避免遗漏同步。&#10;//    - 这样 0ms 的 UI 事件天然被合并展示；只有出现节拍（非零 delay）或 tick 结束时，才把当下的状态切片进队列，显著降低快照频率与开销。&#10;//&#10;// 3) 投影（S）与应用&#10;//    - projectToS(obj)：把后端状态按 S 规则抽取为“纯数据”快照。&#10;//    - applyProjectionToDisplay(src, dst, backendNode)：把 S 快照就地合并到显示层：&#10;//      - 对象：按键合并，删除快照中不存在的 S 键；保留实例与方法；必要时依据 backendNode 的原型创建承载对象，避免丢失原型链。&#10;//      - 数组：优先按 id（uniqueID/id）对齐逐元素合并；若无 id 再回退索引合并；会对齐数组长度，且在创建新元素时按 backend 原型构造实例壳，避免方法丢失。&#10;//      - 不会直接整体替换对象/实例，避免丢失方法（如 Skill.canUse）。&#10;//&#10;// S（共享投影子集）的规范&#10;// - 目的：只把“前端需要渲染/动画的字段”纳入监听，剔除后端私有中间态，降低无关触发与拷贝成本。&#10;// - 规则：&#10;//   1) 仅包含“可枚举的自有属性”。&#10;//   2) 排除所有函数（typeof v === 'function'）。&#10;//   3) 排除所有“仅有 getter、无 setter”的只读属性（避免副作用求值）。&#10;//   4) 排除所有以“_”结尾的属性名（视为后端私有中间态，不参与动画）。&#10;//   5) 其余字段（标量、对象、数组）按结构递归纳入。&#10;// - 建议：&#10;//   - 后端用于 AI、计数器、缓存等与 UI 无关的字段，统一命名为 xxx_，避免进入 S，减少队列压力。&#10;//   - 前端组件中如需调用实例方法（如 Skill.canUse），方法内部仅访问 S 字段，确保在显示层可用。&#10;//&#10;// 使用指南&#10;// - 启动：initAnimationDispatcher({ stepMs })；可按需设置节拍间隔（默认 0ms）。&#10;// - 入队 UI 动作：&#10;//   - enqueueUI(name, payload, { duration })：当 duration&gt;0 时，会在该 UI 前自动入队一条 state 快照（若 dirty==true）。&#10;//   - enqueueDelay(duration)：当 duration&gt;0 时，会在该 delay 前自动入队一条 state 快照（若 dirty==true）。&#10;//   - enqueueState({ snapshot })：如需手动推进状态，也可直接入队投影快照（会清理 dirty）。&#10;// - 不要直接修改 displayGameState；只修改 backendGameState（或发起 UI 事件）。&#10;// - 在类（Skill/Enemy/Item/Ability 等）中：&#10;//   - 非 UI 关键数据（hp、shield、effects、money、AP 等）作为普通字段进入 S。&#10;//   - 仅后端使用的中间态字段请加“_”后缀（如 actionIndex_），避免触发动画。&#10;//   - 方法如 canUse 只读取 S 字段（可从显示层读取），确保在显示层实例上正常运行。&#10;//&#10;// 常见坑与规避&#10;// - 若完全没有非零延时，状态不会自动切片入队，显示层会在下一次出现非零延时前保持合并展示；这是预期的“帧间合并”。&#10;// - 数组重排/插入/删除：为元素提供稳定 id（uniqueID/id），以避免回退到索引合并时的潜在错配。&#10;// - 无关触发多：把纯后端中间态统一命名为 *_ 并确保是可枚举自有属性；这类字段不会被 S 监听到。&#10;//&#10;// 扩展点&#10;// - 可为特定 UI 事件手动传入 { duration: X } 以强制切片当前状态，控制动画节拍。&#10;// - 如需进一步减少冗余快照，可在入队前做“最近一次入队项是否已是 state”检查以去重。&#10;&#10;// animationDispatcher.js - 将后端状态的变化以动画节奏应用到显示层状态，并支持UI动作&#10;&#10;import { watch, toRaw } from 'vue';&#10;import { backendGameState, displayGameState } from './gameState.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;// 队列项类型：&#10;// - { kind: 'state', snapshot, duration? }&#10;// - { kind: 'ui', name: 'lockControl'|'unlockControl', payload?, duration? }&#10;// - { kind: 'delay', duration }&#10;const queue = [];&#10;let processing = false;&#10;let stalling = false;&#10;let defaultStepMs = 0;&#10;// 新增：脏位与 tick 末兜底检查&#10;let dirty = false;&#10;let endOfTickScheduled = false;&#10;function scheduleEndOfTickCheck() {&#10;  if (endOfTickScheduled) return;&#10;  endOfTickScheduled = true;&#10;  setTimeout(() =&gt; {&#10;    endOfTickScheduled = false;&#10;    if (dirty) {&#10;      // tick 结束仍有未同步的变更，强制入队一次当前快照&#10;      queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;      dirty = false;&#10;      tryStartProcessQueue();&#10;    }&#10;  }, 0);&#10;}&#10;&#10;function isWritableProperty(target, key) {&#10;  const desc = Object.getOwnPropertyDescriptor(target, key);&#10;  if (!desc) return true;&#10;  if (typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') return false;&#10;  if (desc.writable === false) return false;&#10;  return true;&#10;}&#10;&#10;function isSKey(key) {&#10;  return typeof key !== 'string' || !key.endsWith('_');&#10;}&#10;&#10;// 将 backendGameState 投影为子集 S（仅包含非函数、非 _ 结尾字段），保持为纯数据树&#10;function projectToS(value, seen = new WeakMap()) {&#10;  // 使用代理对象进行依赖收集；仅在需要取属性描述符时取 raw&#10;  if (value === null || typeof value !== 'object') return value;&#10;  if (seen.has(value)) return seen.get(value);&#10;&#10;  if (Array.isArray(value)) {&#10;    const arr = new Array(value.length);&#10;    seen.set(value, arr);&#10;    for (let i = 0; i &lt; value.length; i++) {&#10;      arr[i] = projectToS(value[i], seen);&#10;    }&#10;    return arr;&#10;  }&#10;&#10;  const out = {};&#10;  seen.set(value, out);&#10;&#10;  // 遍历可枚举自有属性（通过代理拿 keys，可建立依赖）&#10;  for (const key of Object.keys(value)) {&#10;    if (!isSKey(key)) continue;&#10;    const raw = toRaw(value);&#10;    const desc = Object.getOwnPropertyDescriptor(raw, key);&#10;    if (desc &amp;&amp; typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') continue;&#10;    const v = value[key]; // 通过代理读取，建立依赖&#10;    if (typeof v === 'function') continue;&#10;    out[key] = projectToS(v, seen);&#10;  }&#10;  return out;&#10;}&#10;&#10;function getIdKeyFromArray(arr) {&#10;  if (!Array.isArray(arr)) return null;&#10;  for (const el of arr) {&#10;    if (el &amp;&amp; typeof el === 'object') {&#10;      if ('uniqueID' in el) return 'uniqueID';&#10;      if ('id' in el) return 'id';&#10;    }&#10;  }&#10;  return null;&#10;}&#10;&#10;function createInstanceFromBackendNode(bEl) {&#10;  if (bEl &amp;&amp; typeof bEl === 'object') {&#10;    const proto = Object.getPrototypeOf(toRaw(bEl));&#10;    return Object.create(proto || Object.prototype);&#10;  }&#10;  return {};&#10;}&#10;&#10;function reconcileArrayById(sArr, dArr, bArr) {&#10;  const idKey = getIdKeyFromArray(sArr) || getIdKeyFromArray(bArr);&#10;  if (!idKey) return false; // no id available&#10;  // Build id -&gt; dest element map&#10;  const dstMap = new Map();&#10;  for (let i = 0; i &lt; dArr.length; i++) {&#10;    const el = dArr[i];&#10;    if (el &amp;&amp; typeof el === 'object' &amp;&amp; idKey in el) {&#10;      dstMap.set(el[idKey], el);&#10;    }&#10;  }&#10;  const newArr = new Array(sArr.length);&#10;  for (let i = 0; i &lt; sArr.length; i++) {&#10;    const sEl = sArr[i];&#10;    const bEl = Array.isArray(bArr) ? bArr[i] : undefined;&#10;    if (sEl &amp;&amp; typeof sEl === 'object' &amp;&amp; idKey in sEl) {&#10;      const id = sEl[idKey];&#10;      let target = dstMap.get(id);&#10;      if (!target) {&#10;        target = createInstanceFromBackendNode(bEl);&#10;      }&#10;      applyProjectionToDisplay(sEl, target, bEl);&#10;      newArr[i] = target;&#10;    } else if (sEl &amp;&amp; typeof sEl === 'object') {&#10;      // object but no id on this element: create/reuse by backend prototype&#10;      let target = (Array.isArray(bArr) &amp;&amp; bArr[i]) ? createInstanceFromBackendNode(bArr[i]) : {};&#10;      applyProjectionToDisplay(sEl, target, Array.isArray(bArr) ? bArr[i] : undefined);&#10;      newArr[i] = target;&#10;    } else {&#10;      // primitive&#10;      newArr[i] = sEl;&#10;    }&#10;  }&#10;  // In-place replace dArr contents to preserve reactive array reference&#10;  dArr.splice(0, dArr.length, ...newArr);&#10;  return true;&#10;}&#10;&#10;// 将 S 投影快照合并到显示层，仅写入/删除 S 字段，保留实例/方法&#10;function applyProjectionToDisplay(src, dst, backendNode = undefined) {&#10;  // 若为数组，执行就地元素级合并（优先按 id 对齐），尽量保持实例原型&#10;  if (Array.isArray(src) &amp;&amp; Array.isArray(dst)) {&#10;    const bArr = Array.isArray(backendNode) ? backendNode : undefined;&#10;    // Try keyed reconciliation first&#10;    const done = reconcileArrayById(src, dst, bArr);&#10;    if (done) return;&#10;&#10;    // Fallback: index-based merge (best effort)&#10;    const len = src.length;&#10;    for (let i = 0; i &lt; len; i++) {&#10;      const sEl = src[i];&#10;      const dEl = dst[i];&#10;      const bEl = bArr ? bArr[i] : undefined;&#10;      if (sEl &amp;&amp; typeof sEl === 'object') {&#10;        if (dEl &amp;&amp; typeof dEl === 'object') {&#10;          applyProjectionToDisplay(sEl, dEl, bEl);&#10;        } else {&#10;          const inst = createInstanceFromBackendNode(bEl);&#10;          applyProjectionToDisplay(sEl, inst, bEl);&#10;          dst[i] = inst;&#10;        }&#10;      } else {&#10;        dst[i] = sEl;&#10;      }&#10;    }&#10;    if (dst.length &gt; len) dst.splice(len);&#10;    return;&#10;  }&#10;&#10;  // 删除在 dst 中存在但在 src 中不存在的 S 字段（跳过函数与只读属性）&#10;  for (const key of Object.keys(dst)) {&#10;    if (!isSKey(key)) continue;&#10;    const desc = Object.getOwnPropertyDescriptor(dst, key);&#10;    if (desc &amp;&amp; typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') continue;&#10;    if (typeof dst[key] === 'function') continue;&#10;    if (!Object.prototype.hasOwnProperty.call(src, key)) {&#10;      try { delete dst[key]; } catch (_) { /* ignore */ }&#10;    }&#10;  }&#10;&#10;  // 写入/合并 src 中的字段&#10;  for (const key of Object.keys(src)) {&#10;    if (!isWritableProperty(dst, key)) continue;&#10;    const sVal = src[key];&#10;    const dVal = dst[key];&#10;    const bVal = backendNode &amp;&amp; typeof backendNode === 'object' ? backendNode[key] : undefined;&#10;&#10;    if (Array.isArray(sVal)) {&#10;      if (Array.isArray(dVal)) {&#10;        applyProjectionToDisplay(sVal, dVal, bVal);&#10;      } else {&#10;        // 创建目标数组并逐元素合并，尽量保持实例原型&#10;        const arr = new Array(0);&#10;        dst[key] = arr;&#10;        applyProjectionToDisplay(sVal, arr, bVal);&#10;      }&#10;      continue;&#10;    }&#10;&#10;    if (sVal &amp;&amp; typeof sVal === 'object') {&#10;      if (dVal &amp;&amp; typeof dVal === 'object' &amp;&amp; !Array.isArray(dVal)) {&#10;        applyProjectionToDisplay(sVal, dVal, bVal);&#10;      } else {&#10;        // 以后端节点原型创建目标对象，保留方法；否则退回普通对象&#10;        let obj;&#10;        if (bVal &amp;&amp; typeof bVal === 'object' &amp;&amp; !Array.isArray(bVal)) {&#10;          obj = Object.create(Object.getPrototypeOf(toRaw(bVal)));&#10;        } else {&#10;          obj = {};&#10;        }&#10;        applyProjectionToDisplay(sVal, obj, bVal);&#10;        dst[key] = obj;&#10;      }&#10;      continue;&#10;    }&#10;&#10;    // 原始值：直接赋值&#10;    if (dst[key] !== sVal) dst[key] = sVal;&#10;  }&#10;}&#10;&#10;function captureSnapshot() {&#10;  // 基于投影生成轻量快照，仅包含 S 字段&#10;  return projectToS(backendGameState);&#10;}&#10;&#10;function scheduleNext(delay) {&#10;  if(delay &gt; 0) {&#10;    setTimeout(processQueue, delay);&#10;  } else processQueue();&#10;}&#10;&#10;function processQueue() {&#10;  if (processing) return;&#10;  if (queue.length === 0) return;&#10;  processing = true;&#10;  stalling = false;&#10;  const item = queue.shift();&#10;  try {&#10;    switch (item.kind) {&#10;      case 'state':&#10;        applyProjectionToDisplay(item.snapshot || captureSnapshot(), displayGameState, backendGameState);&#10;        break;&#10;      case 'ui':&#10;        handleUIAction(item);&#10;        break;&#10;      case 'delay':&#10;        // 纯延时，不做任何应用&#10;        stalling = true; // 在此期间，不启动额外processQueue&#10;        break;&#10;      default:&#10;        break;&#10;    }&#10;  } finally {&#10;    processing = false;&#10;    scheduleNext(item.duration ?? defaultStepMs);&#10;  }&#10;}&#10;&#10;function tryStartProcessQueue() {&#10;  if(!stalling) {&#10;    processQueue();&#10;  }&#10;}&#10;&#10;function handleUIAction(item) {&#10;  const { name, payload } = item;&#10;  switch (name) {&#10;    case 'lockControl':&#10;      displayGameState.controlDisableCount = (displayGameState.controlDisableCount || 0) + 1;&#10;      break;&#10;    case 'unlockControl':&#10;      displayGameState.controlDisableCount = Math.max(0, (displayGameState.controlDisableCount || 0) - 1);&#10;      break;&#10;    case 'spawnParticles':&#10;      frontendEventBus.emit('spawn-particles', payload?.particles || payload || []);&#10;      break;&#10;    case 'playSound':&#10;      frontendEventBus.emit('play-sound', payload || {});&#10;      break;&#10;    case 'popMessage':&#10;      frontendEventBus.emit('pop-message', payload || {});&#10;      break;&#10;    case 'displayDialog':&#10;      frontendEventBus.emit('display-dialog', payload || []);&#10;      break;&#10;    case 'addBattleLog':&#10;    case 'addBattleLogUI':&#10;      // 将战斗日志作为UI动作排队到事件总线&#10;      frontendEventBus.emit('add-battle-log', payload || {});&#10;      break;&#10;    case 'clearBattleLog':&#10;    case 'clearBattleLogUI':&#10;      // 清空战斗日志作为UI动作排队处理&#10;      frontendEventBus.emit('clear-battle-log');&#10;      break;&#10;  }&#10;}&#10;&#10;// 外部API：入队&#10;// 入队一个sisplayState修改&#10;export function enqueueState(options = {}) {&#10;  const {duration, snapshot} = options;&#10;  queue.push({kind: 'state', snapshot: snapshot || captureSnapshot(), duration});&#10;  // 快照已捕获，清除脏位&#10;  dirty = false;&#10;  tryStartProcessQueue();&#10;}&#10;// 入队一个UI动作&#10;export function enqueueUI(name, payload = {}, options = {}) {&#10;  const { duration = 0 } = options;&#10;  // 若有非零延时，且存在未同步的后端变更，则在它之前切片一次状态&#10;  if (duration &gt; 0 &amp;&amp; dirty) {&#10;    queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;    dirty = false;&#10;  }&#10;  queue.push({ kind: 'ui', name, payload, duration });&#10;  tryStartProcessQueue();&#10;}&#10;&#10;// 入队一个延时&#10;export function enqueueDelay(duration = defaultStepMs) {&#10;  // 若有非零延时，且存在未同步的后端变更，则在它之前切片一次状态&#10;  if (duration &gt; 0 &amp;&amp; dirty) {&#10;    queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;    dirty = false;&#10;  }&#10;  queue.push({ kind: 'delay', duration });&#10;  tryStartProcessQueue();&#10;}&#10;&#10;export function clearQueue() {&#10;  queue.length = 0;&#10;}&#10;&#10;export function initAnimationDispatcher({ stepMs = 0 } = {}) {&#10;  defaultStepMs = stepMs;&#10;  // 初始同步一次（避免空白）&#10;  enqueueState({ snapshot: projectToS(backendGameState) });&#10;  // 新增：监听后端状态变化，仅置脏，不立刻入队&#10;  watch(&#10;    () =&gt; backendGameState,&#10;    () =&gt; {&#10;      dirty = true;&#10;      scheduleEndOfTickCheck();&#10;    },&#10;    { deep: true, flush: 'sync' }&#10;  );&#10;}&#10;&#10;export function stopAnimationDispatcher() {&#10;  // 清理仅通过 clearQueue + 停止watch 外部控制；这里不保留interval&#10;  // 已无interval，留空即可&#10;}" />
              <option name="updatedContent" value="// 动画系统（animationDispatcher）— 设计说明与用法&#10;//&#10;// 核心目标&#10;// - 以“队列 + 节拍”的方式，把后端状态（backendGameState）的变化按动画节奏映射到显示层（displayGameState）。&#10;// - 保证每一次关键状态变化（S 子集）都有独立的可控展示顺序；纯 UI 动作（如日志、声音）也在同一队列中顺序播放。&#10;//&#10;// 核心机制&#10;// 1) 三类队列项&#10;//    - { kind: 'state', snapshot, duration? }：将“后端状态的投影快照”应用到显示层（见 S 规范）。&#10;//    - { kind: 'ui', name, payload, duration? }：纯 UI 行为（日志、音效、飘字等），通过前端事件总线驱动。&#10;//    - { kind: 'delay', duration }：纯延时，用于拉开动画节奏。&#10;//&#10;// 2) 入队策略（性能优化版）&#10;//    - 初始仅在 init 时入队一次 S 投影快照，以完成首次同步。&#10;//    - 使用 watch(() =&gt; backendGameState, { deep:true, flush:'sync' }) 仅标记 dirty=true，不立即入队；&#10;//      当有“非零延时”的 UI 或 delay 入队时，若 dirty==true，则在它之前入队一条 state 快照（duration=0），随后将 dirty 置为 false。&#10;//    - 在每个 macro tick 结束（setTimeout 0）也会检查 dirty；若仍为 true，则强制入队一条 state 快照（duration=0），避免遗漏同步。&#10;//    - 这样 0ms 的 UI 事件天然被合并展示；只有出现节拍（非零 delay）或 tick 结束时，才把当下的状态切片进队列，显著降低快照频率与开销。&#10;//&#10;// 3) 投影（S）与应用&#10;//    - projectToS(obj)：把后端状态按 S 规则抽取为“纯数据”快照。&#10;//    - applyProjectionToDisplay(src, dst, backendNode)：把 S 快照就地合并到显示层：&#10;//      - 对象：按键合并，删除快照中不存在的 S 键；保留实例与方法；必要时依据 backendNode 的原型创建承载对象，避免丢失原型链。&#10;//      - 数组：优先按 id（uniqueID/id）对齐逐元素合并；若无 id 再回退索引合并；会对齐数组长度，且在创建新元素时按 backend 原型构造实例壳，避免方法丢失。&#10;//      - 不会直接整体替换对象/实例，避免丢失方法（如 Skill.canUse）。&#10;//&#10;// S（共享投影子集）的规范&#10;// - 目的：只把“前端需要渲染/动画的字段”纳入监听，剔除后端私有中间态，降低无关触发与拷贝成本。&#10;// - 规则：&#10;//   1) 仅包含“可枚举的自有属性”。&#10;//   2) 排除所有函数（typeof v === 'function'）。&#10;//   3) 排除所有“仅有 getter、无 setter”的只读属性（避免副作用求值）。&#10;//   4) 排除所有以“_”结尾的属性名（视为后端私有中间态，不参与动画）。&#10;//   5) 其余字段（标量、对象、数组）按结构递归纳入。&#10;// - 建议：&#10;//   - 后端用于 AI、计数器、缓存等与 UI 无关的字段，统一命名为 xxx_，避免进入 S，减少队列压力。&#10;//   - 前端组件中如需调用实例方法（如 Skill.canUse），方法内部仅访问 S 字段，确保在显示层可用。&#10;//&#10;// 使用指南&#10;// - 启动：initAnimationDispatcher({ stepMs })；可按需设置节拍间隔（默认 0ms）。&#10;// - 入队 UI 动作：&#10;//   - enqueueUI(name, payload, { duration })：当 duration&gt;0 时，会在该 UI 前自动入队一条 state 快照（若 dirty==true）。&#10;//   - enqueueDelay(duration)：当 duration&gt;0 时，会在该 delay 前自动入队一条 state 快照（若 dirty==true）。&#10;//   - enqueueState({ snapshot })：如需手动推进状态，也可直接入队投影快照（会清理 dirty）。&#10;// - 不要直接修改 displayGameState；只修改 backendGameState（或发起 UI 事件）。&#10;// - 在类（Skill/Enemy/Item/Ability 等）中：&#10;//   - 非 UI 关键数据（hp、shield、effects、money、AP 等）作为普通字段进入 S。&#10;//   - 仅后端使用的中间态字段请加“_”后缀（如 actionIndex_），避免触发动画。&#10;//   - 方法如 canUse 只读取 S 字段（可从显示层读取），确保在显示层实例上正常运行。&#10;//&#10;// 常见坑与规避&#10;// - 若完全没有非零延时，状态不会自动切片入队，显示层会在下一次出现非零延时前保持合并展示；这是预期的“帧间合并”。&#10;// - 数组重排/插入/删除：为元素提供稳定 id（uniqueID/id），以避免回退到索引合并时的潜在错配。&#10;// - 无关触发多：把纯后端中间态统一命名为 *_ 并确保是可枚举自有属性；这类字段不会被 S 监听到。&#10;//&#10;// 扩展点&#10;// - 可为特定 UI 事件手动传入 { duration: X } 以强制切片当前状态，控制动画节拍。&#10;// - 如需进一步减少冗余快照，可在入队前做“最近一次入队项是否已是 state”检查以去重。&#10;&#10;// animationDispatcher.js - 将后端状态的变化以动画节奏应用到显示层状态，并支持UI动作&#10;&#10;import { watch, toRaw } from 'vue';&#10;import { backendGameState, displayGameState } from './gameState.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;// 队列项类型：&#10;// - { kind: 'state', snapshot, duration? }&#10;// - { kind: 'ui', name: 'lockControl'|'unlockControl', payload?, duration? }&#10;// - { kind: 'delay', duration }&#10;const queue = [];&#10;let processing = false;&#10;let stalling = false;&#10;let defaultStepMs = 0;&#10;// 新增：脏位与 tick 末兜底检查&#10;let dirty = false;&#10;let endOfTickScheduled = false;&#10;function scheduleEndOfTickCheck() {&#10;  if (endOfTickScheduled) return;&#10;  endOfTickScheduled = true;&#10;  setTimeout(() =&gt; {&#10;    endOfTickScheduled = false;&#10;    if (dirty) {&#10;      // tick 结束仍有未同步的变更，强制入队一次当前快照&#10;      queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;      dirty = false;&#10;      tryStartProcessQueue();&#10;    }&#10;  }, 0);&#10;}&#10;&#10;function isWritableProperty(target, key) {&#10;  const desc = Object.getOwnPropertyDescriptor(target, key);&#10;  if (!desc) return true;&#10;  if (typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') return false;&#10;  if (desc.writable === false) return false;&#10;  return true;&#10;}&#10;&#10;function isSKey(key) {&#10;  return typeof key !== 'string' || !key.endsWith('_');&#10;}&#10;&#10;// 将 backendGameState 投影为子集 S（仅包含非函数、非 _ 结尾字段），保持为纯数据树&#10;function projectToS(value, seen = new WeakMap()) {&#10;  // 使用代理对象进行依赖收集；仅在需要取属性描述符时取 raw&#10;  if (value === null || typeof value !== 'object') return value;&#10;  if (seen.has(value)) return seen.get(value);&#10;&#10;  if (Array.isArray(value)) {&#10;    const arr = new Array(value.length);&#10;    seen.set(value, arr);&#10;    for (let i = 0; i &lt; value.length; i++) {&#10;      arr[i] = projectToS(value[i], seen);&#10;    }&#10;    return arr;&#10;  }&#10;&#10;  const out = {};&#10;  seen.set(value, out);&#10;&#10;  // 遍历可枚举自有属性（通过代理拿 keys，可建立依赖）&#10;  for (const key of Object.keys(value)) {&#10;    if (!isSKey(key)) continue;&#10;    const raw = toRaw(value);&#10;    const desc = Object.getOwnPropertyDescriptor(raw, key);&#10;    if (desc &amp;&amp; typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') continue;&#10;    const v = value[key]; // 通过代理读取，建立依赖&#10;    if (typeof v === 'function') continue;&#10;    out[key] = projectToS(v, seen);&#10;  }&#10;  return out;&#10;}&#10;&#10;function getIdKeyFromArray(arr) {&#10;  if (!Array.isArray(arr)) return null;&#10;  for (const el of arr) {&#10;    if (el &amp;&amp; typeof el === 'object') {&#10;      if ('uniqueID' in el) return 'uniqueID';&#10;      if ('id' in el) return 'id';&#10;    }&#10;  }&#10;  return null;&#10;}&#10;&#10;function createInstanceFromBackendNode(bEl) {&#10;  if (bEl &amp;&amp; typeof bEl === 'object') {&#10;    const proto = Object.getPrototypeOf(toRaw(bEl));&#10;    return Object.create(proto || Object.prototype);&#10;  }&#10;  return {};&#10;}&#10;&#10;function reconcileArrayById(sArr, dArr, bArr) {&#10;  const idKey = getIdKeyFromArray(sArr) || getIdKeyFromArray(bArr);&#10;  if (!idKey) return false; // no id available&#10;  // Build id -&gt; dest element map&#10;  const dstMap = new Map();&#10;  for (let i = 0; i &lt; dArr.length; i++) {&#10;    const el = dArr[i];&#10;    if (el &amp;&amp; typeof el === 'object' &amp;&amp; idKey in el) {&#10;      dstMap.set(el[idKey], el);&#10;    }&#10;  }&#10;  const newArr = new Array(sArr.length);&#10;  for (let i = 0; i &lt; sArr.length; i++) {&#10;    const sEl = sArr[i];&#10;    const bEl = Array.isArray(bArr) ? bArr[i] : undefined;&#10;    if (sEl &amp;&amp; typeof sEl === 'object' &amp;&amp; idKey in sEl) {&#10;      const id = sEl[idKey];&#10;      let target = dstMap.get(id);&#10;      if (!target) {&#10;        target = createInstanceFromBackendNode(bEl);&#10;      }&#10;      applyProjectionToDisplay(sEl, target, bEl);&#10;      newArr[i] = target;&#10;    } else if (sEl &amp;&amp; typeof sEl === 'object') {&#10;      // object but no id on this element: create/reuse by backend prototype&#10;      let target = (Array.isArray(bArr) &amp;&amp; bArr[i]) ? createInstanceFromBackendNode(bArr[i]) : {};&#10;      applyProjectionToDisplay(sEl, target, Array.isArray(bArr) ? bArr[i] : undefined);&#10;      newArr[i] = target;&#10;    } else {&#10;      // primitive&#10;      newArr[i] = sEl;&#10;    }&#10;  }&#10;  // In-place replace dArr contents to preserve reactive array reference&#10;  dArr.splice(0, dArr.length, ...newArr);&#10;  return true;&#10;}&#10;&#10;// 将 S 投影快照合并到显示层，仅写入/删除 S 字段，保留实例/方法&#10;function applyProjectionToDisplay(src, dst, backendNode = undefined) {&#10;  // 若为数组，执行就地元素级合并（优先按 id 对齐），尽量保持实例原型&#10;  if (Array.isArray(src) &amp;&amp; Array.isArray(dst)) {&#10;    const bArr = Array.isArray(backendNode) ? backendNode : undefined;&#10;    // Try keyed reconciliation first&#10;    const done = reconcileArrayById(src, dst, bArr);&#10;    if (done) return;&#10;&#10;    // Fallback: index-based merge (best effort)&#10;    const len = src.length;&#10;    for (let i = 0; i &lt; len; i++) {&#10;      const sEl = src[i];&#10;      const dEl = dst[i];&#10;      const bEl = bArr ? bArr[i] : undefined;&#10;      if (sEl &amp;&amp; typeof sEl === 'object') {&#10;        if (dEl &amp;&amp; typeof dEl === 'object') {&#10;          applyProjectionToDisplay(sEl, dEl, bEl);&#10;        } else {&#10;          const inst = createInstanceFromBackendNode(bEl);&#10;          applyProjectionToDisplay(sEl, inst, bEl);&#10;          dst[i] = inst;&#10;        }&#10;      } else {&#10;        dst[i] = sEl;&#10;      }&#10;    }&#10;    if (dst.length &gt; len) dst.splice(len);&#10;    return;&#10;  }&#10;&#10;  // 删除在 dst 中存在但在 src 中不存在的 S 字段（跳过函数与只读属性）&#10;  for (const key of Object.keys(dst)) {&#10;    if (!isSKey(key)) continue;&#10;    const desc = Object.getOwnPropertyDescriptor(dst, key);&#10;    if (desc &amp;&amp; typeof desc.get === 'function' &amp;&amp; typeof desc.set !== 'function') continue;&#10;    if (typeof dst[key] === 'function') continue;&#10;    if (!Object.prototype.hasOwnProperty.call(src, key)) {&#10;      try { delete dst[key]; } catch (_) { /* ignore */ }&#10;    }&#10;  }&#10;&#10;  // 写入/合并 src 中的字段&#10;  for (const key of Object.keys(src)) {&#10;    if (!isWritableProperty(dst, key)) continue;&#10;    const sVal = src[key];&#10;    const dVal = dst[key];&#10;    const bVal = backendNode &amp;&amp; typeof backendNode === 'object' ? backendNode[key] : undefined;&#10;&#10;    if (Array.isArray(sVal)) {&#10;      if (Array.isArray(dVal)) {&#10;        applyProjectionToDisplay(sVal, dVal, bVal);&#10;      } else {&#10;        // 创建目标数组并逐元素合并，尽量保持实例原型&#10;        const arr = new Array(0);&#10;        dst[key] = arr;&#10;        applyProjectionToDisplay(sVal, arr, bVal);&#10;      }&#10;      continue;&#10;    }&#10;&#10;    if (sVal &amp;&amp; typeof sVal === 'object') {&#10;      if (dVal &amp;&amp; typeof dVal === 'object' &amp;&amp; !Array.isArray(dVal)) {&#10;        // 如果后端节点有原型且当前显示层对象原型不同，则同步原型（避免丢失 getter 如 attack/defense）&#10;        if (bVal &amp;&amp; typeof bVal === 'object') {&#10;          try {&#10;            const backendProto = Object.getPrototypeOf(toRaw(bVal));&#10;            const dstProto = Object.getPrototypeOf(dVal);&#10;            if (backendProto &amp;&amp; dstProto !== backendProto) {&#10;              Object.setPrototypeOf(dVal, backendProto);&#10;            }&#10;          } catch (_) { /* ignore prototype set errors */ }&#10;        }&#10;        applyProjectionToDisplay(sVal, dVal, bVal);&#10;      } else {&#10;        // 以后端节点原型创建目标对象，保留方法；否则退回普通对象&#10;        let obj;&#10;        if (bVal &amp;&amp; typeof bVal === 'object' &amp;&amp; !Array.isArray(bVal)) {&#10;          obj = Object.create(Object.getPrototypeOf(toRaw(bVal)));&#10;        } else {&#10;          obj = {};&#10;        }&#10;        applyProjectionToDisplay(sVal, obj, bVal);&#10;        dst[key] = obj;&#10;      }&#10;      continue;&#10;    }&#10;&#10;    // 原始值：直接赋值&#10;    if (dst[key] !== sVal) dst[key] = sVal;&#10;  }&#10;}&#10;&#10;function captureSnapshot() {&#10;  // 基于投影生成轻量快照，仅包含 S 字段&#10;  return projectToS(backendGameState);&#10;}&#10;&#10;function scheduleNext(delay) {&#10;  if(delay &gt; 0) {&#10;    setTimeout(processQueue, delay);&#10;  } else processQueue();&#10;}&#10;&#10;function processQueue() {&#10;  if (processing) return;&#10;  if (queue.length === 0) return;&#10;  processing = true;&#10;  stalling = false;&#10;  const item = queue.shift();&#10;  try {&#10;    switch (item.kind) {&#10;      case 'state':&#10;        applyProjectionToDisplay(item.snapshot || captureSnapshot(), displayGameState, backendGameState);&#10;        break;&#10;      case 'ui':&#10;        handleUIAction(item);&#10;        break;&#10;      case 'delay':&#10;        // 纯延时，不做任何应用&#10;        stalling = true; // 在此期间，不启动额外processQueue&#10;        break;&#10;      default:&#10;        break;&#10;    }&#10;  } finally {&#10;    processing = false;&#10;    scheduleNext(item.duration ?? defaultStepMs);&#10;  }&#10;}&#10;&#10;function tryStartProcessQueue() {&#10;  if(!stalling) {&#10;    processQueue();&#10;  }&#10;}&#10;&#10;function handleUIAction(item) {&#10;  const { name, payload } = item;&#10;  switch (name) {&#10;    case 'lockControl':&#10;      displayGameState.controlDisableCount = (displayGameState.controlDisableCount || 0) + 1;&#10;      break;&#10;    case 'unlockControl':&#10;      displayGameState.controlDisableCount = Math.max(0, (displayGameState.controlDisableCount || 0) - 1);&#10;      break;&#10;    case 'spawnParticles':&#10;      frontendEventBus.emit('spawn-particles', payload?.particles || payload || []);&#10;      break;&#10;    case 'playSound':&#10;      frontendEventBus.emit('play-sound', payload || {});&#10;      break;&#10;    case 'popMessage':&#10;      frontendEventBus.emit('pop-message', payload || {});&#10;      break;&#10;    case 'displayDialog':&#10;      frontendEventBus.emit('display-dialog', payload || []);&#10;      break;&#10;    case 'addBattleLog':&#10;    case 'addBattleLogUI':&#10;      // 将战斗日志作为UI动作排队到事件总线&#10;      frontendEventBus.emit('add-battle-log', payload || {});&#10;      break;&#10;    case 'clearBattleLog':&#10;    case 'clearBattleLogUI':&#10;      // 清空战斗日志作为UI动作排队处理&#10;      frontendEventBus.emit('clear-battle-log');&#10;      break;&#10;  }&#10;}&#10;&#10;// 外部API：入队&#10;// 入队一个sisplayState修改&#10;export function enqueueState(options = {}) {&#10;  const {duration, snapshot} = options;&#10;  queue.push({kind: 'state', snapshot: snapshot || captureSnapshot(), duration});&#10;  // 快照已捕获，清除脏位&#10;  dirty = false;&#10;  tryStartProcessQueue();&#10;}&#10;// 入队一个UI动作&#10;export function enqueueUI(name, payload = {}, options = {}) {&#10;  const { duration = 0 } = options;&#10;  // 若有非零延时，且存在未同步的后端变更，则在它之前切片一次状态&#10;  if (duration &gt; 0 &amp;&amp; dirty) {&#10;    queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;    dirty = false;&#10;  }&#10;  queue.push({ kind: 'ui', name, payload, duration });&#10;  tryStartProcessQueue();&#10;}&#10;&#10;// 入队一个延时&#10;export function enqueueDelay(duration = defaultStepMs) {&#10;  // 若有非零延时，且存在未同步的后端变更，则在它之前切片一次状态&#10;  if (duration &gt; 0 &amp;&amp; dirty) {&#10;    queue.push({ kind: 'state', snapshot: captureSnapshot(), duration: 0 });&#10;    dirty = false;&#10;  }&#10;  queue.push({ kind: 'delay', duration });&#10;  tryStartProcessQueue();&#10;}&#10;&#10;export function clearQueue() {&#10;  queue.length = 0;&#10;}&#10;&#10;export function initAnimationDispatcher({ stepMs = 0 } = {}) {&#10;  defaultStepMs = stepMs;&#10;  // 初始同步一次（避免空白）&#10;  enqueueState({ snapshot: projectToS(backendGameState) });&#10;  // 新增：监听后端状态变化，仅置脏，不立刻入队&#10;  watch(&#10;    () =&gt; backendGameState,&#10;    () =&gt; {&#10;      dirty = true;&#10;      scheduleEndOfTickCheck();&#10;    },&#10;    { deep: true, flush: 'sync' }&#10;  );&#10;}&#10;&#10;export function stopAnimationDispatcher() {&#10;  // 清理仅通过 clearQueue + 停止watch 外部控制；这里不保留interval&#10;  // 已无interval，留空即可&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/data/skillManager.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/data/skillManager.js" />
              <option name="originalContent" value="import Skill from './skill.js';&#10;&#10;// 技能管理器类&#10;class SkillManager {&#10;  constructor() {&#10;    this.skills = [];&#10;    this.skillRegistry = new Map(); // 新增技能注册表&#10;    &#10;  }&#10;  // 注册技能&#10;  registerSkill(SkillClass) {&#10;    const skillName = (new SkillClass()).name;&#10;    this.skillRegistry.set(skillName, SkillClass);&#10;  }&#10;&#10;  static async loadAllSkills() {&#10;    &#10;    const skillManager = SkillManager.getInstance();&#10;&#10;    // 动态导入所有技能文件&#10;    const skillModules = [&#10;      await import('./skills/basic.js'),&#10;      await import('./skills/blast.js'),&#10;      await import('./skills/heal.js'),&#10;      // await import('./skills/remi.js'),&#10;      await import('./skills/cMinus.js'),&#10;      await import('./skills/punchKicks.js'),&#10;      await import('./skills/fireAssist.js'),&#10;      await import('./skills/shielding.js'),&#10;      await import('./skills/concentration.js'),&#10;      // await import('./skills/firecontrol.js'),&#10;      // await import('./skills/lumi.js')&#10;    ];&#10;    &#10;    // 遍历所有模块并注册其中的技能&#10;    for (const module of skillModules) {&#10;      // 遍历模块中的所有导出&#10;      for (const [key, SkillClass] of Object.entries(module)) {&#10;        // 检查是否为Skill类的子类&#10;        if (typeof SkillClass === 'function' &amp;&amp; SkillClass !== Skill &amp;&amp; SkillClass.prototype instanceof Skill) {&#10;          try {&#10;            skillManager.registerSkill(SkillClass);&#10;          } catch (error) {&#10;            console.error(`Failed to register skill: ${key}`, error);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;  &#10;  // 创建技能实例&#10;  createSkill(skillName) {&#10;    // 使用注册表创建技能实例&#10;    const SkillClass = this.skillRegistry.get(skillName);&#10;    if (SkillClass) {&#10;      const obj = new SkillClass();&#10;      obj.description = obj.regenerateDescription();&#10;      return obj;&#10;    }&#10;    throw new Error(`Unknown skill: ${skillName}`);&#10;  }&#10;  &#10;  // 获取SkillManager实例&#10;  static getInstance() {&#10;    if (!this.instance) {&#10;      this.instance = new SkillManager();&#10;    }&#10;    return this.instance;&#10;  }&#10;  &#10;  // 获取随机技能&#10;  getRandomSkills(count, playerSkillSlots = [], playerTier = 0, bestQuality = false) {&#10;    const allSkills = Array.from(this.skillRegistry.entries()).map(([name, SkillClass]) =&gt; {&#10;      // 创建临时实例以获取技能系列名称和等阶&#10;      const tempSkill = new SkillClass();&#10;      return {&#10;        name: name,&#10;        series: tempSkill.skillSeriesName,&#10;        tier: tempSkill.tier,&#10;        spawnWeight: tempSkill.spawnWeight&#10;      };&#10;    });&#10;&#10;    const playerNonEmptySkillSlots = playerSkillSlots.filter(skill =&gt; skill !== null);&#10;    const playerSkills = playerNonEmptySkillSlots.map(slot =&gt; slot);&#10;    console.log(playerSkills);&#10;&#10;    // 获取玩家已有的技能系列&#10;    const playerSkillSeries = playerSkills.map(skill =&gt; skill.skillSeriesName);&#10;&#10;    // 过滤掉玩家已有的技能和同系列的技能，以及等阶大于玩家等阶的技能&#10;    const availableSkills = allSkills.filter(skill =&gt;&#10;      !playerSkills.some(playerSkill =&gt; playerSkill.name === skill.name) &amp;&amp;&#10;      !playerSkillSeries.includes(skill.series) &amp;&amp;&#10;      skill.tier &lt;= playerTier&#10;    );&#10;&#10;    // 计算每个技能的出现权重&#10;    const weightedSkills = availableSkills.map(skill =&gt; {&#10;      const tierDifference = playerTier - skill.tier;&#10;      let modifyFactor = 1;&#10;      &#10;      if (skill.tier &gt;= 8) modifyFactor *= 0.7;&#10;      if (skill.tier &gt;= 5) modifyFactor *= 0.8;&#10;      if (tierDifference &gt; 7) {&#10;        modifyFactor = 0.15;&#10;      }  else if (tierDifference &gt; 6) {&#10;        modifyFactor = 0.40;&#10;      } else if (tierDifference &gt; 5) {&#10;        modifyFactor = 0.70;&#10;      }&#10;      // 增加当前等阶的技能出现权重&#10;      if(tierDifference &lt; 1) modifyFactor *= 1.2;&#10;&#10;      // 高质量奖励中，贴近玩家等级上限技能概率大幅提升&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 1) modifyFactor *= 5;&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 2) modifyFactor *= 3;&#10;&#10;      return {&#10;        ...skill,&#10;        weight: skill.spawnWeight * modifyFactor&#10;      };&#10;    });&#10;    // 减少已获得技能的出现权重（x0.2）&#10;    weightedSkills.forEach(skill =&gt; {&#10;      if (playerSkills.some(playerSkill =&gt; playerSkill.name === skill.name)) {&#10;        skill.weight *= 0.2;&#10;      }&#10;    });&#10;    &#10;    const selectedSkills = [];&#10;    &#10;    // 确保不会选择超过可用技能数量的技能&#10;    const actualCount = Math.min(count, weightedSkills.length);&#10;    &#10;    // 带权不放回抽选&#10;    for (let i = 0; i &lt; actualCount; i++) {&#10;      // 计算总权重&#10;      const totalWeight = weightedSkills.reduce((sum, skill) =&gt; sum + skill.weight, 0);&#10;      &#10;      // 生成随机数&#10;      const random = Math.random() * totalWeight;&#10;      &#10;      // 选择技能&#10;      let currentWeight = 0;&#10;      let selectedIndex = 0;&#10;      &#10;      for (let j = 0; j &lt; weightedSkills.length; j++) {&#10;        currentWeight += weightedSkills[j].weight;&#10;        if (random &lt;= currentWeight) {&#10;          selectedIndex = j;&#10;          break;&#10;        }&#10;      }&#10;      &#10;      // 获取选中的技能&#10;      const skillInfo = weightedSkills[selectedIndex];&#10;      const skill = this.createSkill(skillInfo.name);&#10;      selectedSkills.push(skill);&#10;      &#10;      // 从可选技能中移除已选择的技能&#10;      weightedSkills.splice(selectedIndex, 1);&#10;    }&#10;    &#10;    return selectedSkills;&#10;  }&#10;}&#10;&#10;export default SkillManager;" />
              <option name="updatedContent" value="import Skill from './skill.js';&#10;&#10;// 技能管理器类&#10;class SkillManager {&#10;  constructor() {&#10;    this.skills = [];&#10;    this.skillRegistry = new Map(); // 新增技能注册表&#10;    &#10;  }&#10;  // 注册技能&#10;  registerSkill(SkillClass) {&#10;    const skillName = (new SkillClass()).name;&#10;    this.skillRegistry.set(skillName, SkillClass);&#10;  }&#10;&#10;  static async loadAllSkills() {&#10;    &#10;    const skillManager = SkillManager.getInstance();&#10;&#10;    // 动态导入所有技能文件&#10;    const skillModules = [&#10;      await import('./skills/basic.js'),&#10;      await import('./skills/blast.js'),&#10;      await import('./skills/heal.js'),&#10;      // await import('./skills/remi.js'),&#10;      await import('./skills/cMinus.js'),&#10;      await import('./skills/punchKicks.js'),&#10;      await import('./skills/fireAssist.js'),&#10;      await import('./skills/shielding.js'),&#10;      await import('./skills/concentration.js'),&#10;      // await import('./skills/firecontrol.js'),&#10;      // await import('./skills/lumi.js')&#10;    ];&#10;    &#10;    // 遍历所有模块并注册其中的技能&#10;    for (const module of skillModules) {&#10;      // 遍历模块中的所有导出&#10;      for (const [key, SkillClass] of Object.entries(module)) {&#10;        // 检查是否为Skill类的子类&#10;        if (typeof SkillClass === 'function' &amp;&amp; SkillClass !== Skill &amp;&amp; SkillClass.prototype instanceof Skill) {&#10;          try {&#10;            skillManager.registerSkill(SkillClass);&#10;          } catch (error) {&#10;            console.error(`Failed to register skill: ${key}`, error);&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;  &#10;  // 创建技能实例&#10;  createSkill(skillName) {&#10;    // 使用注册表创建技能实例&#10;    const SkillClass = this.skillRegistry.get(skillName);&#10;    if (SkillClass) {&#10;      const obj = new SkillClass();&#10;      obj.description = obj.regenerateDescription();&#10;      return obj;&#10;    }&#10;    throw new Error(`Unknown skill: ${skillName}`);&#10;  }&#10;  &#10;  // 获取SkillManager实例&#10;  static getInstance() {&#10;    if (!this.instance) {&#10;      this.instance = new SkillManager();&#10;    }&#10;    return this.instance;&#10;  }&#10;  &#10;  // 获取随机技能&#10;  getRandomSkills(count, playerSkillSlots = [], playerTier = 0, bestQuality = false) {&#10;    const allSkills = Array.from(this.skillRegistry.entries()).map(([name, SkillClass]) =&gt; {&#10;      // 创建临时实例以获取技能系列名称和等阶&#10;      const tempSkill = new SkillClass();&#10;      return {&#10;        name: name,&#10;        series: tempSkill.skillSeriesName,&#10;        tier: tempSkill.tier,&#10;        spawnWeight: tempSkill.spawnWeight&#10;      };&#10;    });&#10;&#10;    const playerNonEmptySkillSlots = playerSkillSlots.filter(skill =&gt; skill !== null);&#10;    const playerSkills = playerNonEmptySkillSlots.map(slot =&gt; slot);&#10;    // console.log(playerSkills);&#10;    &#10;    // 获取玩家已有的技能系列&#10;    const playerSkillSeries = playerSkills.map(skill =&gt; skill.skillSeriesName);&#10;    const playerSkillNames = playerSkills.map(skill =&gt; skill.name);&#10;    &#10;    // 过滤掉玩家已有的技能和同系列的技能，以及等阶大于玩家等阶的技能&#10;    const baseAvailableSkills = allSkills.filter(skill =&gt; &#10;      !playerSkillNames.includes(skill.name) &amp;&amp;&#10;      !playerSkillSeries.includes(skill.series) &amp;&amp;&#10;      skill.tier &lt;= playerTier&#10;    );&#10;&#10;    // —— 新逻辑：收集玩家技能可升级目标（upgradeTo，可为字符串或数组）并加入奖池 ——&#10;    const upgradeTargetNames = new Set();&#10;    const upgradeSourceMap = new Map(); // targetName -&gt; sourceSkillName&#10;    for(const ownedSkill of playerSkills) {&#10;      const upgradeTo = ownedSkill.upgradeTo;&#10;      if(!upgradeTo) continue;&#10;      if(Array.isArray(upgradeTo)) {&#10;        upgradeTo.forEach(name =&gt; {&#10;          if(name &amp;&amp; name !== ownedSkill.name) {&#10;            upgradeTargetNames.add(name);&#10;            if(!upgradeSourceMap.has(name)) upgradeSourceMap.set(name, ownedSkill.name);&#10;          }&#10;        });&#10;      } else if (typeof upgradeTo === 'string') {&#10;        if(upgradeTo &amp;&amp; upgradeTo !== ownedSkill.name) {&#10;          upgradeTargetNames.add(upgradeTo);&#10;          if(!upgradeSourceMap.has(upgradeTo)) upgradeSourceMap.set(upgradeTo, ownedSkill.name);&#10;        }&#10;      }&#10;    }&#10;&#10;    // 根据名称找到元数据并追加到可用列表（即使同系列也允许，因为这是升级路径）&#10;    for(const targetName of upgradeTargetNames) {&#10;      if(playerSkillNames.includes(targetName)) continue; // 已拥有不再加入&#10;      // 查找此技能的元数据&#10;      const meta = allSkills.find(s =&gt; s.name === targetName);&#10;      if(!meta) continue; // 注册表中不存在&#10;      if(meta.tier &gt; playerTier) continue; // 仍然遵守等阶限制（如需忽略，可移除此行）&#10;      // 避免重复&#10;      if(!baseAvailableSkills.some(s =&gt; s.name === meta.name)) {&#10;        baseAvailableSkills.push({ ...meta, isUpgradeCandidate: true, upgradedFrom: upgradeSourceMap.get(targetName) });&#10;      }&#10;    }&#10;&#10;    const availableSkills = baseAvailableSkills; // 之后流程对 availableSkills 操作&#10;    &#10;    // 计算每个技能的出现权重&#10;    const weightedSkills = availableSkills.map(skill =&gt; {&#10;      const tierDifference = playerTier - skill.tier;&#10;      let modifyFactor = 1;&#10;      &#10;      if (skill.tier &gt;= 8) modifyFactor *= 0.7;&#10;      if (skill.tier &gt;= 5) modifyFactor *= 0.8;&#10;      if (tierDifference &gt; 7) {&#10;        modifyFactor = 0.15;&#10;      }  else if (tierDifference &gt; 6) {&#10;        modifyFactor = 0.40;&#10;      } else if (tierDifference &gt; 5) {&#10;        modifyFactor = 0.70;&#10;      }&#10;      // 增加当前等阶的技能出现权重&#10;      if(tierDifference &lt; 1) modifyFactor *= 1.2;&#10;&#10;      // 高质量奖励中，贴近玩家等级上限技能概率大幅提升&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 1) modifyFactor *= 5;&#10;      if(bestQuality &amp;&amp; tierDifference &lt; 2) modifyFactor *= 3;&#10;&#10;      // 升级候选技能稍微再提升一点（避免被其它随机权重稀释）&#10;      if(skill.isUpgradeCandidate) modifyFactor *= 1.5;&#10;      &#10;      return {&#10;        ...skill,&#10;        weight: skill.spawnWeight * modifyFactor&#10;      };&#10;    });&#10;    // 减少已获得技能的出现权重（x0.2） — 这里理论上已过滤，不再需要，但保留以防未来逻辑调整&#10;    weightedSkills.forEach(skill =&gt; {&#10;      if (playerSkillNames.includes(skill.name)) {&#10;        skill.weight *= 0.2;&#10;      }&#10;    });&#10;    &#10;    const selectedSkills = [];&#10;    &#10;    // 确保不会选择超过可用技能数量的技能&#10;    const actualCount = Math.min(count, weightedSkills.length);&#10;    &#10;    // 带权不放回抽选&#10;    for (let i = 0; i &lt; actualCount; i++) {&#10;      // 计算总权重&#10;      const totalWeight = weightedSkills.reduce((sum, skill) =&gt; sum + skill.weight, 0);&#10;      &#10;      // 如果没有权重可供选择，提前跳出&#10;      if(totalWeight &lt;= 0) break;&#10;      &#10;      // 生成随机数&#10;      const random = Math.random() * totalWeight;&#10;      &#10;      // 选择技能&#10;      let currentWeight = 0;&#10;      let selectedIndex = 0;&#10;      &#10;      for (let j = 0; j &lt; weightedSkills.length; j++) {&#10;        currentWeight += weightedSkills[j].weight;&#10;        if (random &lt;= currentWeight) {&#10;          selectedIndex = j;&#10;          break;&#10;        }&#10;      }&#10;      &#10;      // 获取选中的技能&#10;      const skillInfo = weightedSkills[selectedIndex];&#10;      const skill = this.createSkill(skillInfo.name);&#10;      if(skillInfo.isUpgradeCandidate) {&#10;        skill.isUpgradeCandidate = true; // 标记（目前 UI 未使用）&#10;        if(skillInfo.upgradedFrom) skill.upgradedFrom = skillInfo.upgradedFrom; // 记录来源技能名称&#10;      }&#10;      selectedSkills.push(skill);&#10;      &#10;      // 从可选技能中移除已选择的技能&#10;      weightedSkills.splice(selectedIndex, 1);&#10;    }&#10;    &#10;    return selectedSkills;&#10;  }&#10;}&#10;&#10;export default SkillManager;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>