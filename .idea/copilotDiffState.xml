<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/data/battleUtils.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/data/battleUtils.js" />
              <option name="originalContent" value="// battleUtil.js - 提供战斗中的攻击结算、治疗结算等修改战斗状态相关助手函数，以供技能、敌人和效果结算逻辑调用&#10;&#10;import eventBus from '../eventBus.js';&#10;import { processPostAttackEffects, processAttackTakenEffects, processDamageTakenEffects, processAttackFinishEffects } from './effectProcessor.js';&#10;import { addBattleLog, addDamageLog, addDeathLog, addEffectLog, addHealLog } from './battleLogUtils.js';&#10;&#10;// 任意攻击的结算逻辑（由skill、enemy和effect结算调用）&#10;// @return {dead: target是否死亡, passThoughDamage: 真实造成的对护盾和生命的伤害总和, hpDamage: 对生命造成的伤害}&#10;export function launchAttack (attacker, target, damage) {&#10;&#10;  // 攻击者对攻击的后处理&#10;  let finalDamage = damage + attacker.attack;&#10;  if (attacker) {&#10;    finalDamage = processPostAttackEffects(attacker, target, damage);&#10;  }&#10;  // 处理受到攻击时的效果&#10;  console.log(target.name, finalDamage);&#10;  finalDamage = processAttackTakenEffects(target, finalDamage);&#10;  console.log(target.name, finalDamage);&#10;  // 处理受到伤害时的效果&#10;  finalDamage = processDamageTakenEffects(target, finalDamage);&#10;  // 固定防御减免&#10;  finalDamage = Math.max(finalDamage - target.defense, 0);&#10;  const passThoughDamage = finalDamage;&#10;  let hpDamage = 0;&#10;  &#10;  if (finalDamage &gt; 0) {&#10;    // 优先伤害护盾（如果有）&#10;    const shieldDamage = Math.min(target.shield, finalDamage);&#10;    target.shield -= shieldDamage;&#10;    finalDamage -= shieldDamage;&#10;    hpDamage = finalDamage;&#10;    target.hp = Math.max(target.hp - finalDamage, 0);&#10;    if(finalDamage &gt; 0) {&#10;      if(attacker) {&#10;        addDamageLog(`${attacker.name} 攻击了 ${target.name}，造成 /red{${finalDamage}} 点伤害！`);&#10;      } else {&#10;        addDamageLog(`你受到${finalDamage}点伤害！`);&#10;      }&#10;    } else {&#10;      if(attacker) addBattleLog(`${attacker.name} 攻击了 ${target.name}，被护盾拦下了！`);&#10;      else addBattleLog(`你的护盾挡下伤害！`);&#10;    }&#10;  } else {&#10;    if(attacker) addBattleLog(`${attacker.name} 攻击了 ${target.name}，但不起作用！`);&#10;    else addBattleLog(`你被攻击，但没有作用！`);&#10;  }&#10;  &#10;  // 检查目标是否死亡&#10;  if (target.hp &lt;= 0) {&#10;    addDeathLog(`${target.name} 被击败了！`);&#10;    // 发射事件，用于结算死亡&#10;    eventBus.emit('unit-dead-event', target);&#10;    return {dead: true, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;  }&#10;&#10;  // 发射攻击完成事件，用于结算攻击特效等&#10;  processAttackFinishEffects(attacker, target, hpDamage, passThoughDamage);&#10;  &#10;  // 结算完成，发射受伤事件，用于通知UI播放动画、dialogue播放等&#10;  eventBus.emit('unit-hurt', {target: target, passThoughDamage: passThoughDamage, hpDamage: hpDamage});&#10;&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;  &#10;  return {dead: false, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;}&#10;&#10;// 造成伤害的结算逻辑（由skill和enemy调用），和发动攻击不同，跳过攻击方攻击相关结算。&#10;// @return {dead: target是否死亡, passThoughDamage: 真实造成的对护盾和生命的伤害总和, hpDamage: 对生命造成的伤害}&#10;export function dealDamage (source, target, damage, penetrateDefense = false) {&#10;  let finalDamage = damage;&#10;  // 处理受到伤害时的效果&#10;  finalDamage = processDamageTakenEffects(target, finalDamage);&#10;  // 固定防御减免&#10;  if(!penetrateDefense) finalDamage = Math.max(finalDamage - target.defense, 0);&#10;  const passThoughDamage = finalDamage;&#10;  let hpDamage = 0;&#10;  &#10;  if (finalDamage &gt; 0) {&#10;    // 优先伤害护盾（如果有）&#10;    const shieldDamage = Math.min(target.shield, finalDamage);&#10;    target.shield -= shieldDamage;&#10;    finalDamage -= shieldDamage;&#10;    hpDamage = finalDamage;&#10;    target.hp = Math.max(target.hp - finalDamage, 0);&#10;    if(finalDamage &gt; 0) {&#10;      addDamageLog(`你${source ? `从${source.name}受到` : '受到'}${finalDamage}点伤害！`);&#10;    } else {&#10;      addBattleLog(`你的护盾挡下${source ? `自${source.name}` : ''}的伤害。`);&#10;    }&#10;  } else {&#10;    addBattleLog(`你${source ? `从${source.name}受到` : '受到'}伤害，但不起作用！`);&#10;  }&#10;  &#10;  // 检查目标是否死亡&#10;  if (target.hp &lt;= 0) {&#10;    addDeathLog(`${target.name} 被击败了！`);&#10;    return {dead: true, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;  }&#10;  &#10;  // 结算完成，发射受伤事件，用于通知UI播放动画、dialogue播放等&#10;  eventBus.emit('unit-hurt', {target: target, passThoughDamage: passThoughDamage, hpDamage: hpDamage});&#10;&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;  &#10;  return {dead: false, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;}&#10;&#10;// 任意获得护盾的结算逻辑&#10;export function gainShield (caster, target, shield) {&#10;  target.shield += shield;&#10;  if(caster === target) {&#10;    addHealLog(`${target.name}获得了${shield}点护盾！`);&#10;  } else {&#10;    addHealLog(`${target.name}从${caster.name}获得了${shield}点护盾！`);&#10;  }&#10;  // 发送事件通知UI更新&#10;  eventBus.emit('unit-shield-change', {target: target, deltaShield: shield});&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;}&#10;&#10;// 手动更新所有技能描述&#10;export function updateSkillDescriptions() {&#10;  eventBus.emit('update-skill-descriptions');&#10;}&#10;" />
              <option name="updatedContent" value="// battleUtil.js - 提供战斗中的攻击结算、治疗结算等修改战斗状态相关助手函数，以供技能、敌人和效果结算逻辑调用&#10;&#10;import eventBus from '../eventBus.js';&#10;import { processPostAttackEffects, processAttackTakenEffects, processDamageTakenEffects, processAttackFinishEffects } from './effectProcessor.js';&#10;import { addBattleLog, addDamageLog, addDeathLog, addHealLog } from './battleLogUtils.js';&#10;&#10;// 任意攻击的结算逻辑（由skill、enemy和effect结算调用）&#10;// @return {dead: target是否死亡, passThoughDamage: 真实造成的对护盾和生命的伤害总和, hpDamage: 对生命造成的伤害}&#10;export function launchAttack (attacker, target, damage) {&#10;&#10;  // 攻击者对攻击的后处理&#10;  let finalDamage = damage + attacker.attack;&#10;  if (attacker) {&#10;    finalDamage = processPostAttackEffects(attacker, target, damage);&#10;  }&#10;  // 处理受到攻击时的效果&#10;  console.log(target.name, finalDamage);&#10;  finalDamage = processAttackTakenEffects(target, finalDamage);&#10;  console.log(target.name, finalDamage);&#10;  // 处理受到伤害时的效果&#10;  finalDamage = processDamageTakenEffects(target, finalDamage);&#10;  // 固定防御减免&#10;  finalDamage = Math.max(finalDamage - target.defense, 0);&#10;  const passThoughDamage = finalDamage;&#10;  let hpDamage = 0;&#10;  &#10;  if (finalDamage &gt; 0) {&#10;    // 优先伤害护盾（如果有）&#10;    const shieldDamage = Math.min(target.shield, finalDamage);&#10;    target.shield -= shieldDamage;&#10;    finalDamage -= shieldDamage;&#10;    hpDamage = finalDamage;&#10;    target.hp = Math.max(target.hp - finalDamage, 0);&#10;    if(finalDamage &gt; 0) {&#10;      if(attacker) {&#10;        addDamageLog(`${attacker.name} 攻击了 ${target.name}，造成 /red{${finalDamage}} 点伤害！`);&#10;      } else {&#10;        addDamageLog(`你受到${finalDamage}点伤害！`);&#10;      }&#10;    } else {&#10;      if(attacker) addBattleLog(`${attacker.name} 攻击了 ${target.name}，被护盾拦下了！`);&#10;      else addBattleLog(`你的护盾挡下伤害！`);&#10;    }&#10;  } else {&#10;    if(attacker) addBattleLog(`${attacker.name} 攻击了 ${target.name}，但不起作用！`);&#10;    else addBattleLog(`你被攻击，但没有作用！`);&#10;  }&#10;  &#10;  // 检查目标是否死亡&#10;  if (target.hp &lt;= 0) {&#10;    addDeathLog(`${target.name} 被击败了！`);&#10;    // 发射事件，用于结算死亡&#10;    eventBus.emit('unit-dead-event', target);&#10;    return {dead: true, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;  }&#10;&#10;  // 发射攻击完成事件，用于结算攻击特效等&#10;  processAttackFinishEffects(attacker, target, hpDamage, passThoughDamage);&#10;  &#10;  // 结算完成，发射受伤事件，用于通知UI播放动画、dialogue播放等&#10;  eventBus.emit('unit-hurt', {target: target, passThoughDamage: passThoughDamage, hpDamage: hpDamage});&#10;&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;  &#10;  return {dead: false, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;}&#10;&#10;// 造成伤害的结算逻辑（由skill和enemy调用），和发动攻击不同，跳过攻击方攻击相关结算。&#10;// @return {dead: target是否死亡, passThoughDamage: 真实造成的对护盾和生命的伤害总和, hpDamage: 对生命造成的伤害}&#10;export function dealDamage (source, target, damage, penetrateDefense = false) {&#10;  let finalDamage = damage;&#10;  // 处理受到伤害时的效果&#10;  finalDamage = processDamageTakenEffects(target, finalDamage);&#10;  // 固定防御减免&#10;  if(!penetrateDefense) finalDamage = Math.max(finalDamage - target.defense, 0);&#10;  const passThoughDamage = finalDamage;&#10;  let hpDamage = 0;&#10;  &#10;  if (finalDamage &gt; 0) {&#10;    // 优先伤害护盾（如果有）&#10;    const shieldDamage = Math.min(target.shield, finalDamage);&#10;    target.shield -= shieldDamage;&#10;    finalDamage -= shieldDamage;&#10;    hpDamage = finalDamage;&#10;    target.hp = Math.max(target.hp - finalDamage, 0);&#10;    if(finalDamage &gt; 0) {&#10;      addDamageLog(`你${source ? `从${source.name}受到` : '受到'}${finalDamage}点伤害！`);&#10;    } else {&#10;      addBattleLog(`你的护盾挡下${source ? `自${source.name}` : ''}的伤害。`);&#10;    }&#10;  } else {&#10;    addBattleLog(`你${source ? `从${source.name}受到` : '受到'}伤害，但不起作用！`);&#10;  }&#10;  &#10;  // 检查目标是否死亡&#10;  if (target.hp &lt;= 0) {&#10;    addDeathLog(`${target.name} 被击败了！`);&#10;    return {dead: true, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;  }&#10;  &#10;  // 结算完成，发射受伤事件，用于通知UI播放动画、dialogue播放等&#10;  eventBus.emit('unit-hurt', {target: target, passThoughDamage: passThoughDamage, hpDamage: hpDamage});&#10;&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;  &#10;  return {dead: false, passThoughDamage: passThoughDamage, hpDamage: hpDamage};&#10;}&#10;&#10;// 任意获得护盾的结算逻辑&#10;export function gainShield (caster, target, shield) {&#10;  target.shield += shield;&#10;  if(caster === target) {&#10;    addHealLog(`${target.name}获得了${shield}点护盾！`);&#10;  } else {&#10;    addHealLog(`${target.name}从${caster.name}获得了${shield}点护盾！`);&#10;  }&#10;  // 发送事件通知UI更新&#10;  eventBus.emit('unit-shield-change', {target: target, deltaShield: shield});&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  eventBus.emit('update-skill-descriptions');&#10;}&#10;&#10;// 手动更新所有技能描述&#10;export function updateSkillDescriptions() {&#10;  eventBus.emit('update-skill-descriptions');&#10;}&#10;&#10;// 统一的效果添加入口&#10;export function addEffect(target, effectName, stacks = 1) {&#10;  if (stacks === 0) return;&#10;  const previousStacks = target.effects[effectName] || 0;&#10;&#10;  if (target.effects[effectName]) {&#10;    target.effects[effectName] += stacks;&#10;  } else {&#10;    target.effects[effectName] = stacks;&#10;  }&#10;&#10;  const currStacks = target.effects[effectName] || 0;&#10;&#10;  // 触发效果变化事件（统一payload键名）&#10;  eventBus.emit('effect-change', {&#10;    target: target,&#10;    effectName: effectName,&#10;    deltaStacks: stacks,&#10;    currStacks: currStacks,&#10;    previousStacks: previousStacks&#10;  });&#10;&#10;  // 如果需要，这里可以追加日志/描述更新&#10;  // eventBus.emit('update-skill-descriptions');&#10;}&#10;&#10;// 统一的效果移除入口&#10;export function removeEffect(target, effectName, stacks = 1) {&#10;  addEffect(target, effectName, -stacks);&#10;}&#10;&#10;// 统一的治疗入口&#10;export function applyHeal(target, heal) {&#10;  if (heal &gt; 0) {&#10;    target.hp += heal;&#10;    if (target.hp &gt; target.maxHp) target.hp = target.maxHp;&#10;    // 如需日志，可在此处添加，但为避免重复日志，保持静默&#10;    // addHealLog(`${target.name}恢复了${heal}点生命！`);&#10;  }&#10;  // 更新技能描述（因为玩家状态可能已改变）&#10;  // eventBus.emit('update-skill-descriptions');&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>