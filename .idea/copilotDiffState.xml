<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/global/AnimatableElementContainer.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/global/AnimatableElementContainer.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;animatable-elements-container&quot;&gt;&#10;    &lt;!-- 卡牌层 --&gt;&#10;    &lt;div class=&quot;cards-layer&quot;&gt;&#10;      &lt;div&#10;        v-for=&quot;skill in allSkills&quot;&#10;        :key=&quot;skill.uniqueID&quot;&#10;        class=&quot;card-wrapper&quot;&#10;        :class=&quot;{ hidden: !isCardVisible(skill) }&quot;&#10;        :ref=&quot;el =&gt; registerCard(el, skill.uniqueID)&quot;&#10;        @mousedown=&quot;onCardMouseDown(skill.uniqueID, $event)&quot;&#10;        @mouseenter=&quot;onCardHover(skill.uniqueID, $event)&quot;&#10;        @mouseleave=&quot;onCardLeave(skill.uniqueID, $event)&quot;&#10;        @click=&quot;onCardClick(skill.uniqueID, $event)&quot;&#10;      &gt;&#10;        &lt;SkillCard&#10;          :skill=&quot;skill&quot;&#10;          :player=&quot;player&quot;&#10;          :preview-mode=&quot;false&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;// AnimatableElementContainer&#10;// 负责持有所有可动画元素的Vue元件与DOM实例，管理其生命周期，并注册到animator中&#10;// 和animator配合实现复杂动画&#10;&#10;import { computed, watch, nextTick, ref, onBeforeUnmount } from 'vue';&#10;import SkillCard from './SkillCard.vue';&#10;import { displayGameState } from '../../data/gameState.js';&#10;import frontendEventBus from '../../frontendEventBus.js';&#10;import animator from '../../utils/animator.js';&#10;&#10;export default {&#10;  name: 'AnimatableElementContainer',&#10;  components: { SkillCard },&#10;  setup() {&#10;    const cardRefs = ref({});&#10;    const registeredIds = ref(new Set());&#10;    const mutationObservers = new Map();&#10;    const resizeObservers = new Map();&#10;&#10;    // 计算所有卡牌&#10;    const allSkills = computed(() =&gt; {&#10;      return displayGameState.player?.skills || [];&#10;    });&#10;&#10;    // 计算玩家对象&#10;    const player = computed(() =&gt; {&#10;      return displayGameState.player || null;&#10;    });&#10;&#10;    // 计算在场卡牌 ID（frontierSkills + activatedSkills）&#10;    const visibleCardIds = computed(() =&gt; {&#10;      const ids = new Set();&#10;      &#10;      // 手牌&#10;      const frontier = displayGameState.player?.frontierSkills || [];&#10;      frontier.forEach(s =&gt; {&#10;        if (s?.uniqueID != null) ids.add(s.uniqueID);&#10;      });&#10;      &#10;      // 激活技能&#10;      const activated = displayGameState.player?.activatedSkills || [];&#10;      activated.forEach(s =&gt; {&#10;        if (s?.uniqueID != null) ids.add(s.uniqueID);&#10;      });&#10;      &#10;      return ids;&#10;    });&#10;&#10;    // 判断卡牌是否可见&#10;    const isCardVisible = (skill) =&gt; {&#10;      return skill?.uniqueID != null &amp;&amp; visibleCardIds.value.has(skill.uniqueID);&#10;    };&#10;&#10;    // 断开观察者&#10;    const disconnectObservers = (id) =&gt; {&#10;      try { mutationObservers.get(id)?.disconnect(); } catch(_) {}&#10;      try { resizeObservers.get(id)?.disconnect(); } catch(_) {}&#10;      mutationObservers.delete(id);&#10;      resizeObservers.delete(id);&#10;    };&#10;&#10;    // 注册卡牌到 animator&#10;    const registerCard = (wrapperEl, uniqueID) =&gt; {&#10;      if (!wrapperEl || uniqueID == null) return;&#10;&#10;      // 检查是否已经注册过&#10;      if (registeredIds.value.has(uniqueID)) {&#10;        // 只更新 ref 引用，不重复注册&#10;        cardRefs.value[uniqueID] = wrapperEl;&#10;        return;&#10;      }&#10;      &#10;      // 保存 ref 引用&#10;      cardRefs.value[uniqueID] = wrapperEl;&#10;&#10;      // 等待 DOM 更新后注册到 animator&#10;      nextTick(() =&gt; {&#10;        const domEl = wrapperEl; // wrapper 作为可动画元素&#10;        if (domEl) {&#10;          animator.register(uniqueID, domEl, 'card');&#10;          registeredIds.value.add(uniqueID);&#10;          // 观察内部真实内容变化（SkillCard 根节点）&#10;          const contentEl = domEl.firstElementChild || domEl;&#10;          try {&#10;            const mo = new MutationObserver(() =&gt; {&#10;              // 内容变化：通知 pixi overlay 进行重烘焙&#10;              frontendEventBus.emit('card-content-updated', { id: uniqueID });&#10;            });&#10;            mo.observe(contentEl, { childList: true, characterData: true, subtree: true, attributes: true });&#10;            mutationObservers.set(uniqueID, mo);&#10;          } catch(_) {}&#10;          try {&#10;            const ro = new ResizeObserver(() =&gt; {&#10;              frontendEventBus.emit('card-content-updated', { id: uniqueID });&#10;            });&#10;            ro.observe(contentEl);&#10;            resizeObservers.set(uniqueID, ro);&#10;          } catch(_) {}&#10;        }&#10;      });&#10;    };&#10;&#10;    // 监听卡牌列表变化，处理注册/解除注册&#10;    let prevSkillIds = [];&#10;    watch(allSkills, (newSkills, oldSkills) =&gt; {&#10;      const newIds = newSkills.map(s =&gt; s?.uniqueID).filter(id =&gt; id != null);&#10;      &#10;      // 找出移除的卡牌&#10;      const removed = prevSkillIds.filter(id =&gt; !newIds.includes(id));&#10;      removed.forEach(id =&gt; {&#10;        animator.unregister(id);&#10;        disconnectObservers(id);&#10;        delete cardRefs.value[id];&#10;        registeredIds.value.delete(id); // 从已注册集合中移除&#10;        // console.log('[AnimatableElementContainer] Unregistered card:', id);&#10;      });&#10;      &#10;      prevSkillIds = newIds;&#10;      // console.log('[AnimatableElementContainer] All skills:', newIds.length, ', Registered:', registeredIds.value.size);&#10;    }, { deep: true });&#10;&#10;    // 交互事件处理&#10;    const onCardMouseDown = (id, event) =&gt; {&#10;      frontendEventBus.emit('card-drag-start', { &#10;        id, &#10;        x: event.clientX, &#10;        y: event.clientY &#10;      });&#10;    };&#10;&#10;    const onCardHover = (id, event) =&gt; {&#10;      frontendEventBus.emit('card-hover', { id });&#10;    };&#10;&#10;    const onCardLeave = (id, event) =&gt; {&#10;      frontendEventBus.emit('card-leave', { id });&#10;    };&#10;&#10;    const onCardClick = (id, event) =&gt; {&#10;      frontendEventBus.emit('card-click', { &#10;        id, &#10;        x: event.clientX, &#10;        y: event.clientY &#10;      });&#10;    };&#10;&#10;    onBeforeUnmount(() =&gt; {&#10;      for (const id of registeredIds.value) {&#10;        animator.unregister(id);&#10;        disconnectObservers(id);&#10;      }&#10;    });&#10;&#10;    return {&#10;      allSkills,&#10;      player,&#10;      isCardVisible,&#10;      registerCard,&#10;      onCardMouseDown,&#10;      onCardHover,&#10;      onCardLeave,&#10;      onCardClick&#10;    };&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.animatable-elements-container {&#10;  position: fixed;&#10;  inset: 0;&#10;  pointer-events: none;&#10;  z-index: var(--z-animatable-elements, 100);&#10;}&#10;&#10;.cards-layer {&#10;  position: absolute;&#10;  inset: 0;&#10;}&#10;&#10;.cards-layer &gt; .card-wrapper {&#10;  position: absolute;&#10;  pointer-events: auto; /* 由 wrapper 接收交互 */&#10;  transform-origin: center center;&#10;  will-change: transform, opacity;&#10;}&#10;&#10;.cards-layer &gt; .hidden { visibility: hidden; }&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;animatable-elements-container&quot;&gt;&#10;    &lt;!-- 卡牌层 --&gt;&#10;    &lt;div class=&quot;cards-layer&quot;&gt;&#10;      &lt;div&#10;        v-for=&quot;skill in allSkills&quot;&#10;        :key=&quot;skill.uniqueID&quot;&#10;        class=&quot;card-wrapper&quot;&#10;        :class=&quot;{ hidden: !isCardVisible(skill) }&quot;&#10;        :ref=&quot;el =&gt; registerCard(el, skill.uniqueID)&quot;&#10;        @mousedown=&quot;onCardMouseDown(skill.uniqueID, $event)&quot;&#10;        @mouseenter=&quot;onCardHover(skill.uniqueID, $event)&quot;&#10;        @mouseleave=&quot;onCardLeave(skill.uniqueID, $event)&quot;&#10;        @click=&quot;onCardClick(skill.uniqueID, $event)&quot;&#10;      &gt;&#10;        &lt;SkillCard&#10;          :skill=&quot;skill&quot;&#10;          :player=&quot;player&quot;&#10;          :preview-mode=&quot;false&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import { computed, watch, nextTick, ref, onBeforeUnmount, onMounted } from 'vue';&#10;import SkillCard from './SkillCard.vue';&#10;import { displayGameState } from '../../data/gameState.js';&#10;import frontendEventBus from '../../frontendEventBus.js';&#10;import animator from '../../utils/animator.js';&#10;&#10;export default {&#10;  name: 'AnimatableElementContainer',&#10;  components: { SkillCard },&#10;  setup() {&#10;    const cardRefs = ref({});&#10;    const registeredIds = ref(new Set());&#10;    const mutationObservers = new Map();&#10;    const resizeObservers = new Map();&#10;&#10;    const allSkills = computed(() =&gt; displayGameState.player?.skills || []);&#10;    const player = computed(() =&gt; displayGameState.player || null);&#10;&#10;    const visibleCardIds = computed(() =&gt; {&#10;      const ids = new Set();&#10;      const frontier = displayGameState.player?.frontierSkills || [];&#10;      frontier.forEach(s =&gt; { if (s?.uniqueID != null) ids.add(s.uniqueID); });&#10;      const activated = displayGameState.player?.activatedSkills || [];&#10;      activated.forEach(s =&gt; { if (s?.uniqueID != null) ids.add(s.uniqueID); });&#10;      return ids;&#10;    });&#10;&#10;    const isCardVisible = (skill) =&gt; skill?.uniqueID != null &amp;&amp; visibleCardIds.value.has(skill.uniqueID);&#10;&#10;    const disconnectObservers = (id) =&gt; {&#10;      try { mutationObservers.get(id)?.disconnect(); } catch(_) {}&#10;      try { resizeObservers.get(id)?.disconnect(); } catch(_) {}&#10;      mutationObservers.delete(id);&#10;      resizeObservers.delete(id);&#10;    };&#10;&#10;    const registerCard = (wrapperEl, uniqueID) =&gt; {&#10;      if (!wrapperEl || uniqueID == null) return;&#10;      if (registeredIds.value.has(uniqueID)) {&#10;        cardRefs.value[uniqueID] = wrapperEl;&#10;        return;&#10;      }&#10;      cardRefs.value[uniqueID] = wrapperEl;&#10;&#10;      nextTick(() =&gt; {&#10;        const domEl = wrapperEl; // wrapper 作为可动画元素&#10;        if (domEl) {&#10;          animator.register(uniqueID, domEl, 'card');&#10;          registeredIds.value.add(uniqueID);&#10;          // 观察内部真实内容变化（SkillCard 根节点）&#10;          const contentEl = domEl.firstElementChild || domEl;&#10;          try {&#10;            const mo = new MutationObserver(() =&gt; {&#10;              frontendEventBus.emit('card-content-updated', { id: uniqueID });&#10;            });&#10;            mo.observe(contentEl, { childList: true, characterData: true, subtree: true, attributes: true });&#10;            mutationObservers.set(uniqueID, mo);&#10;          } catch(_) {}&#10;          try {&#10;            const ro = new ResizeObserver(() =&gt; {&#10;              frontendEventBus.emit('card-content-updated', { id: uniqueID });&#10;            });&#10;            ro.observe(contentEl);&#10;            resizeObservers.set(uniqueID, ro);&#10;          } catch(_) {}&#10;        }&#10;      });&#10;    };&#10;&#10;    // Pixi overlay integration: hide/show DOM visuals when sprite is committed/released&#10;    const onSpriteCommitted = ({ id }) =&gt; {&#10;      const el = cardRefs.value[id];&#10;      if (!el) return;&#10;      // 添加一个仅影响视觉的隐藏类，避免影响 computed opacity&#10;      el.classList.add('pixi-hidden');&#10;    };&#10;    const onSpriteReleased = ({ id }) =&gt; {&#10;      const el = cardRefs.value[id];&#10;      if (!el) return;&#10;      el.classList.remove('pixi-hidden');&#10;    };&#10;&#10;    onMounted(() =&gt; {&#10;      frontendEventBus.on('pixi-sprite-committed', onSpriteCommitted);&#10;      frontendEventBus.on('pixi-sprite-released', onSpriteReleased);&#10;    });&#10;&#10;    let prevSkillIds = [];&#10;    watch(allSkills, (newSkills, oldSkills) =&gt; {&#10;      const newIds = newSkills.map(s =&gt; s?.uniqueID).filter(id =&gt; id != null);&#10;      const removed = prevSkillIds.filter(id =&gt; !newIds.includes(id));&#10;      removed.forEach(id =&gt; {&#10;        animator.unregister(id);&#10;        disconnectObservers(id);&#10;        // 移除隐藏类，避免遗留&#10;        const el = cardRefs.value[id];&#10;        if (el) el.classList.remove('pixi-hidden');&#10;        delete cardRefs.value[id];&#10;        registeredIds.value.delete(id);&#10;      });&#10;      prevSkillIds = newIds;&#10;    }, { deep: true });&#10;&#10;    const onCardMouseDown = (id, event) =&gt; {&#10;      frontendEventBus.emit('card-drag-start', { id, x: event.clientX, y: event.clientY });&#10;    };&#10;    const onCardHover = (id, event) =&gt; { frontendEventBus.emit('card-hover', { id }); };&#10;    const onCardLeave = (id, event) =&gt; { frontendEventBus.emit('card-leave', { id }); };&#10;    const onCardClick = (id, event) =&gt; { frontendEventBus.emit('card-click', { id, x: event.clientX, y: event.clientY }); };&#10;&#10;    onBeforeUnmount(() =&gt; {&#10;      for (const id of registeredIds.value) {&#10;        animator.unregister(id);&#10;        disconnectObservers(id);&#10;      }&#10;      frontendEventBus.off('pixi-sprite-committed', onSpriteCommitted);&#10;      frontendEventBus.off('pixi-sprite-released', onSpriteReleased);&#10;    });&#10;&#10;    return { allSkills, player, isCardVisible, registerCard, onCardMouseDown, onCardHover, onCardLeave, onCardClick };&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.animatable-elements-container {&#10;  position: fixed;&#10;  inset: 0;&#10;  pointer-events: none;&#10;  z-index: var(--z-animatable-elements, 100);&#10;}&#10;&#10;.cards-layer { position: absolute; inset: 0; }&#10;&#10;.cards-layer &gt; .card-wrapper {&#10;  position: absolute;&#10;  pointer-events: auto; /* 由 wrapper 接收交互 */&#10;  transform-origin: center center;&#10;  will-change: transform, opacity;&#10;}&#10;&#10;/* 可见性控制（游戏逻辑隐藏）：不参与 Pixi 绘制 */&#10;.cards-layer &gt; .hidden { visibility: hidden; }&#10;&#10;/* 视觉隐藏（由 Pixi 覆盖绘制时启用），不影响 computed opacity */&#10;.cards-layer &gt; .pixi-hidden { filter: opacity(0); }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/global/GamePixiOverlay.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/global/GamePixiOverlay.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;pixi-overlay&quot; ref=&quot;host&quot;&gt;&lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import PixiAppManager from '@/webgl/PixiAppManager.js'&#10;import animator from '@/utils/animator.js'&#10;import { bakeElementToTexture } from '@/webgl/domBake.js'&#10;import frontendEventBus from '@/frontendEventBus.js'&#10;&#10;export default {&#10;  name: 'GamePixiOverlay',&#10;  data() { return { layer: null, spriteMap: new Map(), bakingStamp: new Map(), boundsMap: new Map(), debugShowBounds: false }; },&#10;  mounted() {&#10;    const host = this.$refs.host;&#10;    const { app, PIXI, getLayer } = PixiAppManager.init(host);&#10;    this.layer = getLayer('cards-overlay', 1150);&#10;&#10;    // Purge any pre-existing children (from previous mounts/HMR) before we manage this layer&#10;    try {&#10;      if (this.layer?.children?.length) {&#10;        for (const child of [...this.layer.children]) {&#10;          try { this.layer.removeChild(child); } catch(_) {}&#10;          try { child.destroy({ children: true, texture: true, baseTexture: true }); } catch(_) {}&#10;        }&#10;      }&#10;    } catch(_) {}&#10;&#10;    const getSnapById = (id) =&gt; animator.getTransformsSnapshotByAdapter('card').find(s =&gt; s.id === id) || null;&#10;&#10;    const api = {&#10;      setShowBounds: (v) =&gt; { this.debugShowBounds = !!v; if (!this.debugShowBounds) this._clearBounds(); },&#10;      getShowBounds: () =&gt; this.debugShowBounds,&#10;      dump: (id) =&gt; { const snap = getSnapById(id); const rec = this.spriteMap.get(id); console.log('[PixiOverlay dump]', { id, snap, rec }); },&#10;      dumpAll: () =&gt; {&#10;        const snaps = animator.getTransformsSnapshotByAdapter('card');&#10;        console.log('[PixiOverlay dumpAll] Snaps:', snaps);&#10;        for (const [id, rec] of this.spriteMap.entries()) console.log(`[Sprite ${id}]`, rec);&#10;        console.log('[PixiOverlay dumpAll] Layer children:', this.layer?.children?.map((c,i)=&gt;({i, type: c.constructor?.name, hasId: c.__cardId!=null, cardId:c.__cardId})));&#10;      },&#10;      purgeLayer: () =&gt; {&#10;        // Remove any Sprite not owned by spriteMap; keep bounds graphics&#10;        const ownedSprites = new Set(Array.from(this.spriteMap.values()).map(r =&gt; r.sprite).filter(Boolean));&#10;        for (const child of [...this.layer.children]) {&#10;          const isSprite = child &amp;&amp; child.texture != null; // heuristic for PIXI.Sprite&#10;          const isOwned = ownedSprites.has(child);&#10;          if (isSprite &amp;&amp; !isOwned) {&#10;            try { this.layer.removeChild(child); } catch(_) {}&#10;            try { child.destroy({ children:false, texture:true, baseTexture:true }); } catch(_) {}&#10;          }&#10;        }&#10;        return true;&#10;      },&#10;      rebake: (id) =&gt; {&#10;        const rec = this._ensureRecord(id);&#10;        if (rec) rec.requestBake = true;&#10;        return true;&#10;      }&#10;    };&#10;    if (typeof window !== 'undefined') { window.__pixiOverlayDebug = api; console.info('[PixiOverlay] Debug API available as window.__pixiOverlayDebug'); }&#10;&#10;    const applyVisualHide = (el) =&gt; {&#10;      try {&#10;        const target = (el &amp;&amp; el.parentElement) ? el.parentElement : el;&#10;        if (!target) return;&#10;        const prev = target.style.filter || '';&#10;        if (!/opacity\(/.test(prev)) target.style.filter = (prev ? prev + ' ' : '') + 'opacity(0)';&#10;        else target.style.filter = prev.replace(/opacity\([^)]*\)/, 'opacity(0)');&#10;      } catch(_) {}&#10;    };&#10;&#10;    const computeSizeKey = (wrapperEl) =&gt; {&#10;      const el = (wrapperEl &amp;&amp; wrapperEl.firstElementChild) ? wrapperEl.firstElementChild : wrapperEl;&#10;      if (!el) return '';&#10;      let w = el.offsetWidth || el.clientWidth || 0;&#10;      let h = el.offsetHeight || el.clientHeight || 0;&#10;      if (!(w &gt; 0 &amp;&amp; h &gt; 0)) { const r = el.getBoundingClientRect(); w = Math.round(r.width); h = Math.round(r.height); }&#10;      if (!(w &gt; 0 &amp;&amp; h &gt; 0)) return '';&#10;      return `${w}x${h}`;&#10;    };&#10;&#10;    // Records: id -&gt; { sprite?, baked?, bakeScale?, pendingTexture?, pendingScale?, baking:boolean, requestBake:boolean, wrapperEl?, sizeKey? }&#10;    this._ensureRecord = (id) =&gt; {&#10;      let rec = this.spriteMap.get(id);&#10;      if (!rec) { rec = { sprite: null, baked: null, bakeScale: 1, pendingTexture: null, pendingScale: 1, baking: false, requestBake: false, wrapperEl: null, sizeKey: '' }; this.spriteMap.set(id, rec); }&#10;      return rec;&#10;    };&#10;&#10;    const startBake = async (id, contentEl) =&gt; {&#10;      const rec = this.spriteMap.get(id);&#10;      if (!rec || rec.baking) return;&#10;      rec.baking = true;&#10;      try {&#10;        const baked = await bakeElementToTexture(contentEl);&#10;        rec.pendingTexture = baked.texture;&#10;        rec.pendingScale = baked.scaleUsed || 1;&#10;        // Note: do not destroy baked here; pendingTexture will be adopted, old texture destroyed on swap&#10;      } catch (e) {&#10;        console.warn('[PixiOverlay] bake failed', id, e);&#10;      } finally {&#10;        rec.baking = false;&#10;      }&#10;    };&#10;&#10;    // Content change marks bake request; actual bake and sprite commit happen in ticker&#10;    const onContentUpdated = ({ id }) =&gt; {&#10;      const reg = animator.getRegisteredByAdapter('card').find(r =&gt; r.id === id);&#10;      if (!reg) return;&#10;      const rec = this._ensureRecord(id);&#10;      rec.wrapperEl = reg.element;&#10;      rec.requestBake = true;&#10;    };&#10;    frontendEventBus.on('card-content-updated', onContentUpdated);&#10;    this._offContentUpdated = () =&gt; frontendEventBus.off('card-content-updated', onContentUpdated);&#10;&#10;    app.ticker.add(() =&gt; {&#10;      const regs = animator.getRegisteredByAdapter('card');&#10;      const snaps = animator.getTransformsSnapshotByAdapter('card');&#10;      const snappedIds = new Set(snaps.map(s =&gt; s.id));&#10;&#10;      // Maintain records from regs&#10;      for (const { id, element: wrapper } of regs) {&#10;        const rec = this._ensureRecord(id);&#10;        rec.wrapperEl = wrapper;&#10;        const key = computeSizeKey(wrapper);&#10;        if (key &amp;&amp; rec.sizeKey !== key) { rec.sizeKey = key; rec.requestBake = true; }&#10;      }&#10;&#10;      // Launch bakes for requests&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        if (!rec.wrapperEl) continue;&#10;        if (rec.requestBake &amp;&amp; !rec.baking) {&#10;          const contentEl = rec.wrapperEl.firstElementChild || rec.wrapperEl;&#10;          const rect = contentEl.getBoundingClientRect();&#10;          if (rect &amp;&amp; rect.width &gt; 0 &amp;&amp; rect.height &gt; 0) {&#10;            startBake(id, contentEl);&#10;            rec.requestBake = false; // queued&#10;          }&#10;        }&#10;      }&#10;&#10;      // Commit pending textures and create sprites only inside ticker when snapshot exists&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        const snap = getSnapById(id);&#10;        // Create sprite if missing and pending texture available and snapshot available&#10;        if (!rec.sprite &amp;&amp; rec.pendingTexture &amp;&amp; snap) {&#10;          const sprite = new PIXI.Sprite(rec.pendingTexture);&#10;          sprite.__cardId = id;&#10;          sprite.anchor.set(0.5);&#10;          sprite.zIndex = 0;&#10;          sprite.interactive = false;&#10;          sprite.eventMode = 'none';&#10;          const s = Math.max(1, rec.pendingScale || 1);&#10;          sprite.position.set(snap.cx, snap.cy);&#10;          sprite.scale.set(snap.sx / s, snap.sy / s);&#10;          sprite.rotation = snap.rot;&#10;          sprite.alpha = Math.max(0, Math.min(1, snap.opacity));&#10;          sprite.visible = !!snap.visible;&#10;          this.layer.addChild(sprite);&#10;          rec.sprite = sprite;&#10;          rec.baked = rec.pendingTexture; // keep reference for potential destruction later&#10;          rec.bakeScale = rec.pendingScale || 1;&#10;          rec.pendingTexture = null;&#10;          // Hide DOM visuals now that sprite is live&#10;          applyVisualHide(rec.wrapperEl?.firstElementChild || rec.wrapperEl);&#10;        } else if (rec.sprite &amp;&amp; rec.pendingTexture) {&#10;          // Swap texture safely&#10;          const oldTex = rec.sprite.texture;&#10;          rec.sprite.texture = rec.pendingTexture;&#10;          rec.baked = rec.pendingTexture;&#10;          rec.bakeScale = rec.pendingScale || rec.bakeScale || 1;&#10;          rec.pendingTexture = null;&#10;          try { oldTex?.destroy(true); } catch(_) {}&#10;        }&#10;      }&#10;&#10;      // Sync transforms and visibility/opacity&#10;      for (const snap of snaps) {&#10;        const rec = this.spriteMap.get(snap.id);&#10;        if (!rec?.sprite) continue;&#10;        rec.sprite.visible = !!snap.visible;&#10;        const s = Math.max(1, rec.bakeScale || 1);&#10;        rec.sprite.position.set(snap.cx, snap.cy);&#10;        rec.sprite.scale.set(snap.sx / s, snap.sy / s);&#10;        rec.sprite.rotation = snap.rot;&#10;        rec.sprite.alpha = Math.max(0, Math.min(1, snap.opacity));&#10;      }&#10;      // Hide any sprite without a snapshot this frame&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        if (rec.sprite &amp;&amp; !snappedIds.has(id)) rec.sprite.visible = false;&#10;      }&#10;&#10;      // Remove records for cards no longer registered&#10;      const regIds = new Set(regs.map(r =&gt; r.id));&#10;      for (const [id, rec] of [...this.spriteMap.entries()]) {&#10;        if (!regIds.has(id)) {&#10;          if (rec.sprite) {&#10;            try { this.layer.removeChild(rec.sprite); } catch(_) {}&#10;            try { rec.sprite.destroy({ children:false, texture:false, baseTexture:false }); } catch(_) {}&#10;          }&#10;          try { rec.baked?.destroy?.(true); } catch(_) {}&#10;          try { rec.pendingTexture?.destroy?.(true); } catch(_) {}&#10;          this.spriteMap.delete(id);&#10;          const g = this.boundsMap.get(id);&#10;          if (g) { try { g.destroy(); } catch(_) {}; this.boundsMap.delete(id); }&#10;        }&#10;      }&#10;&#10;      // Compact layer: remove any Sprite not owned by spriteMap (regardless of __cardId)&#10;      const owned = new Set(Array.from(this.spriteMap.values()).map(r =&gt; r.sprite).filter(Boolean));&#10;      for (const child of [...this.layer.children]) {&#10;        const isSprite = child &amp;&amp; child.texture != null; // heuristic: PIXI.Sprite has texture&#10;        if (isSprite &amp;&amp; !owned.has(child)) {&#10;          try { this.layer.removeChild(child); } catch(_) {}&#10;          try { child.destroy({ children:false, texture:true, baseTexture:true }); } catch(_) {}&#10;        }&#10;      }&#10;&#10;      // Debug bounds drawing handled above per this.debugShowBounds&#10;      if (this.debugShowBounds) {&#10;        for (const snap of snaps) {&#10;          if (!snap.visible) {&#10;            const gHidden = this.boundsMap.get(snap.id);&#10;            if (gHidden) { try { gHidden.destroy(); } catch(_) {}; this.boundsMap.delete(snap.id); }&#10;            continue;&#10;          }&#10;          let g = this.boundsMap.get(snap.id);&#10;          if (!g) {&#10;            g = new PIXI.Graphics();&#10;            g.name = `bounds-graphics-${snap.id}`;&#10;            g.lineStyle(2, 0xff00ff, 1);&#10;            g.drawRect(-0.5, -0.5, snap.width + 1, snap.height + 1);&#10;            g.closePath();&#10;            g.visible = this.debugShowBounds;&#10;            this.layer.addChild(g);&#10;            this.boundsMap.set(snap.id, g);&#10;          }&#10;          g.clear();&#10;          g.lineStyle(2, 0xff00ff, 1);&#10;          g.drawRect(-0.5, -0.5, snap.width + 1, snap.height + 1);&#10;          g.closePath();&#10;          g.visible = this.debugShowBounds;&#10;        }&#10;      } else {&#10;        for (const g of this.boundsMap.values()) {&#10;          try { g.destroy(); } catch(_) {}&#10;        }&#10;        this.boundsMap.clear();&#10;      }&#10;    });&#10;  },&#10;  methods: {&#10;    _clearBounds() {&#10;      for (const [id, g] of this.boundsMap.entries()) {&#10;        try { g.destroy(); } catch(_) {}&#10;        this.boundsMap.delete(id);&#10;      }&#10;    }&#10;  },&#10;  beforeUnmount() {&#10;    try { this._offContentUpdated?.(); } catch(_) {}&#10;    try { this._clearBounds(); } catch(_) {}&#10;    try {&#10;      if (this.layer) { this.layer.removeChildren().forEach(c =&gt; c.destroy()); }&#10;      for (const [, rec] of this.spriteMap.entries()) {&#10;        try { rec.baked?.destroy?.(true); } catch(_) {}&#10;        try { rec.pendingTexture?.destroy?.(true); } catch(_) {}&#10;      }&#10;      this.spriteMap.clear();&#10;      this.bakingStamp.clear();&#10;    } catch (_) {}&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.pixi-overlay { position: fixed; inset: 0; z-index: calc(var(--z-animatable-elements, 1100) + 1); pointer-events: none; }&#10;&lt;/style&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;pixi-overlay&quot; ref=&quot;host&quot;&gt;&lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import PixiAppManager from '@/webgl/PixiAppManager.js'&#10;import animator from '@/utils/animator.js'&#10;import { bakeElementToTexture } from '@/webgl/domBake.js'&#10;import frontendEventBus from '@/frontendEventBus.js'&#10;&#10;export default {&#10;  name: 'GamePixiOverlay',&#10;  data() { return { layer: null, spriteMap: new Map(), bakingStamp: new Map(), boundsMap: new Map(), debugShowBounds: false }; },&#10;  mounted() {&#10;    const host = this.$refs.host;&#10;    const { app, PIXI, getLayer } = PixiAppManager.init(host);&#10;    this.layer = getLayer('cards-overlay', 1150);&#10;&#10;    // Purge any pre-existing children (from previous mounts/HMR) before we manage this layer&#10;    try {&#10;      if (this.layer?.children?.length) {&#10;        for (const child of [...this.layer.children]) {&#10;          try { this.layer.removeChild(child); } catch(_) {}&#10;          try { child.destroy({ children: true, texture: true, baseTexture: true }); } catch(_) {}&#10;        }&#10;      }&#10;    } catch(_) {}&#10;&#10;    const getSnapById = (id) =&gt; animator.getTransformsSnapshotByAdapter('card').find(s =&gt; s.id === id) || null;&#10;&#10;    const api = {&#10;      setShowBounds: (v) =&gt; { this.debugShowBounds = !!v; if (!this.debugShowBounds) this._clearBounds(); },&#10;      getShowBounds: () =&gt; this.debugShowBounds,&#10;      dump: (id) =&gt; { const snap = getSnapById(id); const rec = this.spriteMap.get(id); console.log('[PixiOverlay dump]', { id, snap, rec }); },&#10;      dumpAll: () =&gt; {&#10;        const snaps = animator.getTransformsSnapshotByAdapter('card');&#10;        console.log('[PixiOverlay dumpAll] Snaps:', snaps);&#10;        for (const [id, rec] of this.spriteMap.entries()) console.log(`[Sprite ${id}]`, rec);&#10;        console.log('[PixiOverlay dumpAll] Layer children:', this.layer?.children?.map((c,i)=&gt;({i, type: c.constructor?.name, hasId: c.__cardId!=null, cardId:c.__cardId})));&#10;      },&#10;      purgeLayer: () =&gt; {&#10;        // Remove any Sprite not owned by spriteMap; keep bounds graphics&#10;        const ownedSprites = new Set(Array.from(this.spriteMap.values()).map(r =&gt; r.sprite).filter(Boolean));&#10;        for (const child of [...this.layer.children]) {&#10;          const isSprite = child &amp;&amp; child.texture != null; // heuristic for PIXI.Sprite&#10;          const isOwned = ownedSprites.has(child);&#10;          if (isSprite &amp;&amp; !isOwned) {&#10;            try { this.layer.removeChild(child); } catch(_) {}&#10;            try { child.destroy({ children:false, texture:true, baseTexture:true }); } catch(_) {}&#10;          }&#10;        }&#10;        return true;&#10;      },&#10;      rebake: (id) =&gt; {&#10;        const rec = this._ensureRecord(id);&#10;        if (rec) rec.requestBake = true;&#10;        return true;&#10;      }&#10;    };&#10;    if (typeof window !== 'undefined') { window.__pixiOverlayDebug = api; console.info('[PixiOverlay] Debug API available as window.__pixiOverlayDebug'); }&#10;&#10;    const computeSizeKey = (wrapperEl) =&gt; {&#10;      const el = (wrapperEl &amp;&amp; wrapperEl.firstElementChild) ? wrapperEl.firstElementChild : wrapperEl;&#10;      if (!el) return '';&#10;      let w = el.offsetWidth || el.clientWidth || 0;&#10;      let h = el.offsetHeight || el.clientHeight || 0;&#10;      if (!(w &gt; 0 &amp;&amp; h &gt; 0)) { const r = el.getBoundingClientRect(); w = Math.round(r.width); h = Math.round(r.height); }&#10;      if (!(w &gt; 0 &amp;&amp; h &gt; 0)) return '';&#10;      return `${w}x${h}`;&#10;    };&#10;&#10;    // Records: id -&gt; { sprite?, baked?, bakeScale?, pendingTexture?, pendingScale?, baking:boolean, requestBake:boolean, wrapperEl?, sizeKey? }&#10;    this._ensureRecord = (id) =&gt; {&#10;      let rec = this.spriteMap.get(id);&#10;      if (!rec) { rec = { sprite: null, baked: null, bakeScale: 1, pendingTexture: null, pendingScale: 1, baking: false, requestBake: false, wrapperEl: null, sizeKey: '' }; this.spriteMap.set(id, rec); }&#10;      return rec;&#10;    };&#10;&#10;    const startBake = async (id, contentEl) =&gt; {&#10;      const rec = this.spriteMap.get(id);&#10;      if (!rec || rec.baking) return;&#10;      rec.baking = true;&#10;      try {&#10;        const baked = await bakeElementToTexture(contentEl);&#10;        rec.pendingTexture = baked.texture;&#10;        rec.pendingScale = baked.scaleUsed || 1;&#10;      } catch (e) {&#10;        console.warn('[PixiOverlay] bake failed', id, e);&#10;      } finally {&#10;        rec.baking = false;&#10;      }&#10;    };&#10;&#10;    // Content change marks bake request; actual bake and sprite commit happen in ticker&#10;    const onContentUpdated = ({ id }) =&gt; {&#10;      const reg = animator.getRegisteredByAdapter('card').find(r =&gt; r.id === id);&#10;      if (!reg) return;&#10;      const rec = this._ensureRecord(id);&#10;      rec.wrapperEl = reg.element;&#10;      rec.requestBake = true;&#10;    };&#10;    frontendEventBus.on('card-content-updated', onContentUpdated);&#10;    this._offContentUpdated = () =&gt; frontendEventBus.off('card-content-updated', onContentUpdated);&#10;&#10;    app.ticker.add(() =&gt; {&#10;      const regs = animator.getRegisteredByAdapter('card');&#10;      const snaps = animator.getTransformsSnapshotByAdapter('card');&#10;      const snappedIds = new Set(snaps.map(s =&gt; s.id));&#10;&#10;      // Maintain records from regs&#10;      for (const { id, element: wrapper } of regs) {&#10;        const rec = this._ensureRecord(id);&#10;        rec.wrapperEl = wrapper;&#10;        const key = computeSizeKey(wrapper);&#10;        if (key &amp;&amp; rec.sizeKey !== key) { rec.sizeKey = key; rec.requestBake = true; }&#10;      }&#10;&#10;      // Launch bakes for requests&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        if (!rec.wrapperEl) continue;&#10;        if (rec.requestBake &amp;&amp; !rec.baking) {&#10;          const contentEl = rec.wrapperEl.firstElementChild || rec.wrapperEl;&#10;          const rect = contentEl.getBoundingClientRect();&#10;          if (rect &amp;&amp; rect.width &gt; 0 &amp;&amp; rect.height &gt; 0) {&#10;            startBake(id, contentEl);&#10;            rec.requestBake = false; // queued&#10;          }&#10;        }&#10;      }&#10;&#10;      // Commit pending textures and create sprites only inside ticker when snapshot exists&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        const snap = snaps.find(s =&gt; s.id === id);&#10;        if (!rec.sprite &amp;&amp; rec.pendingTexture &amp;&amp; snap) {&#10;          const sprite = new PIXI.Sprite(rec.pendingTexture);&#10;          sprite.__cardId = id;&#10;          sprite.anchor.set(0.5);&#10;          sprite.zIndex = 0;&#10;          sprite.interactive = false;&#10;          sprite.eventMode = 'none';&#10;          const s = Math.max(1, rec.pendingScale || 1);&#10;          sprite.position.set(snap.cx, snap.cy);&#10;          sprite.scale.set(snap.sx / s, snap.sy / s);&#10;          sprite.rotation = snap.rot;&#10;          sprite.alpha = Math.max(0, Math.min(1, snap.opacity));&#10;          sprite.visible = !!snap.visible;&#10;          this.layer.addChild(sprite);&#10;          rec.sprite = sprite;&#10;          rec.baked = rec.pendingTexture;&#10;          rec.bakeScale = rec.pendingScale || 1;&#10;          rec.pendingTexture = null;&#10;          // Notify container to hide wrapper visuals&#10;          frontendEventBus.emit('pixi-sprite-committed', { id });&#10;        } else if (rec.sprite &amp;&amp; rec.pendingTexture) {&#10;          const oldTex = rec.sprite.texture;&#10;          rec.sprite.texture = rec.pendingTexture;&#10;          rec.baked = rec.pendingTexture;&#10;          rec.bakeScale = rec.pendingScale || rec.bakeScale || 1;&#10;          rec.pendingTexture = null;&#10;          try { oldTex?.destroy(true); } catch(_) {}&#10;        }&#10;      }&#10;&#10;      // Sync transforms and visibility/opacity&#10;      for (const snap of snaps) {&#10;        const rec = this.spriteMap.get(snap.id);&#10;        if (!rec?.sprite) continue;&#10;        rec.sprite.visible = !!snap.visible;&#10;        const s = Math.max(1, rec.bakeScale || 1);&#10;        rec.sprite.position.set(snap.cx, snap.cy);&#10;        rec.sprite.scale.set(snap.sx / s, snap.sy / s);&#10;        rec.sprite.rotation = snap.rot;&#10;        rec.sprite.alpha = Math.max(0, Math.min(1, snap.opacity));&#10;      }&#10;      // Hide any sprite without a snapshot this frame&#10;      for (const [id, rec] of this.spriteMap.entries()) {&#10;        if (rec.sprite &amp;&amp; !snappedIds.has(id)) rec.sprite.visible = false;&#10;      }&#10;&#10;      // Remove records for cards no longer registered&#10;      const regIds = new Set(regs.map(r =&gt; r.id));&#10;      for (const [id, rec] of [...this.spriteMap.entries()]) {&#10;        if (!regIds.has(id)) {&#10;          if (rec.sprite) {&#10;            try { this.layer.removeChild(rec.sprite); } catch(_) {}&#10;            try { rec.sprite.destroy({ children:false, texture:false, baseTexture:false }); } catch(_) {}&#10;          }&#10;          try { rec.baked?.destroy?.(true); } catch(_) {}&#10;          try { rec.pendingTexture?.destroy?.(true); } catch(_) {}&#10;          this.spriteMap.delete(id);&#10;          const g = this.boundsMap.get(id);&#10;          if (g) { try { g.destroy(); } catch(_) {}; this.boundsMap.delete(id); }&#10;          frontendEventBus.emit('pixi-sprite-released', { id });&#10;        }&#10;      }&#10;&#10;      // Compact layer: remove any Sprite not owned by spriteMap (regardless of __cardId)&#10;      const owned = new Set(Array.from(this.spriteMap.values()).map(r =&gt; r.sprite).filter(Boolean));&#10;      for (const child of [...this.layer.children]) {&#10;        const isSprite = child &amp;&amp; child.texture != null; // heuristic: PIXI.Sprite has texture&#10;        if (isSprite &amp;&amp; !owned.has(child)) {&#10;          try { this.layer.removeChild(child); } catch(_) {}&#10;          try { child.destroy({ children:false, texture:true, baseTexture:true }); } catch(_) {}&#10;        }&#10;      }&#10;&#10;      // Debug bounds drawing&#10;      if (this.debugShowBounds) {&#10;        for (const snap of snaps) {&#10;          if (!snap.visible) {&#10;            const gHidden = this.boundsMap.get(snap.id);&#10;            if (gHidden) {&#10;              try { gHidden.destroy(); } catch(_) {}&#10;              this.boundsMap.delete(snap.id);&#10;            }&#10;            continue;&#10;          }&#10;          let g = this.boundsMap.get(snap.id);&#10;          if (!g) {&#10;            g = new PIXI.Graphics();&#10;            g.zIndex = 1000;&#10;            g.interactive = false;&#10;            g.eventMode = 'none';&#10;            this.layer.addChild(g);&#10;            this.boundsMap.set(snap.id, g);&#10;          }&#10;          g.clear();&#10;          g.lineStyle(2, 0xff66cc, 0.9);&#10;          g.beginFill(0xff66cc, 0.12);&#10;          g.position.set(snap.cx, snap.cy);&#10;          g.rotation = snap.rot;&#10;          g.scale.set(snap.sx, snap.sy);&#10;          g.drawRect(-snap.baseW / 2, -snap.baseH / 2, snap.baseW, snap.baseH);&#10;          g.endFill();&#10;        }&#10;      } else {&#10;        for (const [bid, g] of this.boundsMap.entries()) {&#10;          try { g.destroy(); } catch(_) {}&#10;          this.boundsMap.delete(bid);&#10;        }&#10;      }&#10;    });&#10;  },&#10;  methods: {&#10;    _clearBounds() {&#10;      for (const [id, g] of this.boundsMap.entries()) {&#10;        try { g.destroy(); } catch(_) {}&#10;        this.boundsMap.delete(id);&#10;      }&#10;    }&#10;  },&#10;  beforeUnmount() {&#10;    try { this._offContentUpdated?.(); } catch(_) {}&#10;    try { this._clearBounds(); } catch(_) {}&#10;    try {&#10;      if (this.layer) { this.layer.removeChildren().forEach(c =&gt; c.destroy()); }&#10;      for (const [, rec] of this.spriteMap.entries()) {&#10;        try { rec.baked?.destroy?.(true); } catch(_) {}&#10;        try { rec.pendingTexture?.destroy?.(true); } catch(_) {}&#10;      }&#10;      this.spriteMap.clear();&#10;      this.bakingStamp.clear();&#10;    } catch (_) {}&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.pixi-overlay { position: fixed; inset: 0; z-index: calc(var(--z-animatable-elements, 1100) + 1); pointer-events: none; }&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/utils/animator.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/utils/animator.js" />
              <option name="originalContent" value="// animator.js - 新一代动画编排器&#10;// 核心职责：&#10;// 1. 管理可动画元素的 DOM 注册表&#10;// 2. 执行来自 animationSequencer 的动画指令&#10;// 3. 管理锚点信息，实现元素向锚点的&quot;静息归位&quot;&#10;// 4. 提供适配器机制，支持不同类型元素的动画&#10;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import gsap from 'gsap';&#10;&#10;const defaultEase = 'power2.out';&#10;&#10;// ========== 状态与配置常量 ==========&#10;const STATES = Object.freeze({&#10;  IDLE: 'idle',&#10;  TRACKING: 'tracking',&#10;  ANIMATING: 'animating',&#10;  DRAGGING: 'dragging'&#10;});&#10;&#10;// 跟踪动画的默认平滑时间（毫秒）与缓动&#10;const DEFAULT_TRACKING_DURATION_MS = 300;&#10;const DEFAULT_TRACKING_EASE = 'power1.out';&#10;&#10;// ========== 适配器接口 ==========&#10;&#10;/**&#10; * 卡牌适配器&#10; */&#10;class CardAdapter {&#10;  getDefaultProps(element) {&#10;    const rect = element?.getBoundingClientRect?.();&#10;    return {&#10;      width: rect?.width || 198,&#10;      height: rect?.height || 266&#10;    };&#10;  }&#10;&#10;  beforeAnimate(element, animationPayload) {&#10;    // 卡牌动画前的预处理&#10;  }&#10;&#10;  afterAnimate(element, animationPayload) {&#10;    // 卡牌动画后的清理&#10;  }&#10;&#10;  getRestPosition(id, anchorsMap) {&#10;    return anchorsMap.get(id) || null;&#10;  }&#10;}&#10;&#10;/**&#10; * 单位面板适配器&#10; */&#10;class UnitPanelAdapter {&#10;  getDefaultProps(element) {&#10;    const rect = element?.getBoundingClientRect?.();&#10;    return {&#10;      width: rect?.width || 300,&#10;      height: rect?.height || 200&#10;    };&#10;  }&#10;&#10;  beforeAnimate(element, animationPayload) {&#10;    // 面板动画前的预处理&#10;  }&#10;&#10;  afterAnimate(element, animationPayload) {&#10;    // 面板动画后的清理&#10;  }&#10;&#10;  getRestPosition(id, anchorsMap) {&#10;    return anchorsMap.get(id) || null;&#10;  }&#10;}&#10;&#10;// 适配器工厂&#10;const adapters = {&#10;  'card': new CardAdapter(),&#10;  'unit-panel': new UnitPanelAdapter()&#10;};&#10;&#10;// ========== Animator 核心类 ==========&#10;// Animator用于维护与播放可动画元素的动画和它们的状态&#10;// 可动画元素的状态列表：'idle' | 'tracking' | 'animating' | 'dragging'&#10;// 每个可动画元素在任意时刻能且仅能属于一个状态&#10;// idle: 待命，无动画，保持元素现有动画参量不变。&#10;// tracking: 元素正维持锚点跟踪，在锚点状态移动时，元素会平滑跟踪到锚点的目标状态。比如手牌。使用一个动态更新目标参数的长时动画实现&#10;// animating: 元素正在执行指令动画（animate），比如刚刚打出、抽取、发动的卡牌&#10;// dragging: 元素正被鼠标拖拽。这是一个特殊状态，一般用于被玩家使用鼠标拖拽中的卡牌上，一般用于在休整时切换排序和卡牌上下场&#10;// 在没有外部干预情况下，状态仅会在自动切换至idle。若要切换到tracking、animating、dragging，则需要外部方法调用完成&#10;&#10;class Animator {&#10;  constructor() {&#10;    // DOM 注册表: id -&gt; { element, adapterType, adapter, anchor, state, currentTween, isDragging }&#10;    this._registry = new Map();&#10;    &#10;    // 容器锚点表: containerKey -&gt; Map&lt;id, { x, y, scale?, rotation? }&gt;&#10;    this._containerAnchors = new Map();&#10;    &#10;    // 全局锚点: name -&gt; { x, y }&#10;    this._globalAnchors = new Map();&#10;&#10;    // 全局锚点监听器：name -&gt; handler（用于去重与清理）&#10;    this._globalAnchorListeners = new Map();&#10;&#10;    // 配置（暂未使用，保留兼容位）&#10;    this._overlayEl = null;&#10;    &#10;    // 全局锚点跟踪配置（统一使用毫秒）&#10;    this._anchorTrackingDurationMs = DEFAULT_TRACKING_DURATION_MS; // 默认锚点跟踪平滑动画持续时间（毫秒）&#10;    this._anchorTrackingEase = DEFAULT_TRACKING_EASE;&#10;&#10;    // 绑定事件监听&#10;    this._bindEvents();&#10;  }&#10;&#10;  // 内部工具：安全杀死当前 tween 并清空引用&#10;  _killCurrentTween(entry) {&#10;    if (entry?.currentTween) {&#10;      try { entry.currentTween.kill(); } catch (_) {}&#10;      entry.currentTween = null;&#10;    }&#10;  }&#10;&#10;  // 计算元素当前未缩放的基准尺寸（用于按中心对齐）&#10;  _getBaseSize(element) {&#10;    if (!element) return { width: 0, height: 0 };&#10;    // 使用未受变换影响的布局尺寸，避免旋转与缩放对基准尺寸计算的干扰&#10;    const ow = (typeof element.offsetWidth === 'number') ? element.offsetWidth : 0;&#10;    const oh = (typeof element.offsetHeight === 'number') ? element.offsetHeight : 0;&#10;    if (ow &gt; 0 &amp;&amp; oh &gt; 0) return { width: ow, height: oh };&#10;    // 兜底：用 rect 并除以当前缩放（若存在）&#10;    const rect = element.getBoundingClientRect();&#10;    const sx = parseFloat(gsap.getProperty(element, 'scaleX')) || 1;&#10;    const sy = parseFloat(gsap.getProperty(element, 'scaleY')) || 1;&#10;    const bw = sx ? rect.width / sx : rect.width;&#10;    const bh = sy ? rect.height / sy : rect.height;&#10;    return { width: bw, height: bh };&#10;  }&#10;&#10;  // 确保为 tracking 状态创建/更新 quickTo setters&#10;  _ensureQuickSetters(entry, { durationMs, ease } = {}) {&#10;    if (!entry || !entry.element) return;&#10;    const dSec = Math.max(0.001, ((typeof durationMs === 'number' ? durationMs : this._anchorTrackingDurationMs) || DEFAULT_TRACKING_DURATION_MS) / 1000);&#10;    const easing = ease || this._anchorTrackingEase;&#10;    const el = entry.element;&#10;&#10;    const cfgKey = `${dSec}|${easing}`;&#10;    if (entry._quickCfgKey === cfgKey &amp;&amp; entry._quick) return; // 已经存在且配置一致&#10;&#10;    entry._quick = {&#10;      x: gsap.quickTo(el, 'x', { duration: dSec, ease: easing, overwrite: true }),&#10;      y: gsap.quickTo(el, 'y', { duration: dSec, ease: easing, overwrite: true }),&#10;      scaleX: gsap.quickTo(el, 'scaleX', { duration: dSec, ease: easing, overwrite: true }),&#10;      scaleY: gsap.quickTo(el, 'scaleY', { duration: dSec, ease: easing, overwrite: true }),&#10;      rotation: gsap.quickTo(el, 'rotation', { duration: dSec, ease: easing, overwrite: true })&#10;    };&#10;    entry._quickCfgKey = cfgKey;&#10;  }&#10;&#10;  // 应用 tracking 目标（使用 quickTo 动态更新）&#10;  _applyTrackingQuickTarget(entry, anchor, opts = {}) {&#10;    if (!entry || !entry.element || !anchor) return;&#10;    this._ensureQuickSetters(entry, opts);&#10;&#10;    const el = entry.element;&#10;    // 计算基于目标 scale 的中心对齐 x/y&#10;    const base = this._getBaseSize(el);&#10;    const csx = parseFloat(gsap.getProperty(el, 'scaleX')) || 1;&#10;    const csy = parseFloat(gsap.getProperty(el, 'scaleY')) || 1;&#10;    const targetScale = (anchor.scale != null) ? anchor.scale : Math.max(csx, csy);&#10;    const x = anchor.x - (base.width * targetScale) / 2;&#10;    const y = anchor.y - (base.height * targetScale) / 2;&#10;&#10;    // 调用 quick setters 进行平滑跟踪&#10;    if (entry._quick) {&#10;      entry._quick.x(x);&#10;      entry._quick.y(y);&#10;      if (anchor.scale != null) {&#10;        entry._quick.scaleX(targetScale);&#10;        entry._quick.scaleY(targetScale);&#10;      }&#10;      if (anchor.rotation != null) entry._quick.rotation(anchor.rotation);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 初始化&#10;   */&#10;  init(options = {}) {&#10;    this._overlayEl = options.overlayEl || null;&#10;    &#10;    // 设置全局锚点&#10;    if (options.centerAnchorEl) {&#10;      this.setGlobalAnchorEl('center', options.centerAnchorEl);&#10;    }&#10;    &#10;    // 注意：不再从 overlayRefs 中设置 deckAnchorEl&#10;    // deck 锚点应该由 ActionPanel 在 mounted 时设置为实际的 DeckIcon&#10;    &#10;    // 其他全局锚点&#10;    Object.entries(options).forEach(([key, value]) =&gt; {&#10;      if (key.endsWith('AnchorEl') &amp;&amp; key !== 'centerAnchorEl' &amp;&amp; key !== 'deckAnchorEl') {&#10;        const name = key.replace(/AnchorEl$/, '');&#10;        this.setGlobalAnchorEl(name, value);&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 绑定前端事件总线监听&#10;   */&#10;  _bindEvents() {&#10;    // 监听动画元素指令&#10;    frontendEventBus.on('animate-element', (payload) =&gt; {&#10;      this.animate(payload);&#10;    });&#10;    &#10;    // 监听动画到锚点指令&#10;    frontendEventBus.on('animate-element-to-anchor', (payload) =&gt; {&#10;      this.animateToAnchor(payload.id, payload.anchor || 'rest', payload);&#10;    });&#10;    &#10;    // 进入跟踪状态指令&#10;    frontendEventBus.on('enter-element-tracking', (payload) =&gt; {&#10;      this.enterTracking(payload.id, payload);&#10;    });&#10;&#10;    // 标准化事件：进入某个状态&#10;    frontendEventBus.on('enter-element-dragging', ({ id }) =&gt; this.enterDragging(id));&#10;    frontendEventBus.on('enter-element-idle', ({ id }) =&gt; this.enterIdle(id));&#10;&#10;    // 效果事件&#10;    frontendEventBus.on('apply-element-effect', (payload) =&gt; this.applyEffect(payload));&#10;  }&#10;&#10;  // ========== 可动画元素注册表管理 ==========&#10;&#10;  /**&#10;   * 注册可动画元素&#10;   * @param {string|number} id - 元素唯一标识&#10;   * @param {HTMLElement} element - DOM 元素&#10;   * @param {string} adapterType - 适配器类型 ('card' | 'unit-panel')&#10;   */&#10;  register(id, element, adapterType = 'card') {&#10;    if (id == null || !element) {&#10;      console.warn('[animator] register: invalid id or element', id, element);&#10;      return;&#10;    }&#10;&#10;    const adapter = adapters[adapterType];&#10;    if (!adapter) {&#10;      console.warn('[animator] register: unknown adapter type', adapterType);&#10;      return;&#10;    }&#10;&#10;    // 解除旧的注册&#10;    if (this._registry.has(id)) {&#10;      this.unregister(id);&#10;    }&#10;&#10;    this._registry.set(id, {&#10;      element,&#10;      adapterType,&#10;      adapter,&#10;      anchor: null,&#10;      state: STATES.IDLE, // 当前状态&#10;      currentTween: null, // 当前的 GSAP tween（无论是跟踪还是指令）&#10;      isDragging: false&#10;    });&#10;    // 新注册的元素默认隐藏，避免在动画前一帧出现在 (0,0)&#10;    try { element.style.visibility = element.style.visibility || 'hidden'; } catch (_) {}&#10;  }&#10;&#10;  /**&#10;   * 解除可动画元素的注册&#10;   */&#10;  unregister(id) {&#10;    if (id == null) return;&#10;    &#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;&#10;    // 停止跟踪/动画/特效&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    this._interruptEffect(entry);&#10;&#10;    this._registry.delete(id);&#10;  }&#10;&#10;  /**&#10;   * 获取已注册的 DOM 元素&#10;   */&#10;  getElement(id) {&#10;    return this._registry.get(id)?.element || null;&#10;  }&#10;&#10;  // ========== 锚点管理 ==========&#10;&#10;  /**&#10;   * 更新容器的锚点信息&#10;   * @param {string} containerKey - 容器标识&#10;   * @param {Map&lt;string|number, {x, y, scale?, rotation?}&gt;} anchorsMap - 锚点目标动画参量映射&#10;   */&#10;  updateAnchors(containerKey, anchorsMap) {&#10;    if (!containerKey || !anchorsMap) {&#10;      console.warn('[animator] updateAnchors: invalid params', containerKey, anchorsMap);&#10;      return;&#10;    }&#10;&#10;    // 过滤掉无效的锚点，防止 NaN 坐标污染注册表&#10;    const safeMap = new Map();&#10;    for (const [id, anchor] of anchorsMap.entries()) {&#10;      if (!anchor) continue;&#10;      const sx = Number.isFinite(anchor.x) ? anchor.x : null;&#10;      const sy = Number.isFinite(anchor.y) ? anchor.y : null;&#10;      const ss = anchor.scale == null || Number.isFinite(anchor.scale) ? anchor.scale : null;&#10;      if (sx != null &amp;&amp; sy != null) {&#10;        // 复制一份，避免外部引用被后续修改&#10;        const item = { x: sx, y: sy };&#10;        if (ss != null) item.scale = ss;&#10;        if (anchor.rotation != null &amp;&amp; Number.isFinite(anchor.rotation)) item.rotation = anchor.rotation;&#10;        safeMap.set(id, item);&#10;      }&#10;    }&#10;&#10;    // 如果没有有效锚点，直接返回，不更新现有状态&#10;    if (safeMap.size === 0) return;&#10;&#10;    this._containerAnchors.set(containerKey, safeMap);&#10;&#10;    // 更新注册表中的锚点引用&#10;    for (const [id, anchor] of safeMap.entries()) {&#10;      const entry = this._registry.get(id);&#10;      if (entry) {&#10;        entry.anchor = anchor;&#10;        // 根据当前状态处理锚点更新&#10;        if (entry.state === STATES.TRACKING) {&#10;          // 使用 quickTo 平滑更新目标&#10;          this._applyTrackingQuickTarget(entry, anchor);&#10;        }&#10;        // idle / animating 或 dragging 状态：和anchor无关，不干预&#10;      }&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 计算锚点目标属性（内部助手函数）&#10;   * @private&#10;   */&#10;  _computeAnchorTargetProps(element, anchor) {&#10;    if (!element || !anchor) return null;&#10;    const base = this._getBaseSize(element);&#10;    const csx = parseFloat(gsap.getProperty(element, 'scaleX')) || 1;&#10;    const csy = parseFloat(gsap.getProperty(element, 'scaleY')) || 1;&#10;    const currentScale = Math.max(csx, csy);&#10;    const targetScale = (anchor.scale != null) ? anchor.scale : currentScale;&#10;    return {&#10;      x: anchor.x - (base.width * targetScale) / 2,&#10;      y: anchor.y - (base.height * targetScale) / 2,&#10;      scale: targetScale,&#10;      rotation: anchor.rotation || 0&#10;    };&#10;  }&#10;&#10;  /**&#10;   * 创建锚点跟踪动画（锚点跟踪状态的核心逻辑，被多个方法复用）&#10;   * @private&#10;   * @param {Object} entry - 注册表项&#10;   * @param {Object} anchor - 锚点对象&#10;   * @param {Object} options - 选项&#10;   * @param {number} [options.durationMs] - 跟踪持续时长（毫秒）&#10;   * @param {string} [options.ease] - 缓动函数&#10;   * @param {Function} [options.onComplete] - 完成回调（可选）&#10;   * @param {Function} [options.onInterrupt] - 中断回调（可选）&#10;   * @returns {Object} GSAP tween 对象&#10;   */&#10;  _createTrackingTween(entry, anchor, options = {}) {&#10;    if (!entry || !anchor || !entry.element) return null;&#10;    &#10;    const { element } = entry;&#10;    const targetProps = this._computeAnchorTargetProps(element, anchor);&#10;    if (!targetProps) return null;&#10;    &#10;    // 使用默认配置或自定义参数（统一使用毫秒，to 时转换为秒）&#10;    const durationMs = typeof options.durationMs === 'number' ? options.durationMs : this._anchorTrackingDurationMs;&#10;    const durationSec = Math.max(0.001, (durationMs || DEFAULT_TRACKING_DURATION_MS) / 1000);&#10;    const ease = options.ease || this._anchorTrackingEase;&#10;    &#10;    // 创建跟踪动画&#10;    const tween = gsap.to(element, {&#10;      ...targetProps,&#10;      duration: durationSec,&#10;      ease,&#10;      overwrite: true,&#10;      onComplete: () =&gt; {&#10;        // 默认行为：完成后，清理tween，但仍保持 tracking 状态，如此，在锚点移动时可继续启动动画并继续跟踪&#10;        if (entry.currentTween === tween) {&#10;          entry.currentTween = null;&#10;        }&#10;        // 执行自定义回调&#10;        if (options.onComplete) {&#10;          options.onComplete();&#10;        }&#10;      },&#10;      onInterrupt: () =&gt; {&#10;        if (entry.currentTween === tween) {&#10;          entry.currentTween = null;&#10;        }&#10;        // 执行自定义回调&#10;        if (options.onInterrupt) {&#10;          options.onInterrupt();&#10;        }&#10;      }&#10;    });&#10;    &#10;    return tween;&#10;  }&#10;  &#10;  // 工具：移除并替换指定全局锚点的 resize 监听（防止重复监听）&#10;  _replaceGlobalAnchorResizeListener(name, handler) {&#10;    const prev = this._globalAnchorListeners.get(name);&#10;    if (prev &amp;&amp; typeof window !== 'undefined') {&#10;      try { window.removeEventListener('resize', prev); } catch (_) {}&#10;    }&#10;    if (handler) {&#10;      this._globalAnchorListeners.set(name, handler);&#10;      try { window.addEventListener('resize', handler, { passive: true }); } catch (_) {}&#10;    } else {&#10;      this._globalAnchorListeners.delete(name);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 应用锚点位置到元素（立即设置，无动画）&#10;   */&#10;  setGlobalAnchorEl(name, element) {&#10;    if (!name) return;&#10;    &#10;    const updatePosition = () =&gt; {&#10;      if(!element) {&#10;        // 移除全局锚点与监听&#10;        this._globalAnchors.delete(name);&#10;        this._replaceGlobalAnchorResizeListener(name, null);&#10;        return;&#10;      }&#10;      const rect = element.getBoundingClientRect();&#10;      if (rect) {&#10;        const anchor = {&#10;          x: rect.left + rect.width / 2,&#10;          y: rect.top + rect.height / 2&#10;        };&#10;        this._globalAnchors.set(name, anchor);&#10;      }&#10;    };&#10;&#10;    updatePosition();&#10;    // 使用替换逻辑避免重复监听&#10;    this._replaceGlobalAnchorResizeListener(name, updatePosition);&#10;  }&#10;&#10;  /**&#10;   * 设置全局锚点（直接坐标）&#10;   */&#10;  setGlobalAnchor(name, position) {&#10;    if (!name || !position) return;&#10;    this._globalAnchors.set(name, { x: position.x, y: position.y });&#10;  }&#10;&#10;  /**&#10;   * 获取锚点坐标&#10;   */&#10;  getAnchorPoint(anchorName) {&#10;    // 如果是对象形式的坐标，直接返回&#10;    if (typeof anchorName === 'object' &amp;&amp; anchorName.x != null &amp;&amp; anchorName.y != null) {&#10;      return { x: anchorName.x, y: anchorName.y };&#10;    }&#10;&#10;    // 从全局锚点获取&#10;    if (typeof anchorName === 'string') {&#10;      const global = this._globalAnchors.get(anchorName);&#10;      if (global) {&#10;        // console.log(`[animator] Using global anchor '${anchorName}':`, global);&#10;        return global;&#10;      }&#10;      console.warn(`[animator] Global anchor '${anchorName}' not found, using screen center`);&#10;    }&#10;&#10;    // 默认返回屏幕中心&#10;    return {&#10;      x: window.innerWidth / 2,&#10;      y: window.innerHeight / 2&#10;    };&#10;  }&#10;&#10;  // ========== 动画执行 ==========&#10;&#10;  /**&#10;   * 应用特效（独立于普通位移动画），保持与历史行为一致：&#10;   * - 停止 tracking 与当前 tween&#10;   * - 进入 animating 状态&#10;   * - 播放特效，duration 后回到 idle，并通知完成&#10;   */&#10;  applyEffect(payload) {&#10;    const { id, effect, duration = 300, instructionId } = payload || {};&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] applyEffect: element not registered', id);&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      return;&#10;    }&#10;&#10;    const { element } = entry;&#10;&#10;    // 统一前置：停止 tracking/动画，进入 animating&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    // 若已有特效，先中断并释放&#10;    this._interruptEffect(entry);&#10;    entry.state = STATES.ANIMATING;&#10;&#10;    // 分发具体效果&#10;    let tween = null;&#10;    switch (effect) {&#10;      case 'shake':&#10;        tween = this._applyShakeEffect(element, payload);&#10;        break;&#10;      default:&#10;        console.warn('[animator] applyEffect: unknown effect', effect);&#10;        break;&#10;    }&#10;&#10;    // 注册可中断的特效状态&#10;    const timerId = setTimeout(() =&gt; {&#10;      // 正常完成路径&#10;      if (entry.state === STATES.ANIMATING) {&#10;        entry.state = STATES.IDLE;&#10;      }&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      delete entry._effect;&#10;    }, duration);&#10;    entry._effect = { timerId, tween, instructionId };&#10;  }&#10;&#10;  /**&#10;   * 切换到animating状态并执行动画指令，在duration后停止动画并回归idle状态。&#10;   */&#10;  animate(payload) {&#10;    const { id, from = {}, to = {}, duration = 300, ease = defaultEase, anchor, instructionId, effect } = payload;&#10;&#10;    // 如果是特效请求，改由 applyEffect 处理&#10;    if (effect) {&#10;      this.applyEffect(payload);&#10;      return;&#10;    }&#10;&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] animate: element not registered', id);&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      return;&#10;    }&#10;&#10;    const { element, adapter } = entry;&#10;&#10;    // 1. 停止tracking状态的跟踪动画（如果正在进行）&#10;    this._stopTracking(entry);&#10;    // 1.1 若有特效，先中断并释放&#10;    this._interruptEffect(entry);&#10;&#10;    // 2. 杀死当前正在执行的动画（如果有）&#10;    this._killCurrentTween(entry);&#10;&#10;    // 3. 转换到 animating 状态&#10;    entry.state = STATES.ANIMATING;&#10;&#10;    // 前处理&#10;    try { adapter.beforeAnimate(element, payload); } catch (_) {}&#10;&#10;    // 构建起始属性 (from)&#10;    const fromProps = {};&#10;&#10;    // 处理 from.anchor&#10;    if (from.anchor) {&#10;      const anchorPoint = this.getAnchorPoint(from.anchor);&#10;      const rect = element.getBoundingClientRect();&#10;      fromProps.x = anchorPoint.x - rect.width / 2;&#10;      fromProps.y = anchorPoint.y - rect.height / 2;&#10;    }&#10;&#10;    // 合并 from 属性（统一 rotation 命名）&#10;    if (from.x != null) fromProps.x = from.x;&#10;    if (from.y != null) fromProps.y = from.y;&#10;    if (from.scale != null) fromProps.scale = from.scale;&#10;    if (from.rotation != null) fromProps.rotation = from.rotation;&#10;    if (from.rotate != null) fromProps.rotation = from.rotate; // 兼容别名&#10;    if (from.opacity != null) fromProps.autoAlpha = from.opacity;&#10;&#10;    // 如果有 from 属性，先立即设置到起始位置&#10;    if (Object.keys(fromProps).length &gt; 0) {&#10;      gsap.set(element, fromProps);&#10;      // 若元素仍处于隐藏状态且未指定 from.opacity，则在定位后再显现，避免 (0,0) 闪烁&#10;      if (element.style.visibility === 'hidden' &amp;&amp; from.opacity == null) {&#10;        gsap.set(element, { autoAlpha: 1 });&#10;      }&#10;    } else {&#10;      // 无 from 属性：若元素仍为隐藏，则直接显现&#10;      if (element.style.visibility === 'hidden') {&#10;        gsap.set(element, { autoAlpha: 1 });&#10;      }&#10;    }&#10;&#10;    // 构建目标属性 (to)&#10;    const toProps = {};&#10;&#10;    // 处理顶层 anchor（目标锚点）&#10;    if (anchor) {&#10;      const anchorPoint = this.getAnchorPoint(anchor);&#10;      const rect = element.getBoundingClientRect();&#10;      toProps.x = anchorPoint.x - rect.width / 2;&#10;      toProps.y = anchorPoint.y - rect.height / 2;&#10;    }&#10;&#10;    // 合并 to 属性（统一 rotation 命名）&#10;    if (to.x != null) toProps.x = to.x;&#10;    if (to.y != null) toProps.y = to.y;&#10;    if (to.scale != null) toProps.scale = to.scale;&#10;    if (to.rotation != null) toProps.rotation = to.rotation;&#10;    if (to.rotate != null) toProps.rotation = to.rotate; // 兼容别名&#10;    if (to.opacity != null) toProps.autoAlpha = to.opacity;&#10;&#10;    // 4. 创建新的动画 tween&#10;    const tween = gsap.to(element, {&#10;      ...toProps,&#10;      duration: Math.max(0.001, duration / 1000),&#10;      ease,&#10;      force3D: true,&#10;      lazy: false,&#10;      overwrite: true, // 强制覆盖，确保单一通道&#10;      onComplete: () =&gt; {&#10;        try { adapter.afterAnimate(element, payload); } catch (_) {}&#10;&#10;        // 动画完成，回到 idle 状态（不自动恢复跟踪）&#10;        if (entry.state === STATES.ANIMATING) {&#10;          entry.state = STATES.IDLE;&#10;        }&#10;        entry.currentTween = null;&#10;&#10;        // 通知完成&#10;        if (instructionId) {&#10;          frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;        }&#10;      },&#10;      onInterrupt: () =&gt; {&#10;        // 被中断也要清理状态&#10;        entry.currentTween = null;&#10;        if (entry.state === STATES.ANIMATING) {&#10;          entry.state = STATES.IDLE;&#10;        }&#10;        if (instructionId) {&#10;          frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;        }&#10;      }&#10;    });&#10;&#10;    // 保存当前 tween&#10;    entry.currentTween = tween;&#10;  }&#10;&#10;  /**&#10;   * 动画到锚点（快捷方法）&#10;   */&#10;  animateToAnchor(id, anchorName, options = {}) {&#10;    this.animate({&#10;      id,&#10;      anchor: anchorName,&#10;      to: {},&#10;      duration: options.duration || 300,&#10;      ease: options.ease || defaultEase,&#10;      instructionId: options.instructionId&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 应用震动效果&#10;   */&#10;  _applyShakeEffect(element, payload) {&#10;    const { intensity = 2, duration = 300 } = payload;&#10;    // 每次抖动的单程时长 50ms，往返一次 100ms&#10;    const cycleMs = 100;&#10;    const repeats = Math.max(0, Math.floor(duration / cycleMs) * 2); // 偶数次半程，保证回到原位&#10;&#10;    return gsap.to(element, {&#10;      x: `+=${intensity}`,&#10;      duration: 0.05,&#10;      repeat: repeats,&#10;      yoyo: true,&#10;      ease: 'power1.inOut'&#10;      // 去掉 onComplete 的强制 x=0，避免覆盖原始位置&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 停止跟踪动画（内部使用）&#10;   */&#10;  _stopTracking(entry) {&#10;    if (!entry) return;&#10;    if (entry.state === STATES.TRACKING &amp;&amp; entry.currentTween) {&#10;      entry.currentTween.kill();&#10;      entry.currentTween = null;&#10;    }&#10;    // 结束 quickTo 产生的补间，避免影响下一次动画&#10;    try { gsap.killTweensOf(entry.element, 'x,y,scaleX,scaleY,rotation'); } catch (_) {}&#10;    entry._quick = null;&#10;    entry._quickCfgKey = null;&#10;  }&#10;&#10;  // ========== 拖拽状态管理 ==========&#10;&#10;  /**&#10;   * 统一入口：进入拖拽状态（推荐使用）&#10;   */&#10;  enterDragging(id) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;&#10;    // 停止跟踪动画（tracking状态）&#10;    this._stopTracking(entry);&#10;    // 中断特效&#10;    this._interruptEffect(entry);&#10;&#10;    // 杀死当前正在执行的动画（animating状态）&#10;    this._killCurrentTween(entry);&#10;&#10;    // 转换到 dragging 状态&#10;    entry.state = STATES.DRAGGING;&#10;    entry.isDragging = true;&#10;  }&#10;&#10;  // ========== 锚点跟踪 ==========&#10;  /**&#10;   * 进入锚点跟踪（从任意状态切换到 tracking 状态）&#10;   * 每种状态仅保留一个入口方法：enterTracking&#10;   * @param {string|number} id - 元素 ID&#10;   * @param {Object} options - 选项&#10;   * @param {number} [options.duration] - 跟踪平滑持续时长（毫秒），默认使用全局配置&#10;   * @param {string} [options.ease] - 缓动函数&#10;   * @param {string} [options.instructionId] - 指令 ID（用于通知完成）&#10;   */&#10;  enterTracking(id, options = {}) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] enterTracking: element not registered', id);&#10;      // 不再释放 animation-instruction-finished（这是状态切换指令）&#10;      return;&#10;    }&#10;&#10;    if (!entry.anchor) {&#10;      console.warn('[animator] enterTracking: element has no anchor', id);&#10;      // 不再释放 animation-instruction-finished（这是状态切换指令）&#10;      return;&#10;    }&#10;&#10;    // 停止当前动画（如果有）&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    // 中断特效&#10;    this._interruptEffect(entry);&#10;&#10;    // 转换到 tracking 状态&#10;    entry.state = STATES.TRACKING;&#10;&#10;    // 初始化 quickTo 并应用当前 anchor 目标&#10;    this._ensureQuickSetters(entry, { durationMs: options.duration, ease: options.ease });&#10;    this._applyTrackingQuickTarget(entry, entry.anchor, { durationMs: options.duration, ease: options.ease });&#10;&#10;    // tracking 模式下不再使用 currentTween&#10;    entry.currentTween = null;&#10;&#10;    // 不释放 animation-instruction-finished（这是状态切换指令）&#10;  }&#10;&#10;  /**&#10;   * 设置全局锚点跟踪配置（毫秒）&#10;   */&#10;  setAnchorTrackingConfig({ duration, ease } = {}) {&#10;    if (duration != null) this._anchorTrackingDurationMs = duration;&#10;    if (ease != null) this._anchorTrackingEase = ease;&#10;  }&#10;&#10;  /**&#10;   * 主动进入 idle（提供统一的状态入口）&#10;   */&#10;  enterIdle(id) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;    // 终止一切动画与拖拽&#10;    this._killCurrentTween(entry);&#10;    this._stopTracking(entry);&#10;    this._interruptEffect(entry);&#10;    entry.isDragging = false;&#10;    entry.state = STATES.IDLE;&#10;  }&#10;&#10;  /**&#10;   * 重置所有动画，清空registry&#10;   */&#10;  reset() {&#10;    for (const [, entry] of this._registry.entries()) {&#10;      this._killCurrentTween(entry);&#10;      this._interruptEffect(entry);&#10;    }&#10;    this._registry.clear();&#10;    this._containerAnchors.clear();&#10;&#10;    // 清理全局锚点监听&#10;    if (typeof window !== 'undefined') {&#10;      for (const [name, handler] of this._globalAnchorListeners.entries()) {&#10;        try { window.removeEventListener('resize', handler); } catch (_) {}&#10;      }&#10;    }&#10;    this._globalAnchorListeners.clear();&#10;  }&#10;&#10;  /**&#10;   * 调试工具：获取当前状态&#10;   */&#10;  getStatus() {&#10;    const entries = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      entries.push({&#10;        id,&#10;        adapterType: entry.adapterType,&#10;        state: entry.state,&#10;        hasAnchor: !!entry.anchor,&#10;        isDragging: entry.isDragging,&#10;        hasTween: !!entry.currentTween&#10;      });&#10;    }&#10;    return {&#10;      registered: this._registry.size,&#10;      containers: this._containerAnchors.size,&#10;      globalAnchors: Array.from(this._globalAnchors.keys()),&#10;      entries&#10;    };&#10;  }&#10;&#10;  /**&#10;   * 调试工具：打印状态&#10;   */&#10;  debug() {&#10;    const status = this.getStatus();&#10;    console.log('[animator] Status:', status);&#10;    console.table(status.entries);&#10;  }&#10;&#10;  /**&#10;   * 注册一个新的适配器类型（可扩展）&#10;   * @param {string} type - 适配器类型名&#10;   * @param {Object} adapter - 适配器实例，需实现 beforeAnimate/afterAnimate 等可选接口&#10;   */&#10;  registerAdapter(type, adapter) {&#10;    if (!type || !adapter) return;&#10;    adapters[type] = adapter;&#10;  }&#10;&#10;  /**&#10;   * 直接设置某个元素的锚点（绕过容器批量更新），便于个别元素临时锚点调整&#10;   * 若元素当前处于 tracking，则立即更新其跟踪目标&#10;   * @param {string|number} id&#10;   * @param {{x:number,y:number,scale?:number,rotation?:number}} anchor&#10;   */&#10;  setElementAnchor(id, anchor) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] setElementAnchor: element not registered', id);&#10;      return;&#10;    }&#10;    entry.anchor = anchor || null;&#10;    if (entry.anchor &amp;&amp; entry.state === STATES.TRACKING) {&#10;      // 使用 quickTo 平滑更新目标&#10;      this._applyTrackingQuickTarget(entry, entry.anchor);&#10;    }&#10;  }&#10;&#10;  // 结束当前正在进行的特效（若有），并通知完成（作为中断）&#10;  _interruptEffect(entry) {&#10;    if (!entry || !entry._effect) return;&#10;    const { timerId, tween, instructionId } = entry._effect || {};&#10;    try { if (timerId) clearTimeout(timerId); } catch (_) {}&#10;    try { if (tween) tween.kill(); } catch (_) {}&#10;    if (instructionId) {&#10;      frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;    }&#10;    delete entry._effect;&#10;  }&#10;&#10;  /**&#10;   * 获取指定适配器类型已注册元素的快照列表&#10;   * @param {string} adapterType 例如 'card' | 'unit-panel'&#10;   * @returns {Array&lt;{ id: string, element: HTMLElement, adapterType: string }&gt;}&#10;   */&#10;  getRegisteredByAdapter(adapterType) {&#10;    const list = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      if (!entry?.element) continue;&#10;      if (!adapterType || entry.adapterType === adapterType) {&#10;        list.push({ id, element: entry.element, adapterType: entry.adapterType });&#10;      }&#10;    }&#10;    return list;&#10;  }&#10;&#10;  /**&#10;   * 获取指定适配器类型的元素几何快照（用于 Pixi overlay 精确对齐）&#10;   * 返回: [{ id, cx, cy, baseW, baseH, rot, sx, sy, opacity }]&#10;   */&#10;  getTransformsSnapshotByAdapter(adapterType) {&#10;    const list = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      if (!entry?.element) continue;&#10;      if (adapterType &amp;&amp; entry.adapterType !== adapterType) continue;&#10;      const el = entry.element;&#10;      const rect = el.getBoundingClientRect();&#10;      if (!rect || rect.width &lt;= 0 || rect.height &lt;= 0) continue;&#10;      // 读取 CSS 变换矩阵&#10;      const cs = getComputedStyle(el);&#10;      const t = cs.transform;&#10;      let rot = 0, sx = 1, sy = 1;&#10;      if (t &amp;&amp; t !== 'none') {&#10;        const m = new DOMMatrix(t);&#10;        // 提取旋转与缩放（2D）&#10;        rot = Math.atan2(m.m12, m.m11);&#10;        sx = Math.hypot(m.m11, m.m12);&#10;        sy = Math.hypot(m.m21, m.m22);&#10;      }&#10;      // 基础尺寸（未受缩放/旋转影响）&#10;      let baseW = el.offsetWidth || 0;&#10;      let baseH = el.offsetHeight || 0;&#10;      if (!baseW || !baseH) {&#10;        // 兜底：用当前 AABB 反推（粗略）&#10;        baseW = rect.width / (sx || 1);&#10;        baseH = rect.height / (sy || 1);&#10;      }&#10;      const cx = rect.left + rect.width / 2;&#10;      const cy = rect.top + rect.height / 2;&#10;      const opacity = parseFloat(cs.opacity) || 1;&#10;      list.push({ id, cx, cy, baseW, baseH, rot, sx, sy, opacity });&#10;    }&#10;    return list;&#10;  }&#10;}&#10;&#10;// 导出单例&#10;const animator = new Animator();&#10;&#10;// 添加到 window 以便调试&#10;if (typeof window !== 'undefined') {&#10;  window.__animator = animator;&#10;  window.__debugAnimator = () =&gt; animator.debug();&#10;}&#10;&#10;export default animator;&#10;" />
              <option name="updatedContent" value="// animator.js - 新一代动画编排器&#10;// 核心职责：&#10;// 1. 管理可动画元素的 DOM 注册表&#10;// 2. 执行来自 animationSequencer 的动画指令&#10;// 3. 管理锚点信息，实现元素向锚点的&quot;静息归位&quot;&#10;// 4. 提供适配器机制，支持不同类型元素的动画&#10;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import gsap from 'gsap';&#10;&#10;const defaultEase = 'power2.out';&#10;&#10;// ========== 状态与配置常量 ==========&#10;const STATES = Object.freeze({&#10;  IDLE: 'idle',&#10;  TRACKING: 'tracking',&#10;  ANIMATING: 'animating',&#10;  DRAGGING: 'dragging'&#10;});&#10;&#10;// 跟踪动画的默认平滑时间（毫秒）与缓动&#10;const DEFAULT_TRACKING_DURATION_MS = 300;&#10;const DEFAULT_TRACKING_EASE = 'power1.out';&#10;&#10;// ========== 适配器接口 ==========&#10;&#10;/**&#10; * 卡牌适配器&#10; */&#10;class CardAdapter {&#10;  getDefaultProps(element) {&#10;    const rect = element?.getBoundingClientRect?.();&#10;    return {&#10;      width: rect?.width || 198,&#10;      height: rect?.height || 266&#10;    };&#10;  }&#10;&#10;  beforeAnimate(element, animationPayload) {&#10;    // 卡牌动画前的预处理&#10;  }&#10;&#10;  afterAnimate(element, animationPayload) {&#10;    // 卡牌动画后的清理&#10;  }&#10;&#10;  getRestPosition(id, anchorsMap) {&#10;    return anchorsMap.get(id) || null;&#10;  }&#10;}&#10;&#10;/**&#10; * 单位面板适配器&#10; */&#10;class UnitPanelAdapter {&#10;  getDefaultProps(element) {&#10;    const rect = element?.getBoundingClientRect?.();&#10;    return {&#10;      width: rect?.width || 300,&#10;      height: rect?.height || 200&#10;    };&#10;  }&#10;&#10;  beforeAnimate(element, animationPayload) {&#10;    // 面板动画前的预处理&#10;  }&#10;&#10;  afterAnimate(element, animationPayload) {&#10;    // 面板动画后的清理&#10;  }&#10;&#10;  getRestPosition(id, anchorsMap) {&#10;    return anchorsMap.get(id) || null;&#10;  }&#10;}&#10;&#10;// 适配器工厂&#10;const adapters = {&#10;  'card': new CardAdapter(),&#10;  'unit-panel': new UnitPanelAdapter()&#10;};&#10;&#10;// ========== Animator 核心类 ==========&#10;// Animator用于维护与播放可动画元素的动画和它们的状态&#10;// 可动画元素的状态列表：'idle' | 'tracking' | 'animating' | 'dragging'&#10;// 每个可动画元素在任意时刻能且仅能属于一个状态&#10;// idle: 待命，无动画，保持元素现有动画参量不变。&#10;// tracking: 元素正维持锚点跟踪，在锚点状态移动时，元素会平滑跟踪到锚点的目标状态。比如手牌。使用一个动态更新目标参数的长时动画实现&#10;// animating: 元素正在执行指令动画（animate），比如刚刚打出、抽取、发动的卡牌&#10;// dragging: 元素正被鼠标拖拽。这是一个特殊状态，一般用于被玩家使用鼠标拖拽中的卡牌上，一般用于在休整时切换排序和卡牌上下场&#10;// 在没有外部干预情况下，状态仅会在自动切换至idle。若要切换到tracking、animating、dragging，则需要外部方法调用完成&#10;&#10;class Animator {&#10;  constructor() {&#10;    // DOM 注册表: id -&gt; { element, adapterType, adapter, anchor, state, currentTween, isDragging }&#10;    this._registry = new Map();&#10;    &#10;    // 容器锚点表: containerKey -&gt; Map&lt;id, { x, y, scale?, rotation? }&gt;&#10;    this._containerAnchors = new Map();&#10;    &#10;    // 全局锚点: name -&gt; { x, y }&#10;    this._globalAnchors = new Map();&#10;&#10;    // 全局锚点监听器：name -&gt; handler（用于去重与清理）&#10;    this._globalAnchorListeners = new Map();&#10;&#10;    // 配置（暂未使用，保留兼容位）&#10;    this._overlayEl = null;&#10;    &#10;    // 全局锚点跟踪配置（统一使用毫秒）&#10;    this._anchorTrackingDurationMs = DEFAULT_TRACKING_DURATION_MS; // 默认锚点跟踪平滑动画持续时间（毫秒）&#10;    this._anchorTrackingEase = DEFAULT_TRACKING_EASE;&#10;&#10;    // 绑定事件监听&#10;    this._bindEvents();&#10;  }&#10;&#10;  // 内部工具：安全杀死当前 tween 并清空引用&#10;  _killCurrentTween(entry) {&#10;    if (entry?.currentTween) {&#10;      try { entry.currentTween.kill(); } catch (_) {}&#10;      entry.currentTween = null;&#10;    }&#10;  }&#10;&#10;  // 计算元素当前未缩放的基准尺寸（用于按中心对齐）&#10;  _getBaseSize(element) {&#10;    if (!element) return { width: 0, height: 0 };&#10;    // 使用未受变换影响的布局尺寸，避免旋转与缩放对基准尺寸计算的干扰&#10;    const ow = (typeof element.offsetWidth === 'number') ? element.offsetWidth : 0;&#10;    const oh = (typeof element.offsetHeight === 'number') ? element.offsetHeight : 0;&#10;    if (ow &gt; 0 &amp;&amp; oh &gt; 0) return { width: ow, height: oh };&#10;    // 兜底：用 rect 并除以当前缩放（若存在）&#10;    const rect = element.getBoundingClientRect();&#10;    const sx = parseFloat(gsap.getProperty(element, 'scaleX')) || 1;&#10;    const sy = parseFloat(gsap.getProperty(element, 'scaleY')) || 1;&#10;    const bw = sx ? rect.width / sx : rect.width;&#10;    const bh = sy ? rect.height / sy : rect.height;&#10;    return { width: bw, height: bh };&#10;  }&#10;&#10;  // 确保为 tracking 状态创建/更新 quickTo setters&#10;  _ensureQuickSetters(entry, { durationMs, ease } = {}) {&#10;    if (!entry || !entry.element) return;&#10;    const dSec = Math.max(0.001, ((typeof durationMs === 'number' ? durationMs : this._anchorTrackingDurationMs) || DEFAULT_TRACKING_DURATION_MS) / 1000);&#10;    const easing = ease || this._anchorTrackingEase;&#10;    const el = entry.element;&#10;&#10;    const cfgKey = `${dSec}|${easing}`;&#10;    if (entry._quickCfgKey === cfgKey &amp;&amp; entry._quick) return; // 已经存在且配置一致&#10;&#10;    entry._quick = {&#10;      x: gsap.quickTo(el, 'x', { duration: dSec, ease: easing, overwrite: true }),&#10;      y: gsap.quickTo(el, 'y', { duration: dSec, ease: easing, overwrite: true }),&#10;      scaleX: gsap.quickTo(el, 'scaleX', { duration: dSec, ease: easing, overwrite: true }),&#10;      scaleY: gsap.quickTo(el, 'scaleY', { duration: dSec, ease: easing, overwrite: true }),&#10;      rotation: gsap.quickTo(el, 'rotation', { duration: dSec, ease: easing, overwrite: true })&#10;    };&#10;    entry._quickCfgKey = cfgKey;&#10;  }&#10;&#10;  // 应用 tracking 目标（使用 quickTo 动态更新）&#10;  _applyTrackingQuickTarget(entry, anchor, opts = {}) {&#10;    if (!entry || !entry.element || !anchor) return;&#10;    this._ensureQuickSetters(entry, opts);&#10;&#10;    const el = entry.element;&#10;    // 计算基于目标 scale 的中心对齐 x/y&#10;    const base = this._getBaseSize(el);&#10;    const csx = parseFloat(gsap.getProperty(el, 'scaleX')) || 1;&#10;    const csy = parseFloat(gsap.getProperty(el, 'scaleY')) || 1;&#10;    const targetScale = (anchor.scale != null) ? anchor.scale : Math.max(csx, csy);&#10;    const x = anchor.x - (base.width * targetScale) / 2;&#10;    const y = anchor.y - (base.height * targetScale) / 2;&#10;&#10;    // 调用 quick setters 进行平滑跟踪&#10;    if (entry._quick) {&#10;      entry._quick.x(x);&#10;      entry._quick.y(y);&#10;      if (anchor.scale != null) {&#10;        entry._quick.scaleX(targetScale);&#10;        entry._quick.scaleY(targetScale);&#10;      }&#10;      if (anchor.rotation != null) entry._quick.rotation(anchor.rotation);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 初始化&#10;   */&#10;  init(options = {}) {&#10;    this._overlayEl = options.overlayEl || null;&#10;    &#10;    // 设置全局锚点&#10;    if (options.centerAnchorEl) {&#10;      this.setGlobalAnchorEl('center', options.centerAnchorEl);&#10;    }&#10;    &#10;    // 注意：不再从 overlayRefs 中设置 deckAnchorEl&#10;    // deck 锚点应该由 ActionPanel 在 mounted 时设置为实际的 DeckIcon&#10;    &#10;    // 其他全局锚点&#10;    Object.entries(options).forEach(([key, value]) =&gt; {&#10;      if (key.endsWith('AnchorEl') &amp;&amp; key !== 'centerAnchorEl' &amp;&amp; key !== 'deckAnchorEl') {&#10;        const name = key.replace(/AnchorEl$/, '');&#10;        this.setGlobalAnchorEl(name, value);&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 绑定前端事件总线监听&#10;   */&#10;  _bindEvents() {&#10;    // 监听动画元素指令&#10;    frontendEventBus.on('animate-element', (payload) =&gt; {&#10;      this.animate(payload);&#10;    });&#10;    &#10;    // 监听动画到锚点指令&#10;    frontendEventBus.on('animate-element-to-anchor', (payload) =&gt; {&#10;      this.animateToAnchor(payload.id, payload.anchor || 'rest', payload);&#10;    });&#10;    &#10;    // 进入跟踪状态指令&#10;    frontendEventBus.on('enter-element-tracking', (payload) =&gt; {&#10;      this.enterTracking(payload.id, payload);&#10;    });&#10;&#10;    // 标准化事件：进入某个状态&#10;    frontendEventBus.on('enter-element-dragging', ({ id }) =&gt; this.enterDragging(id));&#10;    frontendEventBus.on('enter-element-idle', ({ id }) =&gt; this.enterIdle(id));&#10;&#10;    // 效果事件&#10;    frontendEventBus.on('apply-element-effect', (payload) =&gt; this.applyEffect(payload));&#10;  }&#10;&#10;  // ========== 可动画元素注册表管理 ==========&#10;&#10;  /**&#10;   * 注册可动画元素&#10;   * @param {string|number} id - 元素唯一标识&#10;   * @param {HTMLElement} element - DOM 元素&#10;   * @param {string} adapterType - 适配器类型 ('card' | 'unit-panel')&#10;   */&#10;  register(id, element, adapterType = 'card') {&#10;    if (id == null || !element) {&#10;      console.warn('[animator] register: invalid id or element', id, element);&#10;      return;&#10;    }&#10;&#10;    const adapter = adapters[adapterType];&#10;    if (!adapter) {&#10;      console.warn('[animator] register: unknown adapter type', adapterType);&#10;      return;&#10;    }&#10;&#10;    // 解除旧的注册&#10;    if (this._registry.has(id)) {&#10;      this.unregister(id);&#10;    }&#10;&#10;    this._registry.set(id, {&#10;      element,&#10;      adapterType,&#10;      adapter,&#10;      anchor: null,&#10;      state: STATES.IDLE, // 当前状态&#10;      currentTween: null, // 当前的 GSAP tween（无论是跟踪还是指令）&#10;      isDragging: false&#10;    });&#10;    // 新注册的元素默认隐藏，避免在动画前一帧出现在 (0,0)&#10;    try { element.style.visibility = element.style.visibility || 'hidden'; } catch (_) {}&#10;  }&#10;&#10;  /**&#10;   * 解除可动画元素的注册&#10;   */&#10;  unregister(id) {&#10;    if (id == null) return;&#10;    &#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;&#10;    // 停止跟踪/动画/特效&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    this._interruptEffect(entry);&#10;&#10;    this._registry.delete(id);&#10;  }&#10;&#10;  /**&#10;   * 获取已注册的 DOM 元素&#10;   */&#10;  getElement(id) {&#10;    return this._registry.get(id)?.element || null;&#10;  }&#10;&#10;  // ========== 锚点管理 ==========&#10;&#10;  /**&#10;   * 更新容器的锚点信息&#10;   * @param {string} containerKey - 容器标识&#10;   * @param {Map&lt;string|number, {x, y, scale?, rotation?}&gt;} anchorsMap - 锚点目标动画参量映射&#10;   */&#10;  updateAnchors(containerKey, anchorsMap) {&#10;    if (!containerKey || !anchorsMap) {&#10;      console.warn('[animator] updateAnchors: invalid params', containerKey, anchorsMap);&#10;      return;&#10;    }&#10;&#10;    // 过滤掉无效的锚点，防止 NaN 坐标污染注册表&#10;    const safeMap = new Map();&#10;    for (const [id, anchor] of anchorsMap.entries()) {&#10;      if (!anchor) continue;&#10;      const sx = Number.isFinite(anchor.x) ? anchor.x : null;&#10;      const sy = Number.isFinite(anchor.y) ? anchor.y : null;&#10;      const ss = anchor.scale == null || Number.isFinite(anchor.scale) ? anchor.scale : null;&#10;      if (sx != null &amp;&amp; sy != null) {&#10;        // 复制一份，避免外部引用被后续修改&#10;        const item = { x: sx, y: sy };&#10;        if (ss != null) item.scale = ss;&#10;        if (anchor.rotation != null &amp;&amp; Number.isFinite(anchor.rotation)) item.rotation = anchor.rotation;&#10;        safeMap.set(id, item);&#10;      }&#10;    }&#10;&#10;    // 如果没有有效锚点，直接返回，不更新现有状态&#10;    if (safeMap.size === 0) return;&#10;&#10;    this._containerAnchors.set(containerKey, safeMap);&#10;&#10;    // 更新注册表中的锚点引用&#10;    for (const [id, anchor] of safeMap.entries()) {&#10;      const entry = this._registry.get(id);&#10;      if (entry) {&#10;        entry.anchor = anchor;&#10;        // 根据当前状态处理锚点更新&#10;        if (entry.state === STATES.TRACKING) {&#10;          // 使用 quickTo 平滑更新目标&#10;          this._applyTrackingQuickTarget(entry, anchor);&#10;        }&#10;        // idle / animating 或 dragging 状态：和anchor无关，不干预&#10;      }&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 计算锚点目标属性（内部助手函数）&#10;   * @private&#10;   */&#10;  _computeAnchorTargetProps(element, anchor) {&#10;    if (!element || !anchor) return null;&#10;    const base = this._getBaseSize(element);&#10;    const csx = parseFloat(gsap.getProperty(element, 'scaleX')) || 1;&#10;    const csy = parseFloat(gsap.getProperty(element, 'scaleY')) || 1;&#10;    const currentScale = Math.max(csx, csy);&#10;    const targetScale = (anchor.scale != null) ? anchor.scale : currentScale;&#10;    return {&#10;      x: anchor.x - (base.width * targetScale) / 2,&#10;      y: anchor.y - (base.height * targetScale) / 2,&#10;      scale: targetScale,&#10;      rotation: anchor.rotation || 0&#10;    };&#10;  }&#10;&#10;  /**&#10;   * 创建锚点跟踪动画（锚点跟踪状态的核心逻辑，被多个方法复用）&#10;   * @private&#10;   * @param {Object} entry - 注册表项&#10;   * @param {Object} anchor - 锚点对象&#10;   * @param {Object} options - 选项&#10;   * @param {number} [options.durationMs] - 跟踪持续时长（毫秒）&#10;   * @param {string} [options.ease] - 缓动函数&#10;   * @param {Function} [options.onComplete] - 完成回调（可选）&#10;   * @param {Function} [options.onInterrupt] - 中断回调（可选）&#10;   * @returns {Object} GSAP tween 对象&#10;   */&#10;  _createTrackingTween(entry, anchor, options = {}) {&#10;    if (!entry || !anchor || !entry.element) return null;&#10;    &#10;    const { element } = entry;&#10;    const targetProps = this._computeAnchorTargetProps(element, anchor);&#10;    if (!targetProps) return null;&#10;    &#10;    // 使用默认配置或自定义参数（统一使用毫秒，to 时转换为秒）&#10;    const durationMs = typeof options.durationMs === 'number' ? options.durationMs : this._anchorTrackingDurationMs;&#10;    const durationSec = Math.max(0.001, (durationMs || DEFAULT_TRACKING_DURATION_MS) / 1000);&#10;    const ease = options.ease || this._anchorTrackingEase;&#10;    &#10;    // 创建跟踪动画&#10;    const tween = gsap.to(element, {&#10;      ...targetProps,&#10;      duration: durationSec,&#10;      ease,&#10;      overwrite: true,&#10;      onComplete: () =&gt; {&#10;        // 默认行为：完成后，清理tween，但仍保持 tracking 状态，如此，在锚点移动时可继续启动动画并继续跟踪&#10;        if (entry.currentTween === tween) {&#10;          entry.currentTween = null;&#10;        }&#10;        // 执行自定义回调&#10;        if (options.onComplete) {&#10;          options.onComplete();&#10;        }&#10;      },&#10;      onInterrupt: () =&gt; {&#10;        if (entry.currentTween === tween) {&#10;          entry.currentTween = null;&#10;        }&#10;        // 执行自定义回调&#10;        if (options.onInterrupt) {&#10;          options.onInterrupt();&#10;        }&#10;      }&#10;    });&#10;    &#10;    return tween;&#10;  }&#10;  &#10;  // 工具：移除并替换指定全局锚点的 resize 监听（防止重复监听）&#10;  _replaceGlobalAnchorResizeListener(name, handler) {&#10;    const prev = this._globalAnchorListeners.get(name);&#10;    if (prev &amp;&amp; typeof window !== 'undefined') {&#10;      try { window.removeEventListener('resize', prev); } catch (_) {}&#10;    }&#10;    if (handler) {&#10;      this._globalAnchorListeners.set(name, handler);&#10;      try { window.addEventListener('resize', handler, { passive: true }); } catch (_) {}&#10;    } else {&#10;      this._globalAnchorListeners.delete(name);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * 应用锚点位置到元素（立即设置，无动画）&#10;   */&#10;  setGlobalAnchorEl(name, element) {&#10;    if (!name) return;&#10;    &#10;    const updatePosition = () =&gt; {&#10;      if(!element) {&#10;        // 移除全局锚点与监听&#10;        this._globalAnchors.delete(name);&#10;        this._replaceGlobalAnchorResizeListener(name, null);&#10;        return;&#10;      }&#10;      const rect = element.getBoundingClientRect();&#10;      if (rect) {&#10;        const anchor = {&#10;          x: rect.left + rect.width / 2,&#10;          y: rect.top + rect.height / 2&#10;        };&#10;        this._globalAnchors.set(name, anchor);&#10;      }&#10;    };&#10;&#10;    updatePosition();&#10;    // 使用替换逻辑避免重复监听&#10;    this._replaceGlobalAnchorResizeListener(name, updatePosition);&#10;  }&#10;&#10;  /**&#10;   * 设置全局锚点（直接坐标）&#10;   */&#10;  setGlobalAnchor(name, position) {&#10;    if (!name || !position) return;&#10;    this._globalAnchors.set(name, { x: position.x, y: position.y });&#10;  }&#10;&#10;  /**&#10;   * 获取锚点坐标&#10;   */&#10;  getAnchorPoint(anchorName) {&#10;    // 如果是对象形式的坐标，直接返回&#10;    if (typeof anchorName === 'object' &amp;&amp; anchorName.x != null &amp;&amp; anchorName.y != null) {&#10;      return { x: anchorName.x, y: anchorName.y };&#10;    }&#10;&#10;    // 从全局锚点获取&#10;    if (typeof anchorName === 'string') {&#10;      const global = this._globalAnchors.get(anchorName);&#10;      if (global) {&#10;        // console.log(`[animator] Using global anchor '${anchorName}':`, global);&#10;        return global;&#10;      }&#10;      console.warn(`[animator] Global anchor '${anchorName}' not found, using screen center`);&#10;    }&#10;&#10;    // 默认返回屏幕中心&#10;    return {&#10;      x: window.innerWidth / 2,&#10;      y: window.innerHeight / 2&#10;    };&#10;  }&#10;&#10;  // ========== 动画执行 ==========&#10;&#10;  /**&#10;   * 应用特效（独立于普通位移动画），保持与历史行为一致：&#10;   * - 停止 tracking 与当前 tween&#10;   * - 进入 animating 状态&#10;   * - 播放特效，duration 后回到 idle，并通知完成&#10;   */&#10;  applyEffect(payload) {&#10;    const { id, effect, duration = 300, instructionId } = payload || {};&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] applyEffect: element not registered', id);&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      return;&#10;    }&#10;&#10;    const { element } = entry;&#10;&#10;    // 统一前置：停止 tracking/动画，进入 animating&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    // 若已有特效，先中断并释放&#10;    this._interruptEffect(entry);&#10;    entry.state = STATES.ANIMATING;&#10;&#10;    // 分发具体效果&#10;    let tween = null;&#10;    switch (effect) {&#10;      case 'shake':&#10;        tween = this._applyShakeEffect(element, payload);&#10;        break;&#10;      default:&#10;        console.warn('[animator] applyEffect: unknown effect', effect);&#10;        break;&#10;    }&#10;&#10;    // 注册可中断的特效状态&#10;    const timerId = setTimeout(() =&gt; {&#10;      // 正常完成路径&#10;      if (entry.state === STATES.ANIMATING) {&#10;        entry.state = STATES.IDLE;&#10;      }&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      delete entry._effect;&#10;    }, duration);&#10;    entry._effect = { timerId, tween, instructionId };&#10;  }&#10;&#10;  /**&#10;   * 切换到animating状态并执行动画指令，在duration后停止动画并回归idle状态。&#10;   */&#10;  animate(payload) {&#10;    const { id, from = {}, to = {}, duration = 300, ease = defaultEase, anchor, instructionId, effect } = payload;&#10;&#10;    // 如果是特效请求，改由 applyEffect 处理&#10;    if (effect) {&#10;      this.applyEffect(payload);&#10;      return;&#10;    }&#10;&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] animate: element not registered', id);&#10;      if (instructionId) {&#10;        frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;      }&#10;      return;&#10;    }&#10;&#10;    const { element, adapter } = entry;&#10;&#10;    // 1. 停止tracking状态的跟踪动画（如果正在进行）&#10;    this._stopTracking(entry);&#10;    // 1.1 若有特效，先中断并释放&#10;    this._interruptEffect(entry);&#10;&#10;    // 2. 杀死当前正在执行的动画（如果有）&#10;    this._killCurrentTween(entry);&#10;&#10;    // 3. 转换到 animating 状态&#10;    entry.state = STATES.ANIMATING;&#10;&#10;    // 前处理&#10;    try { adapter.beforeAnimate(element, payload); } catch (_) {}&#10;&#10;    // 构建起始属性 (from)&#10;    const fromProps = {};&#10;&#10;    // 处理 from.anchor&#10;    if (from.anchor) {&#10;      const anchorPoint = this.getAnchorPoint(from.anchor);&#10;      const rect = element.getBoundingClientRect();&#10;      fromProps.x = anchorPoint.x - rect.width / 2;&#10;      fromProps.y = anchorPoint.y - rect.height / 2;&#10;    }&#10;&#10;    // 合并 from 属性（统一 rotation 命名）&#10;    if (from.x != null) fromProps.x = from.x;&#10;    if (from.y != null) fromProps.y = from.y;&#10;    if (from.scale != null) fromProps.scale = from.scale;&#10;    if (from.rotation != null) fromProps.rotation = from.rotation;&#10;    if (from.rotate != null) fromProps.rotation = from.rotate; // 兼容别名&#10;    if (from.opacity != null) fromProps.autoAlpha = from.opacity;&#10;&#10;    // 如果有 from 属性，先立即设置到起始位置&#10;    if (Object.keys(fromProps).length &gt; 0) {&#10;      gsap.set(element, fromProps);&#10;      // 若元素仍处于隐藏状态且未指定 from.opacity，则在定位后再显现，避免 (0,0) 闪烁&#10;      if (element.style.visibility === 'hidden' &amp;&amp; from.opacity == null) {&#10;        gsap.set(element, { autoAlpha: 1 });&#10;      }&#10;    } else {&#10;      // 无 from 属性：若元素仍为隐藏，则直接显现&#10;      if (element.style.visibility === 'hidden') {&#10;        gsap.set(element, { autoAlpha: 1 });&#10;      }&#10;    }&#10;&#10;    // 构建目标属性 (to)&#10;    const toProps = {};&#10;&#10;    // 处理顶层 anchor（目标锚点）&#10;    if (anchor) {&#10;      const anchorPoint = this.getAnchorPoint(anchor);&#10;      const rect = element.getBoundingClientRect();&#10;      toProps.x = anchorPoint.x - rect.width / 2;&#10;      toProps.y = anchorPoint.y - rect.height / 2;&#10;    }&#10;&#10;    // 合并 to 属性（统一 rotation 命名）&#10;    if (to.x != null) toProps.x = to.x;&#10;    if (to.y != null) toProps.y = to.y;&#10;    if (to.scale != null) toProps.scale = to.scale;&#10;    if (to.rotation != null) toProps.rotation = to.rotation;&#10;    if (to.rotate != null) toProps.rotation = to.rotate; // 兼容别名&#10;    if (to.opacity != null) toProps.autoAlpha = to.opacity;&#10;&#10;    // 4. 创建新的动画 tween&#10;    const tween = gsap.to(element, {&#10;      ...toProps,&#10;      duration: Math.max(0.001, duration / 1000),&#10;      ease,&#10;      force3D: true,&#10;      lazy: false,&#10;      overwrite: true, // 强制覆盖，确保单一通道&#10;      onComplete: () =&gt; {&#10;        try { adapter.afterAnimate(element, payload); } catch (_) {}&#10;&#10;        // 动画完成，回到 idle 状态（不自动恢复跟踪）&#10;        if (entry.state === STATES.ANIMATING) {&#10;          entry.state = STATES.IDLE;&#10;        }&#10;        entry.currentTween = null;&#10;&#10;        // 通知完成&#10;        if (instructionId) {&#10;          frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;        }&#10;      },&#10;      onInterrupt: () =&gt; {&#10;        // 被中断也要清理状态&#10;        entry.currentTween = null;&#10;        if (entry.state === STATES.ANIMATING) {&#10;          entry.state = STATES.IDLE;&#10;        }&#10;        if (instructionId) {&#10;          frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;        }&#10;      }&#10;    });&#10;&#10;    // 保存当前 tween&#10;    entry.currentTween = tween;&#10;  }&#10;&#10;  /**&#10;   * 动画到锚点（快捷方法）&#10;   */&#10;  animateToAnchor(id, anchorName, options = {}) {&#10;    this.animate({&#10;      id,&#10;      anchor: anchorName,&#10;      to: {},&#10;      duration: options.duration || 300,&#10;      ease: options.ease || defaultEase,&#10;      instructionId: options.instructionId&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 应用震动效果&#10;   */&#10;  _applyShakeEffect(element, payload) {&#10;    const { intensity = 2, duration = 300 } = payload;&#10;    // 每次抖动的单程时长 50ms，往返一次 100ms&#10;    const cycleMs = 100;&#10;    const repeats = Math.max(0, Math.floor(duration / cycleMs) * 2); // 偶数次半程，保证回到原位&#10;&#10;    return gsap.to(element, {&#10;      x: `+=${intensity}`,&#10;      duration: 0.05,&#10;      repeat: repeats,&#10;      yoyo: true,&#10;      ease: 'power1.inOut'&#10;      // 去掉 onComplete 的强制 x=0，避免覆盖原始位置&#10;    });&#10;  }&#10;&#10;  /**&#10;   * 停止跟踪动画（内部使用）&#10;   */&#10;  _stopTracking(entry) {&#10;    if (!entry) return;&#10;    if (entry.state === STATES.TRACKING &amp;&amp; entry.currentTween) {&#10;      entry.currentTween.kill();&#10;      entry.currentTween = null;&#10;    }&#10;    // 结束 quickTo 产生的补间，避免影响下一次动画&#10;    try { gsap.killTweensOf(entry.element, 'x,y,scaleX,scaleY,rotation'); } catch (_) {}&#10;    entry._quick = null;&#10;    entry._quickCfgKey = null;&#10;  }&#10;&#10;  // ========== 拖拽状态管理 ==========&#10;&#10;  /**&#10;   * 统一入口：进入拖拽状态（推荐使用）&#10;   */&#10;  enterDragging(id) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;&#10;    // 停止跟踪动画（tracking状态）&#10;    this._stopTracking(entry);&#10;    // 中断特效&#10;    this._interruptEffect(entry);&#10;&#10;    // 杀死当前正在执行的动画（animating状态）&#10;    this._killCurrentTween(entry);&#10;&#10;    // 转换到 dragging 状态&#10;    entry.state = STATES.DRAGGING;&#10;    entry.isDragging = true;&#10;  }&#10;&#10;  // ========== 锚点跟踪 ==========&#10;  /**&#10;   * 进入锚点跟踪（从任意状态切换到 tracking 状态）&#10;   * 每种状态仅保留一个入口方法：enterTracking&#10;   * @param {string|number} id - 元素 ID&#10;   * @param {Object} options - 选项&#10;   * @param {number} [options.duration] - 跟踪平滑持续时长（毫秒），默认使用全局配置&#10;   * @param {string} [options.ease] - 缓动函数&#10;   * @param {string} [options.instructionId] - 指令 ID（用于通知完成）&#10;   */&#10;  enterTracking(id, options = {}) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] enterTracking: element not registered', id);&#10;      // 不再释放 animation-instruction-finished（这是状态切换指令）&#10;      return;&#10;    }&#10;&#10;    if (!entry.anchor) {&#10;      console.warn('[animator] enterTracking: element has no anchor', id);&#10;      // 不再释放 animation-instruction-finished（这是状态切换指令）&#10;      return;&#10;    }&#10;&#10;    // 停止当前动画（如果有）&#10;    this._stopTracking(entry);&#10;    this._killCurrentTween(entry);&#10;    // 中断特效&#10;    this._interruptEffect(entry);&#10;&#10;    // 转换到 tracking 状态&#10;    entry.state = STATES.TRACKING;&#10;&#10;    // 初始化 quickTo 并应用当前 anchor 目标&#10;    this._ensureQuickSetters(entry, { durationMs: options.duration, ease: options.ease });&#10;    this._applyTrackingQuickTarget(entry, entry.anchor, { durationMs: options.duration, ease: options.ease });&#10;&#10;    // tracking 模式下不再使用 currentTween&#10;    entry.currentTween = null;&#10;&#10;    // 不释放 animation-instruction-finished（这是状态切换指令）&#10;  }&#10;&#10;  /**&#10;   * 设置全局锚点跟踪配置（毫秒）&#10;   */&#10;  setAnchorTrackingConfig({ duration, ease } = {}) {&#10;    if (duration != null) this._anchorTrackingDurationMs = duration;&#10;    if (ease != null) this._anchorTrackingEase = ease;&#10;  }&#10;&#10;  /**&#10;   * 主动进入 idle（提供统一的状态入口）&#10;   */&#10;  enterIdle(id) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) return;&#10;    // 终止一切动画与拖拽&#10;    this._killCurrentTween(entry);&#10;    this._stopTracking(entry);&#10;    this._interruptEffect(entry);&#10;    entry.isDragging = false;&#10;    entry.state = STATES.IDLE;&#10;  }&#10;&#10;  /**&#10;   * 重置所有动画，清空registry&#10;   */&#10;  reset() {&#10;    for (const [, entry] of this._registry.entries()) {&#10;      this._killCurrentTween(entry);&#10;      this._interruptEffect(entry);&#10;    }&#10;    this._registry.clear();&#10;    this._containerAnchors.clear();&#10;&#10;    // 清理全局锚点监听&#10;    if (typeof window !== 'undefined') {&#10;      for (const [name, handler] of this._globalAnchorListeners.entries()) {&#10;        try { window.removeEventListener('resize', handler); } catch (_) {}&#10;      }&#10;    }&#10;    this._globalAnchorListeners.clear();&#10;  }&#10;&#10;  /**&#10;   * 调试工具：获取当前状态&#10;   */&#10;  getStatus() {&#10;    const entries = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      entries.push({&#10;        id,&#10;        adapterType: entry.adapterType,&#10;        state: entry.state,&#10;        hasAnchor: !!entry.anchor,&#10;        isDragging: entry.isDragging,&#10;        hasTween: !!entry.currentTween&#10;      });&#10;    }&#10;    return {&#10;      registered: this._registry.size,&#10;      containers: this._containerAnchors.size,&#10;      globalAnchors: Array.from(this._globalAnchors.keys()),&#10;      entries&#10;    };&#10;  }&#10;&#10;  /**&#10;   * 调试工具：打印状态&#10;   */&#10;  debug() {&#10;    const status = this.getStatus();&#10;    console.log('[animator] Status:', status);&#10;    console.table(status.entries);&#10;  }&#10;&#10;  /**&#10;   * 注册一个新的适配器类型（可扩展）&#10;   * @param {string} type - 适配器类型名&#10;   * @param {Object} adapter - 适配器实例，需实现 beforeAnimate/afterAnimate 等可选接口&#10;   */&#10;  registerAdapter(type, adapter) {&#10;    if (!type || !adapter) return;&#10;    adapters[type] = adapter;&#10;  }&#10;&#10;  /**&#10;   * 直接设置某个元素的锚点（绕过容器批量更新），便于个别元素临时锚点调整&#10;   * 若元素当前处于 tracking，则立即更新其跟踪目标&#10;   * @param {string|number} id&#10;   * @param {{x:number,y:number,scale?:number,rotation?:number}} anchor&#10;   */&#10;  setElementAnchor(id, anchor) {&#10;    const entry = this._registry.get(id);&#10;    if (!entry) {&#10;      console.warn('[animator] setElementAnchor: element not registered', id);&#10;      return;&#10;    }&#10;    entry.anchor = anchor || null;&#10;    if (entry.anchor &amp;&amp; entry.state === STATES.TRACKING) {&#10;      // 使用 quickTo 平滑更新目标&#10;      this._applyTrackingQuickTarget(entry, entry.anchor);&#10;    }&#10;  }&#10;&#10;  // 结束当前正在进行的特效（若有），并通知完成（作为中断）&#10;  _interruptEffect(entry) {&#10;    if (!entry || !entry._effect) return;&#10;    const { timerId, tween, instructionId } = entry._effect || {};&#10;    try { if (timerId) clearTimeout(timerId); } catch (_) {}&#10;    try { if (tween) tween.kill(); } catch (_) {}&#10;    if (instructionId) {&#10;      frontendEventBus.emit('animation-instruction-finished', { id: instructionId });&#10;    }&#10;    delete entry._effect;&#10;  }&#10;&#10;  /**&#10;   * 获取指定适配器类型已注册元素的快照列表&#10;   * @param {string} adapterType 例如 'card' | 'unit-panel'&#10;   * @returns {Array&lt;{ id: string, element: HTMLElement, adapterType: string }&gt;}&#10;   */&#10;  getRegisteredByAdapter(adapterType) {&#10;    const list = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      if (!entry?.element) continue;&#10;      if (!adapterType || entry.adapterType === adapterType) {&#10;        list.push({ id, element: entry.element, adapterType: entry.adapterType });&#10;      }&#10;    }&#10;    return list;&#10;  }&#10;&#10;  /**&#10;   * 获取指定适配器类型的元素几何快照（用于 Pixi overlay 精确对齐）&#10;   * 返回: [{ id, cx, cy, baseW, baseH, rot, sx, sy, opacity }]&#10;   */&#10;  getTransformsSnapshotByAdapter(adapterType) {&#10;    const list = [];&#10;    for (const [id, entry] of this._registry.entries()) {&#10;      if (!entry?.element) continue;&#10;      if (adapterType &amp;&amp; entry.adapterType !== adapterType) continue;&#10;      const el = entry.element;&#10;      const rect = el.getBoundingClientRect();&#10;      if (!rect || rect.width &lt;= 0 || rect.height &lt;= 0) continue;&#10;      // 读取 CSS 变换矩阵&#10;      const cs = getComputedStyle(el);&#10;      const t = cs.transform;&#10;      let rot = 0, sx = 1, sy = 1;&#10;      if (t &amp;&amp; t !== 'none') {&#10;        const m = new DOMMatrix(t);&#10;        rot = Math.atan2(m.m12, m.m11);&#10;        sx = Math.hypot(m.m11, m.m12);&#10;        sy = Math.hypot(m.m21, m.m22);&#10;      }&#10;      let baseW = el.offsetWidth || 0;&#10;      let baseH = el.offsetHeight || 0;&#10;      if (!baseW || !baseH) {&#10;        baseW = rect.width / (sx || 1);&#10;        baseH = rect.height / (sy || 1);&#10;      }&#10;      const cx = rect.left + rect.width / 2;&#10;      const cy = rect.top + rect.height / 2;&#10;      const opacity = parseFloat(cs.opacity) || 1;&#10;      const visible = (cs.visibility !== 'hidden') &amp;&amp; (cs.display !== 'none');&#10;      list.push({ id, cx, cy, baseW, baseH, rot, sx, sy, opacity, visible });&#10;    }&#10;    return list;&#10;  }&#10;}&#10;&#10;// 导出单例&#10;const animator = new Animator();&#10;&#10;// 添加到 window 以便调试&#10;if (typeof window !== 'undefined') {&#10;  window.__animator = animator;&#10;  window.__debugAnimator = () =&gt; animator.debug();&#10;}&#10;&#10;export default animator;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>