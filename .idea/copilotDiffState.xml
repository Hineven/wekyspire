<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/assets/common.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/common.css" />
              <option name="originalContent" value="/* 公共按钮样式 */&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;}&#10;&#10;button:disabled {&#10;  opacity: 0.5;&#10;  cursor: not-allowed;&#10;}" />
              <option name="updatedContent" value="/* Global box model reset: make widths include padding and borders */&#13;&#10;*, *::before, *::after {&#13;&#10;  box-sizing: border-box;&#13;&#10;}&#13;&#10;&#13;&#10;/* 公共按钮样式 */&#13;&#10;button {&#13;&#10;  padding: 10px 15px;&#13;&#10;  margin: 5px;&#13;&#10;  cursor: pointer;&#13;&#10;}&#13;&#10;&#13;&#10;button:disabled {&#13;&#10;  opacity: 0.5;&#13;&#10;  cursor: not-allowed;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/assets/zLayers.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/assets/zLayers.css" />
              <option name="updatedContent" value="/* Centralized z-index map (higher = on top)&#10;   Order (top → bottom): Dialog &gt; Cutscene &gt; BossShowup &gt; Particles &gt; Regular content&#10;   Regular overlays (slot/ability overlays) are below particles.&#10;   AnimationOverlay (card ghosts) is above regular overlays but below particles.&#10;*/&#10;:root {&#10;  /* Regular content baseline */&#10;  --z-base: 0;&#10;&#10;  /* Regular overlays (selection panels, dim overlays) */&#10;  --z-overlay: 1200;&#10;  --z-overlay-content: 1210; /* overlay inner content if needed */&#10;&#10;  /* Tooltips in regular UI (above base/overlay, below particles) */&#10;  --z-tooltip: 1300;&#10;&#10;  /* Card animation overlay (ghosts) */&#10;  --z-animation: 1500;&#10;&#10;  /* Effects */&#10;  --z-particles: 2000;&#10;&#10;  /* Cinematic layers */&#10;  --z-boss: 2500;&#10;  --z-cutscene: 3000;&#10;  --z-dialog: 3500;&#10;  --z-message: 3600; /* ephemeral popup messages above dialog */&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/AbilityRewardPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/AbilityRewardPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;ability-reward-panel-wrapper&quot;&gt;&#10;    &lt;div class=&quot;ability-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#10;      &lt;!-- 选中效果覆盖层 --&gt;&#10;      &lt;transition name=&quot;selection-overlay-fade&quot;&gt;&#10;        &lt;div class=&quot;selection-overlay&quot; v-if=&quot;showSelectionEffect&quot; key=&quot;overlay&quot;&gt;&lt;/div&gt;&#10;      &lt;/transition&gt;&#10;      &#10;      &lt;h2&gt;选择一项能力！&lt;/h2&gt;&#10;      &lt;div class=&quot;ability-cards&quot;&gt;&#10;        &lt;div &#10;          v-for=&quot;ability in abilities&quot;&#10;          :key=&quot;ability.uniqueID&quot;&#10;          :class=&quot;[&#10;            'ability-card', &#10;            'tier-' + ability.tier,&#10;            { 'selected-glow': selectedAbility === ability &amp;&amp; showSelectionEffect }&#10;          ]&quot;&#10;          @click=&quot;selectAbility(ability)&quot;&#10;        &gt;&#10;          &lt;div class=&quot;ability-tier&quot;&gt;{{ getAbilityTierLabel(ability.tier) }}&lt;/div&gt;&#10;          &lt;div class=&quot;ability-name&quot;&gt;{{ ability.name }}&lt;/div&gt;&#10;          &lt;div class=&quot;ability-description&quot;&gt;&#10;            &lt;ColoredText :text=&quot;ability.description&quot; /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition-group&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import { getAbilityTierLabel } from '../utils/tierUtils.js';&#10;&#10;export default {&#10;  name: 'AbilityRewardPanel',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    abilities: {&#10;      type: Array,&#10;      default: () =&gt; []&#10;    },&#10;    isVisible: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      selectedAbility: null,&#10;      showSelectionEffect: false&#10;    };&#10;  },&#10;  methods: {&#10;    getAbilityTierLabel,&#10;    selectAbility(ability) {&#10;      // 设置选中的能力&#10;      this.selectedAbility = ability;&#10;      this.showSelectionEffect = true;&#10;      &#10;      // 等待动画完成后发出事件&#10;      setTimeout(() =&gt; {&#10;        this.$emit('selected-ability-reward', ability);&#10;      }, 2000); // 动画持续时间&#10;    },&#10;    closePanel() {&#10;      this.$emit('close');&#10;    },&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.ability-reward-panel {&#10;  border: 1px solid #9c27b0; /* 紫色边框 */&#10;  padding: 20px;&#10;  background: linear-gradient(135deg, #f3e5f5, #e1bee7); /* 紫色渐变背景 */&#10;  max-width: 80%;&#10;  margin: 20px auto;&#10;  box-shadow: 0 4px 8px rgba(156, 39, 176, 0.3);&#10;  border-radius: 8px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.ability-reward-panel h2 {&#10;  text-align: center;&#10;  margin-bottom: 20px;&#10;  color: #7b1fa2; /* 深紫色文字 */&#10;}&#10;&#10;.ability-cards {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 20px;&#10;  margin: 20px 0;&#10;  justify-content: center;&#10;}&#10;&#10;.ability-card {&#10;  border: 1px solid #eee;&#10;  padding: 15px;&#10;  width: 200px;&#10;  cursor: pointer;&#10;  background-color: white;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  transition: transform 0.2s;&#10;  position: relative;&#10;}&#10;&#10;.ability-card:hover {&#10;  transform: translateY(-5px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.ability-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;/* 不同等阶的能力卡片样式 */&#10;.ability-card.tier-1 {&#10;  background-color: #e8f5e9; /* 绿色 */&#10;  border: 1px solid #4caf50;&#10;}&#10;&#10;.ability-card.tier-2 {&#10;  background-color: #e3f2fd; /* 蓝色 */&#10;  border: 1px solid #2196f3;&#10;}&#10;&#10;.ability-card.tier-3 {&#10;  background-color: #f3e5f5; /* 紫色 */&#10;  border: 1px solid #9c27b0;&#10;}&#10;&#10;.ability-card.tier-4 {&#10;  background-color: #fff3e0; /* 黄色 */&#10;  border: 1px solid #ff9800;&#10;}&#10;&#10;.ability-card.tier-5 {&#10;  background-color: #ffebee; /* 红色 */&#10;  border: 1px solid #f44336;&#10;}&#10;&#10;.ability-name {&#10;  font-weight: bold;&#10;  font-size: 1.2em;&#10;  margin-bottom: 10px;&#10;  color: #333;&#10;}&#10;&#10;.ability-description {&#10;  color: #666;&#10;}&#10;&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;  background-color: #9c27b0; /* 紫色按钮 */&#10;  color: white;&#10;  border: none;&#10;  border-radius: 4px;&#10;}&#10;&#10;button:hover {&#10;  background-color: #7b1fa2; /* 深紫色 */&#10;}&#10;&#10;/* 选中效果覆盖层 */&#10;.selection-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  z-index: 901; /* 高于主覆盖层 */&#10;}&#10;&#10;/* 选中效果覆盖层淡入淡出动画 */&#10;.selection-overlay-fade-enter-active, .selection-overlay-fade-leave-active {&#10;  transition: opacity 1.5s;&#10;}&#10;&#10;.selection-overlay-fade-enter-from, .selection-overlay-fade-leave-to {&#10;  opacity: 0;&#10;}&#10;&#10;.selection-overlay-fade-enter-to, .selection-overlay-fade-leave-from {&#10;  opacity: 1;&#10;}&#10;&#10;/* 选中能力卡发光效果 */&#10;.selected-glow {&#10;  position: relative;&#10;  z-index: 902; /* 高于选中效果覆盖层 */&#10;}&#10;&#10;.selected-glow.tier-1 {&#10;  box-shadow: 0 0 20px 10px #4caf50;&#10;}&#10;&#10;.selected-glow.tier-2 {&#10;  box-shadow: 0 0 20px 10px #2196f3;&#10;}&#10;&#10;.selected-glow.tier-3 {&#10;  box-shadow: 0 0 20px 10px #9c27b0;&#10;}&#10;&#10;.selected-glow.tier-4 {&#10;  box-shadow: 0 0 20px 10px #ff9800;&#10;}&#10;&#10;.selected-glow.tier-5 {&#10;  box-shadow: 0 0 20px 10px #f44336;&#10;}&#10;&#10;/* 滑动进入和退出动画 */&#10;.slide-enter-active, .slide-leave-active {&#10;  transition: all 0.5s ease;&#10;}&#10;&#10;.slide-enter-from {&#10;  transform: translateY(100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-leave-to {&#10;  transform: translateY(-100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-enter-to, .slide-leave-from {&#10;  transform: translateY(0);&#10;  opacity: 1;&#10;}&#10;&#10;/* 为transition-group添加样式 */&#10;.ability-reward-panel-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;ability-reward-panel-wrapper&quot;&gt;&#10;    &lt;div class=&quot;ability-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#10;      &lt;!-- 选中效果覆盖层 --&gt;&#10;      &lt;transition name=&quot;selection-overlay-fade&quot;&gt;&#10;        &lt;div class=&quot;selection-overlay&quot; v-if=&quot;showSelectionEffect&quot; key=&quot;overlay&quot;&gt;&lt;/div&gt;&#10;      &lt;/transition&gt;&#10;      &#10;      &lt;h2&gt;选择一项能力！&lt;/h2&gt;&#10;      &lt;div class=&quot;ability-cards&quot;&gt;&#10;        &lt;div &#10;          v-for=&quot;ability in abilities&quot;&#10;          :key=&quot;ability.uniqueID&quot;&#10;          :class=&quot;[&#10;            'ability-card', &#10;            'tier-' + ability.tier,&#10;            { 'selected-glow': selectedAbility === ability &amp;&amp; showSelectionEffect }&#10;          ]&quot;&#10;          @click=&quot;selectAbility(ability)&quot;&#10;        &gt;&#10;          &lt;div class=&quot;ability-tier&quot;&gt;{{ getAbilityTierLabel(ability.tier) }}&lt;/div&gt;&#10;          &lt;div class=&quot;ability-name&quot;&gt;{{ ability.name }}&lt;/div&gt;&#10;          &lt;div class=&quot;ability-description&quot;&gt;&#10;            &lt;ColoredText :text=&quot;ability.description&quot; /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition-group&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import { getAbilityTierLabel } from '../utils/tierUtils.js';&#10;&#10;export default {&#10;  name: 'AbilityRewardPanel',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    abilities: {&#10;      type: Array,&#10;      default: () =&gt; []&#10;    },&#10;    isVisible: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      selectedAbility: null,&#10;      showSelectionEffect: false&#10;    };&#10;  },&#10;  methods: {&#10;    getAbilityTierLabel,&#10;    selectAbility(ability) {&#10;      // 设置选中的能力&#10;      this.selectedAbility = ability;&#10;      this.showSelectionEffect = true;&#10;      &#10;      // 等待动画完成后发出事件&#10;      setTimeout(() =&gt; {&#10;        this.$emit('selected-ability-reward', ability);&#10;      }, 2000); // 动画持续时间&#10;    },&#10;    closePanel() {&#10;      this.$emit('close');&#10;    },&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.ability-reward-panel {&#10;  border: 1px solid #9c27b0; /* 紫色边框 */&#10;  padding: 20px;&#10;  background: linear-gradient(135deg, #f3e5f5, #e1bee7); /* 紫色渐变背景 */&#10;  max-width: 80%;&#10;  margin: 20px auto;&#10;  box-shadow: 0 4px 8px rgba(156, 39, 176, 0.3);&#10;  border-radius: 8px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.ability-reward-panel h2 {&#10;  text-align: center;&#10;  margin-bottom: 20px;&#10;  color: #7b1fa2; /* 深紫色文字 */&#10;}&#10;&#10;.ability-cards {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 20px;&#10;  margin: 20px 0;&#10;  justify-content: center;&#10;}&#10;&#10;.ability-card {&#10;  border: 1px solid #eee;&#10;  padding: 15px;&#10;  width: 200px;&#10;  cursor: pointer;&#10;  background-color: white;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  transition: transform 0.2s;&#10;  position: relative;&#10;}&#10;&#10;.ability-card:hover {&#10;  transform: translateY(-5px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.ability-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;/* 不同等阶的能力卡片样式 */&#10;.ability-card.tier-1 {&#10;  background-color: #e8f5e9; /* 绿色 */&#10;  border: 1px solid #4caf50;&#10;}&#10;&#10;.ability-card.tier-2 {&#10;  background-color: #e3f2fd; /* 蓝色 */&#10;  border: 1px solid #2196f3;&#10;}&#10;&#10;.ability-card.tier-3 {&#10;  background-color: #f3e5f5; /* 紫色 */&#10;  border: 1px solid #9c27b0;&#10;}&#10;&#10;.ability-card.tier-4 {&#10;  background-color: #fff3e0; /* 黄色 */&#10;  border: 1px solid #ff9800;&#10;}&#10;&#10;.ability-card.tier-5 {&#10;  background-color: #ffebee; /* 红色 */&#10;  border: 1px solid #f44336;&#10;}&#10;&#10;.ability-name {&#10;  font-weight: bold;&#10;  font-size: 1.2em;&#10;  margin-bottom: 10px;&#10;  color: #333;&#10;}&#10;&#10;.ability-description {&#10;  color: #666;&#10;}&#10;&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;  background-color: #9c27b0; /* 紫色按钮 */&#10;  color: white;&#10;  border: none;&#10;  border-radius: 4px;&#10;}&#10;&#10;button:hover {&#10;  background-color: #7b1fa2; /* 深紫色 */&#10;}&#10;&#10;/* 选中效果覆盖层 */&#10;.selection-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  z-index: 901; /* 高于主覆盖层 */&#10;}&#10;&#10;/* 选中效果覆盖层淡入淡出动画 */&#10;.selection-overlay-fade-enter-active, .selection-overlay-fade-leave-active {&#10;  transition: opacity 1.5s;&#10;}&#10;&#10;.selection-overlay-fade-enter-from, .selection-overlay-fade-leave-to {&#10;  opacity: 0;&#10;}&#10;&#10;.selection-overlay-fade-enter-to, .selection-overlay-fade-leave-from {&#10;  opacity: 1;&#10;}&#10;&#10;/* 选中能力卡发光效果 */&#10;.selected-glow {&#10;  position: relative;&#10;  z-index: 902; /* 高于选中效果覆盖层 */&#10;}&#10;&#10;.selected-glow.tier-1 {&#10;  box-shadow: 0 0 20px 10px #4caf50;&#10;}&#10;&#10;.selected-glow.tier-2 {&#10;  box-shadow: 0 0 20px 10px #2196f3;&#10;}&#10;&#10;.selected-glow.tier-3 {&#10;  box-shadow: 0 0 20px 10px #9c27b0;&#10;}&#10;&#10;.selected-glow.tier-4 {&#10;  box-shadow: 0 0 20px 10px #ff9800;&#10;}&#10;&#10;.selected-glow.tier-5 {&#10;  box-shadow: 0 0 20px 10px #f44336;&#10;}&#10;&#10;/* 滑动进入和退出动画 */&#10;.slide-enter-active, .slide-leave-active {&#10;  transition: all 0.5s ease;&#10;}&#10;&#10;.slide-enter-from {&#10;  transform: translateY(100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-leave-to {&#10;  transform: translateY(-100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-enter-to, .slide-leave-from {&#10;  transform: translateY(0);&#10;  opacity: 1;&#10;}&#10;&#10;/* 为transition-group添加样式 */&#10;.ability-reward-panel-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/ActionPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/ActionPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;action-panel&quot; :class=&quot;{ 'disabled': !isPlayerTurn || isControlDisabled }&quot;&gt;&#10;    &lt;div class=&quot;skills&quot;&gt;&#10;      &lt;SkillCard&#10;        v-for=&quot;skill in visibleSkills&quot;&#10;        :key=&quot;skill.uniqueID&quot;&#10;        :skill=&quot;skill&quot;&#10;        :player=&quot;player&quot;&#10;        :disabled=&quot;!canUseSkill(skill) || !isPlayerTurn || isControlDisabled&quot;&#10;        :player-mana=&quot;player.mana&quot;&#10;        :suppress-activation-animation-on-click=&quot;true&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;    &lt;button @click=&quot;onDropSkillButtonClicked&quot; :disabled=&quot;!canDropSkill&quot;&gt;⚡1 丢弃头部技能&lt;/button&gt;&#10;    &lt;button @click=&quot;onEndTurnButtonClicked&quot; :disabled=&quot;!isPlayerTurn || isControlDisabled&quot;&gt;结束回合&lt;/button&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import SkillCard from './SkillCard.vue';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import backendEventBus, { EventNames } from '../backendEventBus';&#10;import { enqueueUI } from '../data/animationDispatcher.js';&#10;&#10;export default {&#10;  name: 'ActionPanel',&#10;  components: { SkillCard },&#10;  props: {&#10;    player: { type: Object, required: true },&#10;    isControlDisabled: { type: Boolean, default: false },&#10;    isPlayerTurn: { type: Boolean, default: true }&#10;  },&#10;  computed: {&#10;    canDropSkill() {&#10;      return (this.isPlayerTurn &amp;&amp; !this.isControlDisabled &amp;&amp; this.player.remainingActionPoints &gt; 0);&#10;    },&#10;    visibleSkills() {&#10;      return (this.player?.frontierSkills || []).filter(Boolean);&#10;    }&#10;  },&#10;  methods: {&#10;        const startEl = event?.currentTarget || (event?.target &amp;&amp; event.target.closest &amp;&amp; event.target.closest('.skill-card')) || null;&#10;        const manaCost = skill.manaCost;&#10;        const actionPointCost = skill.actionPointCost;&#10;        const mouseX = event.clientX;&#10;        const mouseY = event.clientY;&#10;&#10;        if (startEl) {&#10;          // 通过动画调度队列编排播放卡牌动画&#10;          enqueueUI('animateCardPlay', { el: startEl });&#10;        }&#10;        // 触发后端逻辑&#10;        setTimeout(() =&gt; backendEventBus.emit(EventNames.Player.USE_SKILL, skill.uniqueID), 0);&#10;&#10;        this.generateParticleEffects(manaCost, actionPointCost, mouseX, mouseY);&#10;      }&#10;    },&#10;    onEndTurnButtonClicked() {&#10;      backendEventBus.emit(EventNames.Player.END_TURN);&#10;    },&#10;    onDropSkillButtonClicked() {&#10;      backendEventBus.emit(EventNames.Player.DROP_SKILL);&#10;    },&#10;    generateParticleEffects(manaCost, actionPointCost, mouseX, mouseY) {&#10;      const particles = [];&#10;      if (manaCost &gt; 0) {&#10;        for (let i = 0; i &lt; 2 + manaCost * 8; i++) {&#10;          particles.push({&#10;            x: mouseX, y: mouseY,&#10;            vx: (Math.random() - 0.5) * 100,&#10;            vy: (Math.random() - 0.5) * 100 - 50,&#10;            color: '#2196f3', life: 2000, gravity: 400, size: 3 + Math.random() * 2&#10;          });&#10;        }&#10;      }&#10;      if (actionPointCost &gt; 0) {&#10;        for (let i = 0; i &lt; 2 + actionPointCost * 8; i++) {&#10;          particles.push({&#10;            x: mouseX, y: mouseY,&#10;            vx: (Math.random() - 0.5) * 100,&#10;            vy: (Math.random() - 0.5) * 100 - 50,&#10;            color: '#FFD700', life: 2000, gravity: 400, size: 3 + Math.random() * 2&#10;          });&#10;        }&#10;      }&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;/* 操作面板 */&#10;.action-panel {&#10;  position: absolute;&#10;  bottom: 0;&#10;  width: 100%;&#10;  padding: 15px;&#10;}&#10;&#10;.action-panel.disabled {&#10;  filter: brightness(50%);&#10;  pointer-events: none;&#10;}&#10;&#10;.skills {&#10;  display: grid;&#10;  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));&#10;  gap: 15px;&#10;  margin-bottom: 15px;&#10;  position: relative;&#10;}&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;action-panel&quot; :class=&quot;{ 'disabled': !isPlayerTurn || isControlDisabled }&quot;&gt;&#10;    &lt;div class=&quot;skills&quot;&gt;&#10;      &lt;SkillCard&#10;        v-for=&quot;skill in visibleSkills&quot;&#10;        :key=&quot;skill.uniqueID&quot;&#10;        :skill=&quot;skill&quot;&#10;        :player=&quot;player&quot;&#10;        :disabled=&quot;!canUseSkill(skill) || !isPlayerTurn || isControlDisabled&quot;&#10;        :player-mana=&quot;player.mana&quot;&#10;        :suppress-activation-animation-on-click=&quot;true&quot;&#10;        :style=&quot;appearing[skill.uniqueID] ? { visibility: 'hidden' } : null&quot;&#10;        :ref=&quot;el =&gt; setCardRef(el, skill.uniqueID)&quot;&#10;        @skill-card-clicked=&quot;onSkillCardClicked&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;    &lt;button @click=&quot;onDropSkillButtonClicked&quot; :disabled=&quot;!canDropSkill&quot;&gt;⚡1 丢弃头部技能&lt;/button&gt;&#10;    &lt;button @click=&quot;onEndTurnButtonClicked&quot; :disabled=&quot;!isPlayerTurn || isControlDisabled&quot;&gt;结束回合&lt;/button&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import SkillCard from './SkillCard.vue';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import backendEventBus, { EventNames } from '../backendEventBus';&#10;import { enqueueUI } from '../data/animationDispatcher.js';&#10;&#10;export default {&#10;  name: 'ActionPanel',&#10;  components: { SkillCard },&#10;  props: {&#10;    player: { type: Object, required: true },&#10;    isControlDisabled: { type: Boolean, default: false },&#10;    isPlayerTurn: { type: Boolean, default: true }&#10;  },&#10;  data() {&#10;    return {&#10;      cardRefs: {},&#10;      prevIds: [],&#10;      appearing: {}&#10;    };&#10;  },&#10;  computed: {&#10;    canDropSkill() {&#10;      return (this.isPlayerTurn &amp;&amp; !this.isControlDisabled &amp;&amp; this.player.remainingActionPoints &gt; 0);&#10;    },&#10;    visibleSkills() {&#10;      return (this.player?.frontierSkills || []).filter(Boolean);&#10;    },&#10;    visibleIds() {&#10;      return this.visibleSkills.map(s =&gt; s.uniqueID);&#10;    }&#10;  },&#10;  mounted() {&#10;    frontendEventBus.on('card-appear-finished', this.onCardAppearFinished);&#10;  },&#10;  beforeUnmount() {&#10;    frontendEventBus.off('card-appear-finished', this.onCardAppearFinished);&#10;  },&#10;  watch: {&#10;    visibleIds: {&#10;      immediate: true,&#10;      handler(newIds, oldIds) {&#10;        if (!oldIds || oldIds.length === 0) {&#10;          this.prevIds = [...newIds];&#10;          return;&#10;        }&#10;        const prevSet = new Set(this.prevIds);&#10;        const added = newIds.filter(id =&gt; !prevSet.has(id));&#10;        this.prevIds = [...newIds];&#10;        if (added.length === 0) return;&#10;        // 先标记为出现中，避免闪现&#10;        added.forEach(id =&gt; { this.appearing[id] = true; });&#10;        // 等待DOM挂载完成，再播放“从牌库出现”动画&#10;        this.$nextTick(() =&gt; {&#10;          added.forEach(id =&gt; this.animateAppearFromDeck(id));&#10;        });&#10;      }&#10;    }&#10;  },&#10;  methods: {&#10;    onCardAppearFinished(payload = {}) {&#10;      const id = payload?.id;&#10;      if (id != null &amp;&amp; this.appearing[id]) {&#10;        // 小延时确保渲染稳定&#10;        setTimeout(() =&gt; { delete this.appearing[id]; }, 0);&#10;      }&#10;    },&#10;    setCardRef(el, id) {&#10;      if (el) {&#10;        this.cardRefs[id] = el;&#10;      } else {&#10;        delete this.cardRefs[id];&#10;      }&#10;    },&#10;    animateAppearFromDeck(id, retry = 0) {&#10;      const comp = this.cardRefs[id];&#10;      const el = comp &amp;&amp; comp.$el ? comp.$el : null;&#10;      if (!el) {&#10;        if (retry &lt; 3) {&#10;          setTimeout(() =&gt; this.animateAppearFromDeck(id, retry + 1), 16);&#10;        } else {&#10;          // 兜底：避免永远隐藏&#10;          delete this.appearing[id];&#10;        }&#10;        return;&#10;      }&#10;      enqueueUI(&#10;        'animateCardPlay',&#10;        { el, kind: 'appearFromDeck', options: { id, durationMs: 450, startScale: 0.6, fade: true } },&#10;        { duration: 0 }&#10;      );&#10;      // 保险兜底：如果事件未按时回来，自动解除隐藏&#10;      setTimeout(() =&gt; { if (this.appearing[id]) delete this.appearing[id]; }, 1200);&#10;    },&#10;    canUseSkill(skill) {&#10;      return skill &amp;&amp; typeof skill.canUse === 'function' &amp;&amp; skill.canUse(this.player) &amp;&amp; skill.usesLeft !== 0;&#10;    },&#10;    onSkillCardClicked(skill, event) {&#10;      if (this.canUseSkill(skill)) {&#10;        const startEl = event?.currentTarget || (event?.target &amp;&amp; event.target.closest &amp;&amp; event.target.closest('.skill-card')) || null;&#10;        const manaCost = skill.manaCost;&#10;        const actionPointCost = skill.actionPointCost;&#10;        const mouseX = event.clientX;&#10;        const mouseY = event.clientY;&#10;        const skillIndex = this.player.frontierSkills.indexOf(skill);&#10;&#10;        if (startEl) {&#10;          enqueueUI('animateCardPlay', { el: startEl });&#10;        }&#10;        // 触发后端逻辑&#10;        setTimeout(() =&gt; backendEventBus.emit(EventNames.Player.USE_SKILL, skill.uniqueID), 0);&#10;&#10;        this.generateParticleEffects(manaCost, actionPointCost, mouseX, mouseY);&#10;      }&#10;    },&#10;    onEndTurnButtonClicked() {&#10;      backendEventBus.emit(EventNames.Player.END_TURN);&#10;    },&#10;    onDropSkillButtonClicked() {&#10;      backendEventBus.emit(EventNames.Player.DROP_SKILL);&#10;    },&#10;    generateParticleEffects(manaCost, actionPointCost, mouseX, mouseY) {&#10;      const particles = [];&#10;      if (manaCost &gt; 0) {&#10;        for (let i = 0; i &lt; 2 + manaCost * 8; i++) {&#10;          particles.push({&#10;            x: mouseX, y: mouseY,&#10;            vx: (Math.random() - 0.5) * 100,&#10;            vy: (Math.random() - 0.5) * 100 - 50,&#10;            color: '#2196f3', life: 2000, gravity: 400, size: 3 + Math.random() * 2&#10;          });&#10;        }&#10;      }&#10;      if (actionPointCost &gt; 0) {&#10;        for (let i = 0; i &lt; 2 + actionPointCost * 8; i++) {&#10;          particles.push({&#10;            x: mouseX, y: mouseY,&#10;            vx: (Math.random() - 0.5) * 100,&#10;            vy: (Math.random() - 0.5) * 100 - 50,&#10;            color: '#FFD700', life: 2000, gravity: 400, size: 3 + Math.random() * 2&#10;          });&#10;        }&#10;      }&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;/* 操作面板 */&#10;.action-panel {&#10;  position: absolute;&#10;  bottom: 0;&#10;  width: 100%;&#10;  padding: 15px;&#10;}&#10;&#10;.action-panel.disabled {&#10;  filter: brightness(50%);&#10;  pointer-events: none;&#10;}&#10;&#10;.skills {&#10;  display: grid;&#10;  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));&#10;  gap: 15px;&#10;  margin-bottom: 15px;&#10;  position: relative;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/AnimationOverlay.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/AnimationOverlay.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div ref=&quot;overlay&quot; class=&quot;animation-overlay&quot; aria-hidden=&quot;true&quot;&gt;&#10;    &lt;!-- 中心舞台锚点：用于卡牌飞向中心播放动画 --&gt;&#10;    &lt;div ref=&quot;centerAnchor&quot; class=&quot;overlay-anchor center-anchor&quot;&gt;&lt;/div&gt;&#10;    &lt;!-- 牌库入口锚点：用于卡牌飞入牌库（可根据你的UI具体位置再调整） --&gt;&#10;    &lt;div ref=&quot;deckAnchor&quot; class=&quot;overlay-anchor deck-anchor&quot;&gt;&lt;/div&gt;&#10;    &lt;!-- 幽灵元素容器（克隆的卡牌等） --&gt;&#10;    &lt;div ref=&quot;ghostContainer&quot; class=&quot;ghost-container&quot;&gt;&lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;export default {&#10;  name: 'AnimationOverlay',&#10;  methods: {&#10;    getRefs() {&#10;      return {&#10;        overlayEl: this.$refs.overlay,&#10;        centerAnchorEl: this.$refs.centerAnchor,&#10;        deckAnchorEl: this.$refs.deckAnchor,&#10;        ghostContainerEl: this.$refs.ghostContainer,&#10;      };&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.animation-overlay {&#10;  position: fixed;&#10;  inset: 0;&#10;  pointer-events: none; /* 不阻断交互 */&#10;  z-index: 9999; /* 在最上层 */&#10;}&#10;.overlay-anchor {&#10;  position: absolute;&#10;  width: 0;&#10;  height: 0;&#10;}&#10;/* 中心舞台：屏幕正中 */&#10;.center-anchor {&#10;  left: 50%;&#10;  top: 50%;&#10;  transform: translate(-50%, -50%);&#10;}&#10;/* 牌库锚点：屏幕右下，适当留边距 */&#10;.deck-anchor {&#10;  right: 24px;&#10;  bottom: 24px;&#10;}&#10;.ghost-container {&#10;  position: absolute;&#10;  inset: 0;&#10;  overflow: visible;&#10;}&#10;&lt;/style&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div ref=&quot;overlay&quot; class=&quot;animation-overlay&quot; aria-hidden=&quot;true&quot;&gt;&#10;    &lt;!-- 中心舞台锚点：用于卡牌飞向中心播放动画 --&gt;&#10;    &lt;div ref=&quot;centerAnchor&quot; class=&quot;overlay-anchor center-anchor&quot;&gt;&lt;/div&gt;&#10;    &lt;!-- 牌库入口锚点：用于卡牌飞入牌库（可根据你的UI具体位置再调整） --&gt;&#10;    &lt;div ref=&quot;deckAnchor&quot; class=&quot;overlay-anchor deck-anchor&quot;&gt;&lt;/div&gt;&#10;    &lt;!-- 幽灵元素容器（克隆的卡牌等） --&gt;&#10;    &lt;div ref=&quot;ghostContainer&quot; class=&quot;ghost-container&quot;&gt;&lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;export default {&#10;  name: 'AnimationOverlay',&#10;  methods: {&#10;    getRefs() {&#10;      return {&#10;        overlayEl: this.$refs.overlay,&#10;        centerAnchorEl: this.$refs.centerAnchor,&#10;        deckAnchorEl: this.$refs.deckAnchor,&#10;        ghostContainerEl: this.$refs.ghostContainer,&#10;      };&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.animation-overlay {&#10;  position: fixed;&#10;  inset: 0;&#10;  pointer-events: none; /* 不阻断交互 */&#10;  z-index: var(--z-animation);&#10;}&#10;.overlay-anchor {&#10;  position: absolute;&#10;  width: 0;&#10;  height: 0;&#10;}&#10;/* 中心舞台：屏幕正中 */&#10;.center-anchor {&#10;  left: 50%;&#10;  top: 50%;&#10;  transform: translate(-50%, -50%);&#10;}&#10;/* 牌库锚点：屏幕右下，适当留边距 */&#10;.deck-anchor {&#10;  right: 24px;&#10;  bottom: 24px;&#10;}&#10;.ghost-container {&#10;  position: absolute;&#10;  inset: 0;&#10;  overflow: visible;&#10;  z-index: var(--z-animation);&#10;}&#10;/* 防止任何CSS动画/过渡影响幽灵元素，保证GSAP独占控制；并用border-box确保宽高包含边框，避免尺寸偏差 */&#10;.ghost-container :global(.animation-ghost) {&#10;  box-sizing: border-box;&#10;  animation: none !important;&#10;  transition: none !important;&#10;  will-change: transform, opacity;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/BattleScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/BattleScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;battle-screen&quot;&gt;&#10;    &lt;!-- 战斗场次 --&gt;&#10;    &lt;h3 style=&quot;color: white;&quot;&gt; 第{{ level }}层 &lt;/h3&gt;&#10;    &lt;!-- 顶部状态面板区域 --&gt;&#10;    &lt;div class=&quot;status-panels&quot;&gt;&#10;      &lt;!-- 敌人状态面板 --&gt;&#10;      &lt;EnemyStatusPanel &#10;        :enemy=&quot;enemy&quot;&#10;        :z-index=&quot;2&quot;&#10;        ref=&quot;enemyStatusPanel&quot;&#10;      /&gt;&#10;&#10;      &lt;!-- 玩家状态面板 --&gt;&#10;      &lt;PlayerStatusPanel &#10;        :player=&quot;player&quot;&#10;        ref=&quot;playerStatusPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;!-- 战斗日志面板 --&gt;&#10;    &lt;BattleLogPanel &#10;      :logs=&quot;logs&quot;&#10;      :enemy=&quot;enemy&quot;&#10;    /&gt;&#10;    &#10;    &lt;!-- 操作面板 --&gt;&#10;    &lt;ActionPanel&#10;      :player=&quot;player&quot;&#10;      :is-control-disabled=&quot;isControlDisabled&quot;&#10;      :is-player-turn=&quot;isPlayerTurn&quot;&#10;    /&gt;&#10;&#10;    &lt;!-- 动画覆盖层（fixed，全屏，不阻断交互） --&gt;&#10;    &lt;AnimationOverlay ref=&quot;animationOverlay&quot; /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import BattleLogPanel from './BattleLogPanel.vue';&#10;import EnemyStatusPanel from './EnemyStatusPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import ActionPanel from './ActionPanel.vue';&#10;import AnimationOverlay from './AnimationOverlay.vue';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import orchestrator from '../utils/animationOrchestrator.js';&#10;&#10;export default {&#10;  name: 'BattleScreen',&#10;  components: {&#10;    BattleLogPanel,&#10;    EnemyStatusPanel,&#10;    PlayerStatusPanel,&#10;    ActionPanel,&#10;    AnimationOverlay&#10;  },&#10;  props: {&#10;    player: { type: Object, required: true },&#10;    enemy: { type: Object, required: true },&#10;    isControlDisabled: { type: Boolean, default: false },&#10;    isPlayerTurn: { type: Boolean, default: true },&#10;    level: { type: Number, default: 1 }&#10;  },&#10;  data() {&#10;    return {&#10;      logs: []&#10;    };&#10;  },&#10;  mounted() {&#10;    frontendEventBus.on('add-battle-log', this.onAddBattleLog);&#10;    frontendEventBus.on('clear-battle-log', this.onClearBattleLog);&#10;&#10;    // 初始化动画编排器（注入 overlay/anchors/ghost 容器）&#10;    const overlayRefs = this.$refs.animationOverlay?.getRefs?.();&#10;    if (overlayRefs) {&#10;      orchestrator.init(overlayRefs);&#10;    }&#10;  },&#10;  beforeUnmount() {&#10;    frontendEventBus.off('add-battle-log', this.onAddBattleLog);&#10;    frontendEventBus.off('clear-battle-log', this.onClearBattleLog);&#10;  },&#10;  methods: {&#10;    onAddBattleLog(value) {&#10;      // 兼容字符串与对象格式&#10;      this.logs.push(value);&#10;    },&#10;    onClearBattleLog() {&#10;      this.logs = [];&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.battle-screen {&#10;  margin: 0 auto;&#10;  max-width: 1200px;&#10;  height:100vh;&#10;  display: flex;&#10;  flex-direction: column;&#10;  padding: 20px;&#10;  box-sizing: border-box;&#10;}&#10;&#10;/* 顶部状态面板区域 */&#10;.status-panels {&#10;  display: flex;&#10;  justify-content: space-between; /* 左右贴边对齐 */&#10;  align-items: flex-start;&#10;  gap: 20px;&#10;  margin-bottom: 20px;&#10;  min-height: 200px;&#10;}&#10;/* 确保面板保持各自的固定宽度，不被拉伸或压缩 */&#10;.status-panels &gt; * {&#10;  flex: 0 0 auto;&#10;}&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;battle-screen&quot;&gt;&#10;    &lt;!-- 战斗场次 --&gt;&#10;    &lt;h3 style=&quot;color: white;&quot;&gt; 第{{ level }}层 &lt;/h3&gt;&#10;    &lt;!-- 顶部状态面板区域 --&gt;&#10;    &lt;div class=&quot;status-panels&quot;&gt;&#10;      &lt;!-- 敌人状态面板 --&gt;&#10;      &lt;EnemyStatusPanel &#10;        :enemy=&quot;enemy&quot;&#10;        :z-index=&quot;2&quot;&#10;        ref=&quot;enemyStatusPanel&quot;&#10;      /&gt;&#10;&#10;      &lt;!-- 玩家状态面板 --&gt;&#10;      &lt;PlayerStatusPanel &#10;        :player=&quot;player&quot;&#10;        ref=&quot;playerStatusPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;!-- 战斗日志面板 --&gt;&#10;    &lt;BattleLogPanel &#10;      :logs=&quot;logs&quot;&#10;      :enemy=&quot;enemy&quot;&#10;    /&gt;&#10;    &#10;    &lt;!-- 操作面板 --&gt;&#10;    &lt;ActionPanel&#10;      :player=&quot;player&quot;&#10;      :is-control-disabled=&quot;isControlDisabled&quot;&#10;      :is-player-turn=&quot;isPlayerTurn&quot;&#10;    /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import BattleLogPanel from './BattleLogPanel.vue';&#10;import EnemyStatusPanel from './EnemyStatusPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import ActionPanel from './ActionPanel.vue';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;export default {&#10;  name: 'BattleScreen',&#10;  components: {&#10;    BattleLogPanel,&#10;    EnemyStatusPanel,&#10;    PlayerStatusPanel,&#10;    ActionPanel&#10;  },&#10;  props: {&#10;    player: { type: Object, required: true },&#10;    enemy: { type: Object, required: true },&#10;    isControlDisabled: { type: Boolean, default: false },&#10;    isPlayerTurn: { type: Boolean, default: true },&#10;    level: { type: Number, default: 1 }&#10;  },&#10;  data() {&#10;    return {&#10;      logs: []&#10;    };&#10;  },&#10;  mounted() {&#10;    frontendEventBus.on('add-battle-log', this.onAddBattleLog);&#10;    frontendEventBus.on('clear-battle-log', this.onClearBattleLog);&#10;  },&#10;  beforeUnmount() {&#10;    frontendEventBus.off('add-battle-log', this.onAddBattleLog);&#10;    frontendEventBus.off('clear-battle-log', this.onClearBattleLog);&#10;  },&#10;  methods: {&#10;    onAddBattleLog(value) {&#10;      // 兼容字符串与对象格式&#10;      this.logs.push(value);&#10;    },&#10;    onClearBattleLog() {&#10;      this.logs = [];&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.battle-screen {&#10;  margin: 0 auto;&#10;  max-width: 1200px;&#10;  height:100vh;&#10;  display: flex;&#10;  flex-direction: column;&#10;  padding: 20px;&#10;  box-sizing: border-box;&#10;}&#10;&#10;/* 顶部状态面板区域 */&#10;.status-panels {&#10;  display: flex;&#10;  justify-content: space-between; /* 左右贴边对齐 */&#10;  align-items: flex-start;&#10;  gap: 20px;&#10;  margin-bottom: 20px;&#10;  min-height: 200px;&#10;}&#10;/* 确保面板保持各自的固定宽度，不被拉伸或压缩 */&#10;.status-panels &gt; * {&#10;  flex: 0 0 auto;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/BossShowupAnimation.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/BossShowupAnimation.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;boss-showup-overlay&quot; v-if=&quot;showAnimation&quot;&gt;&#10;    &lt;img :src=&quot;bossCoverImageUrl&quot; class=&quot;boss-cover-image&quot; /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;export default {&#10;  name: 'BossShowupAnimation',&#10;  data() {&#10;    return {&#10;      showAnimation: false,&#10;      bossCoverImageUrl: '',&#10;    };&#10;  },&#10;  mounted() {&#10;    frontendEventBus.on('play-boss-showup-animation', (bossClass, bossCoverImageUrl) =&gt; {&#10;      this.playAnimation(bossClass, bossCoverImageUrl);&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    frontendEventBus.off('play-boss-showup-animation', this.onAnimationEnd);&#10;  },&#10;  methods: {&#10;    playAnimation(bossClass, bossCoverImageUrl) {&#10;      this.bossCoverImageUrl = bossCoverImageUrl;&#10;      this.showAnimation = true;&#10;      &#10;      // 播放动画，3秒后隐藏&#10;      setTimeout(() =&gt; {&#10;        this.showAnimation = false;&#10;      }, 3000);&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.boss-showup-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: rgba(0, 0, 0, 0.8);&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  z-index: 1000; /* 确保在战斗和休整界面之上 */&#10;}&#10;&#10;.boss-cover-image {&#10;  max-width: 90%;&#10;  max-height: 90%;&#10;  object-fit: contain;&#10;  animation: fadeIn 0.5s ease-in-out, fadeOut 0.5s ease-in-out 2.5s forwards;&#10;}&#10;&#10;@keyframes fadeIn {&#10;  from { opacity: 0; transform: scale(0.8); }&#10;  to { opacity: 1; transform: scale(1); }&#10;}&#10;&#10;@keyframes fadeOut {&#10;  from { opacity: 1; }&#10;  to { opacity: 0; }&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;div class=&quot;boss-showup-overlay&quot; v-if=&quot;showAnimation&quot;&gt;&#13;&#10;    &lt;img :src=&quot;bossCoverImageUrl&quot; class=&quot;boss-cover-image&quot; /&gt;&#13;&#10;  &lt;/div&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import frontendEventBus from '../frontendEventBus.js';&#13;&#10;&#13;&#10;export default {&#13;&#10;  name: 'BossShowupAnimation',&#13;&#10;  data() {&#13;&#10;    return {&#13;&#10;      showAnimation: false,&#13;&#10;      bossCoverImageUrl: '',&#13;&#10;    };&#13;&#10;  },&#13;&#10;  mounted() {&#13;&#10;    frontendEventBus.on('play-boss-showup-animation', (bossClass, bossCoverImageUrl) =&gt; {&#13;&#10;      this.playAnimation(bossClass, bossCoverImageUrl);&#13;&#10;    });&#13;&#10;  },&#13;&#10;  beforeUnmount() {&#13;&#10;    frontendEventBus.off('play-boss-showup-animation', this.onAnimationEnd);&#13;&#10;  },&#13;&#10;  methods: {&#13;&#10;    playAnimation(bossClass, bossCoverImageUrl) {&#13;&#10;      this.bossCoverImageUrl = bossCoverImageUrl;&#13;&#10;      this.showAnimation = true;&#13;&#10;      &#13;&#10;      // 播放动画，3秒后隐藏&#13;&#10;      setTimeout(() =&gt; {&#13;&#10;        this.showAnimation = false;&#13;&#10;      }, 3000);&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.boss-showup-overlay {&#13;&#10;  position: fixed;&#13;&#10;  top: 0;&#13;&#10;  left: 0;&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  background-color: rgba(0, 0, 0, 0.8);&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: center;&#13;&#10;  z-index: var(--z-boss);&#13;&#10;}&#13;&#10;&#13;&#10;.boss-cover-image {&#13;&#10;  max-width: 90%;&#13;&#10;  max-height: 90%;&#13;&#10;  object-fit: contain;&#13;&#10;  animation: fadeIn 0.5s ease-in-out, fadeOut 0.5s ease-in-out 2.5s forwards;&#13;&#10;}&#13;&#10;&#13;&#10;@keyframes fadeIn {&#13;&#10;  from { opacity: 0; transform: scale(0.8); }&#13;&#10;  to { opacity: 1; transform: scale(1); }&#13;&#10;}&#13;&#10;&#13;&#10;@keyframes fadeOut {&#13;&#10;  from { opacity: 1; }&#13;&#10;  to { opacity: 0; }&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/CutsceneScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/CutsceneScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;transition name=&quot;fade&quot;&gt;&#10;    &lt;div class=&quot;cutscene-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#10;      &lt;div class=&quot;cutscene-screen&quot;&gt;&#10;        &lt;transition name=&quot;image-fade&quot; mode=&quot;out-in&quot;&gt;&#10;          &lt;img :src=&quot;currentImage&quot; :alt=&quot;currentImage&quot; class=&quot;cutscene-image&quot; v-if=&quot;showImage&quot; :key=&quot;currentImage&quot; /&gt;&#10;        &lt;/transition&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;export default {&#10;  name: 'CutsceneScreen',&#10;  props: {&#10;    gameState: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      isVisible: false,&#10;      currentImage: '',&#10;      cutsceneImageIndex: 0,&#10;      cutsceneEvent: null,&#10;      fadeTimeout: null,&#10;      previousStage: '',&#10;      showImage: true&#10;    };&#10;  },&#10;  mounted() {&#10;    // 监听display-cutscene事件&#10;    frontendEventBus.on('display-cutscene', (cutsceneEvent) =&gt; {&#10;      if(this.cutsceneEvent) {&#10;        console.error('CutsceneScreen: 尝试显示新的cutscene事件时，当前已存在一个cutscene事件');&#10;        return ;&#10;      }&#10;      this.cutsceneEvent = cutsceneEvent;&#10;      this.currentImage = '';&#10;      this.cutsceneImageIndex = 0;&#10;      this.isVisible = true;&#10;    &#10;      setTimeout(()=&gt;{&#10;        this.currentImage = this.cutsceneEvent.images[this.cutsceneImageIndex];&#10;        this.showImage = true;&#10;        const interval = setInterval(()=&gt;{&#10;          this.showImage = false;&#10;          setTimeout(() =&gt; {&#10;            this.cutsceneImageIndex++;&#10;            if(this.cutsceneImageIndex &lt; this.cutsceneEvent.images.length){&#10;              this.currentImage = this.cutsceneEvent.images[this.cutsceneImageIndex];&#10;            } else {&#10;              this.cutsceneImageIndex = 0;&#10;              this.currentImage = '';&#10;              clearInterval(interval);&#10;              setTimeout(()=&gt; {&#10;                this.cutsceneEvent?.onEnd?.();&#10;                this.cutsceneEvent = null;&#10;                this.isVisible = false;&#10;              }, 1000);&#10;              return;&#10;            }&#10;            this.showImage = true;&#10;          }, 500);&#10;        }, this.cutsceneEvent.interval || 3000);&#10;      }, 1000);&#10;    });&#10;    &#10;    // 监听游戏阶段变化（如需）&#10;    this.previousStage = this.gameState.gameStage;&#10;  },&#10;  beforeUnmount() {&#10;    // 移除事件监听&#10;    frontendEventBus.off('display-cutscene', this.onCutsceneEnd);&#10;    // 清除定时器&#10;    if (this.fadeTimeout) {&#10;      clearTimeout(this.fadeTimeout);&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.cutscene-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: black;&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  z-index: 900; /* 低于DialogScreen的1000 */&#10;}&#10;&#10;.fade-enter-active, .fade-leave-active {&#10;  transition: opacity 1s ease;&#10;}&#10;.fade-enter-from, .fade-leave-to {&#10;  opacity: 0;&#10;}&#10;&#10;.image-fade-enter-active, .image-fade-leave-active {&#10;  transition: opacity 0.5s ease;&#10;}&#10;.image-fade-enter-from, .image-fade-leave-to {&#10;  opacity: 0;&#10;}&#10;&#10;.cutscene-screen {&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;}&#10;&#10;.cutscene-image {&#10;  max-width: 90%;&#10;  max-height: 90%;&#10;  object-fit: contain;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;transition name=&quot;fade&quot;&gt;&#13;&#10;    &lt;div class=&quot;cutscene-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#13;&#10;      &lt;div class=&quot;cutscene-screen&quot;&gt;&#13;&#10;        &lt;transition name=&quot;image-fade&quot; mode=&quot;out-in&quot;&gt;&#13;&#10;          &lt;img :src=&quot;currentImage&quot; :alt=&quot;currentImage&quot; class=&quot;cutscene-image&quot; v-if=&quot;showImage&quot; :key=&quot;currentImage&quot; /&gt;&#13;&#10;        &lt;/transition&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  &lt;/transition&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import frontendEventBus from '../frontendEventBus.js';&#13;&#10;&#13;&#10;export default {&#13;&#10;  name: 'CutsceneScreen',&#13;&#10;  props: {&#13;&#10;    gameState: {&#13;&#10;      type: Object,&#13;&#10;      required: true&#13;&#10;    }&#13;&#10;  },&#13;&#10;  data() {&#13;&#10;    return {&#13;&#10;      isVisible: false,&#13;&#10;      currentImage: '',&#13;&#10;      cutsceneImageIndex: 0,&#13;&#10;      cutsceneEvent: null,&#13;&#10;      fadeTimeout: null,&#13;&#10;      previousStage: '',&#13;&#10;      showImage: true&#13;&#10;    };&#13;&#10;  },&#13;&#10;  mounted() {&#13;&#10;    // 监听display-cutscene事件&#13;&#10;    frontendEventBus.on('display-cutscene', (cutsceneEvent) =&gt; {&#13;&#10;      if(this.cutsceneEvent) {&#13;&#10;        console.error('CutsceneScreen: 尝试显示新的cutscene事件时，当前已存在一个cutscene事件');&#13;&#10;        return ;&#13;&#10;      }&#13;&#10;      this.cutsceneEvent = cutsceneEvent;&#13;&#10;      this.currentImage = '';&#13;&#10;      this.cutsceneImageIndex = 0;&#13;&#10;      this.isVisible = true;&#13;&#10;    &#13;&#10;      setTimeout(()=&gt;{&#13;&#10;        this.currentImage = this.cutsceneEvent.images[this.cutsceneImageIndex];&#13;&#10;        this.showImage = true;&#13;&#10;        const interval = setInterval(()=&gt;{&#13;&#10;          this.showImage = false;&#13;&#10;          setTimeout(() =&gt; {&#13;&#10;            this.cutsceneImageIndex++;&#13;&#10;            if(this.cutsceneImageIndex &lt; this.cutsceneEvent.images.length){&#13;&#10;              this.currentImage = this.cutsceneEvent.images[this.cutsceneImageIndex];&#13;&#10;            } else {&#13;&#10;              this.cutsceneImageIndex = 0;&#13;&#10;              this.currentImage = '';&#13;&#10;              clearInterval(interval);&#13;&#10;              setTimeout(()=&gt; {&#13;&#10;                this.cutsceneEvent?.onEnd?.();&#13;&#10;                this.cutsceneEvent = null;&#13;&#10;                this.isVisible = false;&#13;&#10;              }, 1000);&#13;&#10;              return;&#13;&#10;            }&#13;&#10;            this.showImage = true;&#13;&#10;          }, 500);&#13;&#10;        }, this.cutsceneEvent.interval || 3000);&#13;&#10;      }, 1000);&#13;&#10;    });&#13;&#10;    &#13;&#10;    // 监听游戏阶段变化（如需）&#13;&#10;    this.previousStage = this.gameState.gameStage;&#13;&#10;  },&#13;&#10;  beforeUnmount() {&#13;&#10;    // 移除事件监听&#13;&#10;    frontendEventBus.off('display-cutscene', this.onCutsceneEnd);&#13;&#10;    // 清除定时器&#13;&#10;    if (this.fadeTimeout) {&#13;&#10;      clearTimeout(this.fadeTimeout);&#13;&#10;    }&#13;&#10;  }&#13;&#10;};&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.cutscene-overlay {&#13;&#10;  position: fixed;&#13;&#10;  top: 0;&#13;&#10;  left: 0;&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  background-color: black;&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: center;&#13;&#10;  z-index: var(--z-cutscene);&#13;&#10;}&#13;&#10;&#13;&#10;.fade-enter-active, .fade-leave-active {&#13;&#10;  transition: opacity 1s ease;&#13;&#10;}&#13;&#10;.fade-enter-from, .fade-leave-to {&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.image-fade-enter-active, .image-fade-leave-active {&#13;&#10;  transition: opacity 0.5s ease;&#13;&#10;}&#13;&#10;.image-fade-enter-from, .image-fade-leave-to {&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.cutscene-screen {&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: center;&#13;&#10;}&#13;&#10;&#13;&#10;.cutscene-image {&#13;&#10;  max-width: 90%;&#13;&#10;  max-height: 90%;&#13;&#10;  object-fit: contain;&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/DialogScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/DialogScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;dialog-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#10;    &lt;div class=&quot;dialog-screen&quot;&gt;&#10;      &lt;div class=&quot;character-avatar&quot;&gt;&#10;        &lt;img :src=&quot;currentDialog.avatar&quot; :alt=&quot;currentDialog.character&quot; v-if=&quot;currentDialog.avatar&quot;&gt;&#10;        &lt;div v-else class=&quot;placeholder-avatar&quot;&gt;{{ currentDialog.character }}&lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;dialog-content&quot;&gt;&#10;        &lt;h3&gt;{{ currentDialog.character }}&lt;/h3&gt;&#10;        &lt;p&gt;&lt;ColoredText :text=&quot;currentDialog.text&quot; /&gt;&lt;/p&gt;&#10;        &lt;button @click=&quot;nextDialog&quot;&gt;继续&lt;/button&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import ColoredText from './ColoredText.vue';&#10;&#10;export default {&#10;  name: 'DialogScreen',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  data() {&#10;    return {&#10;      isVisible: false,&#10;      currentDialog: {&#10;        character: '',&#10;        text: '',&#10;        avatar: ''&#10;      },&#10;      dialogSequence: [],&#10;      dialogIndex: 0&#10;    };&#10;  },&#10;  mounted() {&#10;    // 监听display-dialog事件&#10;    frontendEventBus.on('display-dialog', (dialogSequence) =&gt; {&#10;      this.dialogSequence = dialogSequence;&#10;      this.dialogIndex = 0;&#10;      this.currentDialog = this.dialogSequence[this.dialogIndex];&#10;      this.isVisible = true;&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    // 移除事件监听&#10;    frontendEventBus.off('display-dialog', this.onClose);&#10;  },&#10;  methods: {&#10;    nextDialog() {&#10;      // 检查是否还有更多对话&#10;      if (this.dialogIndex &lt; this.dialogSequence.length - 1) {&#10;        // 显示下一个对话&#10;        this.dialogIndex++;&#10;        this.currentDialog = this.dialogSequence[this.dialogIndex];&#10;      } else {&#10;        // 对话结束，隐藏对话框&#10;        this.isVisible = false;&#10;        this.dialogSequence = [];&#10;        this.dialogIndex = 0;&#10;        &#10;        // 触发对话结束事件（前端事件总线）&#10;        frontendEventBus.emit('dialog-ended');&#10;      }&#10;      this.$emit('next-dialog');&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.dialog-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: flex-end;&#10;  z-index: 1000;&#10;}&#10;&#10;.dialog-screen {&#10;  background-color: white;&#10;  width: 80%;&#10;  max-width: 600px;&#10;  border-radius: 10px;&#10;  display: flex;&#10;  padding: 20px;&#10;  margin-bottom: 20px;&#10;}&#10;&#10;.character-avatar {&#10;  width: 100px;&#10;  height: 100px;&#10;  margin-right: 20px;&#10;}&#10;&#10;.character-avatar img {&#10;  width: 100%;&#10;  height: 100%;&#10;  object-fit: cover;&#10;  border-radius: 50%;&#10;}&#10;&#10;.placeholder-avatar {&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: #eee;&#10;  border-radius: 50%;&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  font-weight: bold;&#10;}&#10;&#10;.dialog-content {&#10;  flex: 1;&#10;}&#10;&#10;.dialog-content h3 {&#10;  margin-top: 0;&#10;}&#10;&#10;button {&#10;  padding: 10px 20px;&#10;  float: right;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;div class=&quot;dialog-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#13;&#10;    &lt;div class=&quot;dialog-screen&quot;&gt;&#13;&#10;      &lt;div class=&quot;character-avatar&quot;&gt;&#13;&#10;        &lt;img :src=&quot;currentDialog.avatar&quot; :alt=&quot;currentDialog.character&quot; v-if=&quot;currentDialog.avatar&quot;&gt;&#13;&#10;        &lt;div v-else class=&quot;placeholder-avatar&quot;&gt;{{ currentDialog.character }}&lt;/div&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;      &lt;div class=&quot;dialog-content&quot;&gt;&#13;&#10;        &lt;h3&gt;{{ currentDialog.character }}&lt;/h3&gt;&#13;&#10;        &lt;p&gt;&lt;ColoredText :text=&quot;currentDialog.text&quot; /&gt;&lt;/p&gt;&#13;&#10;        &lt;button @click=&quot;nextDialog&quot;&gt;继续&lt;/button&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  &lt;/div&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import frontendEventBus from '../frontendEventBus.js';&#13;&#10;import ColoredText from './ColoredText.vue';&#13;&#10;&#13;&#10;export default {&#13;&#10;  name: 'DialogScreen',&#13;&#10;  components: {&#13;&#10;    ColoredText&#13;&#10;  },&#13;&#10;  data() {&#13;&#10;    return {&#13;&#10;      isVisible: false,&#13;&#10;      currentDialog: {&#13;&#10;        character: '',&#13;&#10;        text: '',&#13;&#10;        avatar: ''&#13;&#10;      },&#13;&#10;      dialogSequence: [],&#13;&#10;      dialogIndex: 0&#13;&#10;    };&#13;&#10;  },&#13;&#10;  mounted() {&#13;&#10;    // 监听display-dialog事件&#13;&#10;    frontendEventBus.on('display-dialog', (dialogSequence) =&gt; {&#13;&#10;      this.dialogSequence = dialogSequence;&#13;&#10;      this.dialogIndex = 0;&#13;&#10;      this.currentDialog = this.dialogSequence[this.dialogIndex];&#13;&#10;      this.isVisible = true;&#13;&#10;    });&#13;&#10;  },&#13;&#10;  beforeUnmount() {&#13;&#10;    // 移除事件监听&#13;&#10;    frontendEventBus.off('display-dialog', this.onClose);&#13;&#10;  },&#13;&#10;  methods: {&#13;&#10;    nextDialog() {&#13;&#10;      // 检查是否还有更多对话&#13;&#10;      if (this.dialogIndex &lt; this.dialogSequence.length - 1) {&#13;&#10;        // 显示下一个对话&#13;&#10;        this.dialogIndex++;&#13;&#10;        this.currentDialog = this.dialogSequence[this.dialogIndex];&#13;&#10;      } else {&#13;&#10;        // 对话结束，隐藏对话框&#13;&#10;        this.isVisible = false;&#13;&#10;        this.dialogSequence = [];&#13;&#10;        this.dialogIndex = 0;&#13;&#10;        &#13;&#10;        // 触发对话结束事件（前端事件总线）&#13;&#10;        frontendEventBus.emit('dialog-ended');&#13;&#10;      }&#13;&#10;      this.$emit('next-dialog');&#13;&#10;    }&#13;&#10;  }&#13;&#10;};&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.dialog-overlay {&#13;&#10;  position: fixed;&#13;&#10;  top: 0;&#13;&#10;  left: 0;&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  background-color: rgba(0, 0, 0, 0.5);&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: flex-end;&#13;&#10;  z-index: var(--z-dialog);&#13;&#10;}&#13;&#10;&#13;&#10;.dialog-screen {&#13;&#10;  background-color: white;&#13;&#10;  width: 80%;&#13;&#10;  max-width: 600px;&#13;&#10;  border-radius: 10px;&#13;&#10;  display: flex;&#13;&#10;  padding: 20px;&#13;&#10;  margin-bottom: 20px;&#13;&#10;}&#13;&#10;&#13;&#10;.character-avatar {&#13;&#10;  width: 100px;&#13;&#10;  height: 100px;&#13;&#10;  margin-right: 20px;&#13;&#10;}&#13;&#10;&#13;&#10;.character-avatar img {&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  object-fit: cover;&#13;&#10;  border-radius: 50%;&#13;&#10;}&#13;&#10;&#13;&#10;.placeholder-avatar {&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  background-color: #eee;&#13;&#10;  border-radius: 50%;&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: center;&#13;&#10;  font-weight: bold;&#13;&#10;}&#13;&#10;&#13;&#10;.dialog-content {&#13;&#10;  flex: 1;&#13;&#10;}&#13;&#10;&#13;&#10;.dialog-content h3 {&#13;&#10;  margin-top: 0;&#13;&#10;}&#13;&#10;&#13;&#10;button {&#13;&#10;  padding: 10px 20px;&#13;&#10;  float: right;&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/EnemyStatusPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/EnemyStatusPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;HurtAnimationWrapper :unit=&quot;enemy&quot; ref=&quot;hurtAnimation&quot;&gt;&#10;    &lt;div class=&quot;enemy-status-panel&quot; ref=&quot;enemyPanel&quot;&gt;&#10;      &lt;div class=&quot;enemy-avatar&quot;&gt;&#10;          &lt;img v-if=&quot;enemy.avatarUrl&quot; :src=&quot;enemy.avatarUrl&quot; :alt=&quot;enemy.name&quot; class=&quot;avatar-image&quot; /&gt;&#10;          &lt;div v-else class=&quot;avatar-placeholder&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;enemy-details&quot;&gt;&#10;        &lt;div class=&quot;enemy-header&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;h2 style=&quot;color: red; display: inline-block;&quot;&gt;敌人：{{ enemy.name }}&lt;/h2&gt;&#10;            &lt;span v-if=&quot;enemy.isBoss&quot; class=&quot;enemy-subtitle&quot;&gt; - {{ enemy.subtitle }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;enemy-info-button&quot; @mouseenter=&quot;showEnemyInfo&quot; @mouseleave=&quot;hideEnemyInfo&quot;&gt;?&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &#10;      &lt;div class=&quot;enemy-stats&quot;&gt;&#10;        &lt;div class=&quot;stat&quot;&gt;&#10;          &lt;span class=&quot;stat-label&quot;&gt;⚔️ 攻击:&lt;/span&gt;&#10;          &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.attack }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;stat&quot;&gt;&#10;          &lt;span class=&quot;stat-label&quot;&gt;️ 防御:&lt;/span&gt;&#10;          &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.defense }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;!-- 效果显示栏 --&gt;&#10;      &lt;EffectDisplayBar &#10;        :effects=&quot;enemy.effects&quot;&#10;        :target=&quot;enemy&quot;&#10;        @show-tooltip=&quot;$emit('show-tooltip', $event)&quot;&#10;        @hide-tooltip=&quot;$emit('hide-tooltip')&quot;&#10;      /&gt;&#10;      &lt;HealthBar :unit=&quot;enemy&quot; class=&quot;enemy&quot; /&gt;&#10;      &#10;    &lt;/div&gt;&#10;    &lt;!-- 敌人信息悬浮框 --&gt;&#10;    &lt;div &#10;      v-if=&quot;enemyInfo.show&quot; &#10;      class=&quot;enemy-info-tooltip&quot; &#10;      :style=&quot;{ left: enemyInfo.x + 'px', top: enemyInfo.y + 'px' }&quot;&#10;    &gt;&#10;      &lt;div class=&quot;enemy-info-content&quot;&gt;&#10;        &lt;h3&gt;{{ enemy.name }}&lt;/h3&gt;&#10;        &lt;p v-if=&quot;enemy.subtitle&quot;&gt;{{ enemy.subtitle }}&lt;/p&gt;&#10;        &lt;p&gt;{{ enemy.description }}&lt;/p&gt;&#10;        &lt;div class=&quot;enemy-info-stats&quot;&gt;&#10;          &lt;div class=&quot;stat&quot;&gt;&#10;            &lt;span class=&quot;stat-label&quot;&gt;⚔️ 攻击力:&lt;/span&gt;&#10;            &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.attack }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat&quot;&gt;&#10;            &lt;span class=&quot;stat-label&quot;&gt;️ 防御力:&lt;/span&gt;&#10;            &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.defense }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;  &lt;/HurtAnimationWrapper&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import EffectDisplayBar from './EffectDisplayBar.vue';&#10;import HurtAnimationWrapper from './HurtAnimationWrapper.vue';&#10;import HealthBar from './HealthBar.vue';&#10;import Enemy from &quot;../data/enemy&quot;;&#10;&#10;export default {&#10;  name: 'EnemyStatusPanel',&#10;  components: {&#10;    EffectDisplayBar,&#10;    HurtAnimationWrapper,&#10;    HealthBar&#10;  },&#10;  props: {&#10;    enemy: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      enemyInfo: {&#10;        show: false,&#10;        x: 0,&#10;        y: 0&#10;      }&#10;    };&#10;  },&#10;  watch: {&#10;&#10;  },&#10;  methods: {&#10;    showEnemyInfo(event) {&#10;      // 获取相对于HurtAnimationWrapper的位置&#10;      const wrapper = this.$el.closest('.hurt-animation-wrapper');&#10;      if (wrapper) {&#10;        const wrapperRect = wrapper.getBoundingClientRect();&#10;        const buttonRect = event.target.getBoundingClientRect();&#10;        &#10;        // 计算相对于wrapper的位置&#10;        const relativeX = buttonRect.left - wrapperRect.left + 30;&#10;        const relativeY = buttonRect.top - wrapperRect.top - 10;&#10;        &#10;        this.enemyInfo = {&#10;          show: true,&#10;          x: relativeX,&#10;          y: relativeY&#10;        };&#10;      } else {&#10;        // 如果没有找到wrapper，使用绝对定位作为fallback&#10;        this.enemyInfo = {&#10;          show: true,&#10;          x: event.clientX + 20,&#10;          y: event.clientY - 10&#10;        };&#10;      }&#10;    },&#10;    &#10;    hideEnemyInfo() {&#10;      this.enemyInfo.show = false;&#10;    },&#10;    &#10;&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.enemy-status-panel {&#10;  display: flex;&#10;  align-items: center;&#10;  border: 1px solid #ccc;&#10;  border-radius: 8px;&#10;  background-color: #fff;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  z-index: 1;&#10;}&#10;&#10;.enemy-details {&#10;  padding-right: 20px;&#10;  padding-left: 20px;&#10;  min-width: 300px;&#10;  height: 230px;&#10;}&#10;&#10;.enemy-header {&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.enemy-avatar {&#10;  width: 350px;&#10;  height: 250px;&#10;}&#10;&#10;.avatar-image {&#10;  object-fit:cover;&#10;  width: inherit;&#10;  height: inherit;&#10;}&#10;&#10;.avatar-placeholder {&#10;  object-fit:cover;&#10;  width: inherit;&#10;  height: inherit;&#10;  background-color: #000;&#10;}&#10;&#10;.enemy-info-button {&#10;  cursor: pointer;&#10;  background-color: #f0f0f0;&#10;  border: 1px solid #ccc;&#10;  border-radius: 50%;&#10;  width: 24px;&#10;  height: 24px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  font-weight: bold;&#10;  color: #666;&#10;  flex-shrink: 0;&#10;}&#10;&#10;.enemy-info-button:hover {&#10;  background-color: #e0e0e0;&#10;}&#10;&#10;.enemy-subtitle {&#10;  font-size: 14px;&#10;  color: #666;&#10;  font-weight: normal;&#10;}&#10;&#10;.enemy-stats {&#10;  display: flex;&#10;  gap: 20px;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.stat {&#10;  display: flex;&#10;  align-items: center;&#10;  margin-right: 15px;&#10;}&#10;&#10;.stat-label {&#10;  font-weight: bold;&#10;  margin-right: 5px;&#10;}&#10;&#10;.health-bar-container {&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 10px;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.shield-display {&#10;  font-size: 16px;&#10;  font-weight: bold;&#10;  color: #1E90FF;&#10;  padding: 4px 8px;&#10;  background-color: rgba(30, 144, 255, 0.1);&#10;  border-radius: 4px;&#10;  border: 1px solid #1E90FF;&#10;  transition: transform 0.3s ease;&#10;}&#10;&#10;.shield-display.scale-animation {&#10;  animation: shield-pulse 0.3s ease;&#10;}&#10;&#10;@keyframes shield-pulse {&#10;  0% { transform: scale(1); }&#10;  50% { transform: scale(1.2); }&#10;  100% { transform: scale(1); }&#10;}&#10;&#10;.health-bar {&#10;  flex: 1;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.bar {&#10;  width: 100%;&#10;  height: 20px;&#10;  background-color: #f0f0f0;&#10;  border-radius: 10px;&#10;  overflow: hidden;&#10;  margin-top: 5px;&#10;}&#10;&#10;.fill {&#10;  height: 100%;&#10;  background-color: #f44336;&#10;  transition: width 0.3s ease;&#10;}&#10;&#10;.damage-text-container {&#10;  position: relative;&#10;  height: 0;&#10;  overflow: visible;&#10;  pointer-events: none;&#10;}&#10;&#10;.damage-text {&#10;  position: absolute;&#10;  font-weight: bold;&#10;  font-size: 24px;&#10;  pointer-events: none;&#10;  z-index: 1000;&#10;  animation: damageFloat 1s ease-out forwards;&#10;}&#10;&#10;@keyframes damageFloat {&#10;  0% {&#10;    opacity: 1;&#10;    transform: translateY(0);&#10;  }&#10;  100% {&#10;    opacity: 0;&#10;    transform: translateY(-50px);&#10;  }&#10;}&#10;&#10;/* 敌人信息悬浮框 */&#10;.enemy-info-tooltip {&#10;  position: absolute;&#10;  background-color: rgba(0, 0, 0, 0.9);&#10;  color: white;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  z-index: 1000;&#10;  min-width: 250px;&#10;  max-width: 400px;&#10;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);&#10;  left: v-bind('enemyInfo.x + &quot;px&quot;');&#10;  top: v-bind('enemyInfo.y + &quot;px&quot;');&#10;}&#10;&#10;.enemy-info-content h3 {&#10;  margin-top: 0;&#10;  margin-bottom: 10px;&#10;  color: #ff6666;&#10;}&#10;&#10;.enemy-info-content p {&#10;  margin: 5px 0;&#10;  font-size: 0.9em;&#10;  line-height: 1.4;&#10;}&#10;&#10;.enemy-info-stats {&#10;  margin-top: 10px;&#10;  padding-top: 10px;&#10;  border-top: 1px solid #555;&#10;}&#10;&#10;.enemy-info-stats .stat {&#10;  margin-right: 20px;&#10;  margin-bottom: 5px;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;HurtAnimationWrapper :unit=&quot;enemy&quot; ref=&quot;hurtAnimation&quot;&gt;&#10;    &lt;div class=&quot;enemy-status-panel&quot; ref=&quot;enemyPanel&quot;&gt;&#10;      &lt;div class=&quot;enemy-avatar&quot;&gt;&#10;          &lt;img v-if=&quot;enemy.avatarUrl&quot; :src=&quot;enemy.avatarUrl&quot; :alt=&quot;enemy.name&quot; class=&quot;avatar-image&quot; /&gt;&#10;          &lt;div v-else class=&quot;avatar-placeholder&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;enemy-details&quot;&gt;&#10;        &lt;div class=&quot;enemy-header&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;h2 style=&quot;color: red; display: inline-block;&quot;&gt;敌人：{{ enemy.name }}&lt;/h2&gt;&#10;            &lt;span v-if=&quot;enemy.isBoss&quot; class=&quot;enemy-subtitle&quot;&gt; - {{ enemy.subtitle }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;enemy-info-button&quot; @mouseenter=&quot;showEnemyInfo&quot; @mouseleave=&quot;hideEnemyInfo&quot;&gt;?&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &#10;      &lt;div class=&quot;enemy-stats&quot;&gt;&#10;        &lt;div class=&quot;stat&quot;&gt;&#10;          &lt;span class=&quot;stat-label&quot;&gt;⚔️ 攻击:&lt;/span&gt;&#10;          &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.attack }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;stat&quot;&gt;&#10;          &lt;span class=&quot;stat-label&quot;&gt;️ 防御:&lt;/span&gt;&#10;          &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.defense }}&lt;/span&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;!-- 效果显示栏 --&gt;&#10;      &lt;EffectDisplayBar &#10;        :effects=&quot;enemy.effects&quot;&#10;        :target=&quot;enemy&quot;&#10;        @show-tooltip=&quot;$emit('show-tooltip', $event)&quot;&#10;        @hide-tooltip=&quot;$emit('hide-tooltip')&quot;&#10;      /&gt;&#10;      &lt;HealthBar :unit=&quot;enemy&quot; class=&quot;enemy&quot; /&gt;&#10;      &#10;    &lt;/div&gt;&#10;    &lt;!-- 敌人信息悬浮框 --&gt;&#10;    &lt;div &#10;      v-if=&quot;enemyInfo.show&quot; &#10;      class=&quot;enemy-info-tooltip&quot; &#10;      :style=&quot;{ left: enemyInfo.x + 'px', top: enemyInfo.y + 'px' }&quot;&#10;    &gt;&#10;      &lt;div class=&quot;enemy-info-content&quot;&gt;&#10;        &lt;h3&gt;{{ enemy.name }}&lt;/h3&gt;&#10;        &lt;p v-if=&quot;enemy.subtitle&quot;&gt;{{ enemy.subtitle }}&lt;/p&gt;&#10;        &lt;p&gt;{{ enemy.description }}&lt;/p&gt;&#10;        &lt;div class=&quot;enemy-info-stats&quot;&gt;&#10;          &lt;div class=&quot;stat&quot;&gt;&#10;            &lt;span class=&quot;stat-label&quot;&gt;⚔️ 攻击力:&lt;/span&gt;&#10;            &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.attack }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat&quot;&gt;&#10;            &lt;span class=&quot;stat-label&quot;&gt;️ 防御力:&lt;/span&gt;&#10;            &lt;span class=&quot;stat-value&quot;&gt;{{ enemy.defense }}&lt;/span&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;  &lt;/HurtAnimationWrapper&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import EffectDisplayBar from './EffectDisplayBar.vue';&#10;import HurtAnimationWrapper from './HurtAnimationWrapper.vue';&#10;import HealthBar from './HealthBar.vue';&#10;import Enemy from &quot;../data/enemy&quot;;&#10;&#10;export default {&#10;  name: 'EnemyStatusPanel',&#10;  components: {&#10;    EffectDisplayBar,&#10;    HurtAnimationWrapper,&#10;    HealthBar&#10;  },&#10;  props: {&#10;    enemy: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      enemyInfo: {&#10;        show: false,&#10;        x: 0,&#10;        y: 0&#10;      }&#10;    };&#10;  },&#10;  watch: {&#10;&#10;  },&#10;  methods: {&#10;    showEnemyInfo(event) {&#10;      // 获取相对于HurtAnimationWrapper的位置&#10;      const wrapper = this.$el.closest('.hurt-animation-wrapper');&#10;      if (wrapper) {&#10;        const wrapperRect = wrapper.getBoundingClientRect();&#10;        const buttonRect = event.target.getBoundingClientRect();&#10;        &#10;        // 计算相对于wrapper的位置&#10;        const relativeX = buttonRect.left - wrapperRect.left + 30;&#10;        const relativeY = buttonRect.top - wrapperRect.top - 10;&#10;        &#10;        this.enemyInfo = {&#10;          show: true,&#10;          x: relativeX,&#10;          y: relativeY&#10;        };&#10;      } else {&#10;        // 如果没有找到wrapper，使用绝对定位作为fallback&#10;        this.enemyInfo = {&#10;          show: true,&#10;          x: event.clientX + 20,&#10;          y: event.clientY - 10&#10;        };&#10;      }&#10;    },&#10;    &#10;    hideEnemyInfo() {&#10;      this.enemyInfo.show = false;&#10;    },&#10;    &#10;&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.enemy-status-panel {&#10;  display: flex;&#10;  align-items: center;&#10;  border: 1px solid #ccc;&#10;  border-radius: 8px;&#10;  background-color: #fff;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  z-index: 1;&#10;}&#10;&#10;.enemy-details {&#10;  padding-right: 20px;&#10;  padding-left: 20px;&#10;  min-width: 300px;&#10;  height: 230px;&#10;}&#10;&#10;.enemy-header {&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.enemy-avatar {&#10;  width: 350px;&#10;  height: 250px;&#10;}&#10;&#10;.avatar-image {&#10;  object-fit:cover;&#10;  width: inherit;&#10;  height: inherit;&#10;}&#10;&#10;.avatar-placeholder {&#10;  object-fit:cover;&#10;  width: inherit;&#10;  height: inherit;&#10;  background-color: #000;&#10;}&#10;&#10;.enemy-info-button {&#10;  cursor: pointer;&#10;  background-color: #f0f0f0;&#10;  border: 1px solid #ccc;&#10;  border-radius: 50%;&#10;  width: 24px;&#10;  height: 24px;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  font-weight: bold;&#10;  color: #666;&#10;  flex-shrink: 0;&#10;}&#10;&#10;.enemy-info-button:hover {&#10;  background-color: #e0e0e0;&#10;}&#10;&#10;.enemy-subtitle {&#10;  font-size: 14px;&#10;  color: #666;&#10;  font-weight: normal;&#10;}&#10;&#10;.enemy-stats {&#10;  display: flex;&#10;  gap: 20px;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.stat {&#10;  display: flex;&#10;  align-items: center;&#10;  margin-right: 15px;&#10;}&#10;&#10;.stat-label {&#10;  font-weight: bold;&#10;  margin-right: 5px;&#10;}&#10;&#10;.health-bar-container {&#10;  display: flex;&#10;  align-items: center;&#10;  gap: 10px;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.shield-display {&#10;  font-size: 16px;&#10;  font-weight: bold;&#10;  color: #1E90FF;&#10;  padding: 4px 8px;&#10;  background-color: rgba(30, 144, 255, 0.1);&#10;  border-radius: 4px;&#10;  border: 1px solid #1E90FF;&#10;  transition: transform 0.3s ease;&#10;}&#10;&#10;.shield-display.scale-animation {&#10;  animation: shield-pulse 0.3s ease;&#10;}&#10;&#10;@keyframes shield-pulse {&#10;  0% { transform: scale(1); }&#10;  50% { transform: scale(1.2); }&#10;  100% { transform: scale(1); }&#10;}&#10;&#10;.health-bar {&#10;  flex: 1;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.bar {&#10;  width: 100%;&#10;  height: 20px;&#10;  background-color: #f0f0f0;&#10;  border-radius: 10px;&#10;  overflow: hidden;&#10;  margin-top: 5px;&#10;}&#10;&#10;.fill {&#10;  height: 100%;&#10;  background-color: #f44336;&#10;  transition: width 0.3s ease;&#10;}&#10;&#10;.damage-text-container {&#10;  position: relative;&#10;  height: 0;&#10;  overflow: visible;&#10;  pointer-events: none;&#10;}&#10;&#10;.damage-text {&#10;  position: absolute;&#10;  font-weight: bold;&#10;  font-size: 24px;&#10;  pointer-events: none;&#10;  z-index: var(--z-tooltip);&#10;  animation: damageFloat 1s ease-out forwards;&#10;}&#10;&#10;@keyframes damageFloat {&#10;  0% {&#10;    opacity: 1;&#10;    transform: translateY(0);&#10;  }&#10;  100% {&#10;    opacity: 0;&#10;    transform: translateY(-50px);&#10;  }&#10;}&#10;&#10;/* 敌人信息悬浮框 */&#10;.enemy-info-tooltip {&#10;  position: absolute;&#10;  background-color: rgba(0, 0, 0, 0.9);&#10;  color: white;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  z-index: var(--z-tooltip);&#10;  min-width: 250px;&#10;  max-width: 400px;&#10;  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);&#10;  left: v-bind('enemyInfo.x + &quot;px&quot;');&#10;  top: v-bind('enemyInfo.y + &quot;px&quot;');&#10;}&#10;&#10;.enemy-info-content h3 {&#10;  margin-top: 0;&#10;  margin-bottom: 10px;&#10;  color: #ff6666;&#10;}&#10;&#10;.enemy-info-content p {&#10;  margin: 5px 0;&#10;  font-size: 0.9em;&#10;  line-height: 1.4;&#10;}&#10;&#10;.enemy-info-stats {&#10;  margin-top: 10px;&#10;  padding-top: 10px;&#10;  border-top: 1px solid #555;&#10;}&#10;&#10;.enemy-info-stats .stat {&#10;  margin-right: 20px;&#10;  margin-bottom: 5px;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/MessagePopupScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/MessagePopupScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;message-popup-container&quot;&gt;&#10;    &lt;transition-group name=&quot;message-popup&quot; tag=&quot;div&quot;&gt;&#10;      &lt;div &#10;        v-for=&quot;message in messages&quot; &#10;        :key=&quot;message.id&quot; &#10;        class=&quot;message-popup&quot;&#10;        :class=&quot;message.type&quot;&#10;      &gt;&#10;        {{ message.text }}&#10;      &lt;/div&gt;&#10;    &lt;/transition-group&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;export default {&#10;  name: 'MessagePopupScreen',&#10;  data() {&#10;    return {&#10;      messages: [],&#10;      messageId: 0&#10;    };&#10;  },&#10;  mounted() {&#10;    // 监听pop-message事件&#10;    frontendEventBus.on('pop-message', (message) =&gt; {&#10;      this.addMessage(message);&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    // 移除事件监听&#10;    frontendEventBus.off('pop-message');&#10;  },&#10;  methods: {&#10;    addMessage(message) {&#10;      const id = this.messageId++;&#10;      const newMessage = {&#10;        id,&#10;        text: message.text,&#10;        type: message.type || 'info', // 默认为info类型&#10;        duration: message.duration || 3000 // 默认持续3秒&#10;      };&#10;      &#10;      this.messages.push(newMessage);&#10;      &#10;      // 设置自动移除&#10;      setTimeout(() =&gt; {&#10;        this.removeMessage(id);&#10;      }, newMessage.duration);&#10;    },&#10;    removeMessage(id) {&#10;      const index = this.messages.findIndex(msg =&gt; msg.id === id);&#10;      if (index !== -1) {&#10;        this.messages.splice(index, 1);&#10;      }&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.message-popup-container {&#10;  position: fixed;&#10;  bottom: 20px;&#10;  left: 50%;&#10;  transform: translateX(-50%);&#10;  z-index: 1100; /* 高于DialogScreen的1000 */&#10;  display: flex;&#10;  flex-direction: column-reverse; /* 新消息显示在上面 */&#10;  align-items: center;&#10;  pointer-events: none; /* 防止阻挡其他元素的交互 */&#10;}&#10;&#10;.message-popup {&#10;  padding: 10px 20px;&#10;  margin: 5px 0;&#10;  border-radius: 5px;&#10;  color: white;&#10;  font-weight: bold;&#10;  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);&#10;  opacity: 0.9;&#10;  pointer-events: auto; /* 允许消息本身的交互 */&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.message-popup.info {&#10;  background-color: #2196F3; /* 蓝色 */&#10;}&#10;&#10;.message-popup.success {&#10;  background-color: #4CAF50; /* 绿色 */&#10;}&#10;&#10;.message-popup.warning {&#10;  background-color: #FF9800; /* 橙色 */&#10;}&#10;&#10;.message-popup.error {&#10;  background-color: #F44336; /* 红色 */&#10;}&#10;&#10;/* 进入和离开动画 */&#10;.message-popup-enter-active, .message-popup-leave-active {&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.message-popup-enter-from {&#10;  opacity: 0;&#10;  transform: translateY(20px);&#10;}&#10;&#10;.message-popup-leave-to {&#10;  opacity: 0;&#10;  transform: translateY(-20px);&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;message-popup-container&quot;&gt;&#10;    &lt;transition-group name=&quot;message-popup&quot; tag=&quot;div&quot;&gt;&#10;      &lt;div &#10;        v-for=&quot;message in messages&quot; &#10;        :key=&quot;message.id&quot; &#10;        class=&quot;message-popup&quot;&#10;        :class=&quot;message.type&quot;&#10;      &gt;&#10;        {{ message.text }}&#10;      &lt;/div&gt;&#10;    &lt;/transition-group&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;export default {&#10;  name: 'MessagePopupScreen',&#10;  data() {&#10;    return {&#10;      messages: [],&#10;      messageId: 0&#10;    };&#10;  },&#10;  mounted() {&#10;    // 监听pop-message事件&#10;    frontendEventBus.on('pop-message', (message) =&gt; {&#10;      this.addMessage(message);&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    // 移除事件监听&#10;    frontendEventBus.off('pop-message');&#10;  },&#10;  methods: {&#10;    addMessage(message) {&#10;      const id = this.messageId++;&#10;      const newMessage = {&#10;        id,&#10;        text: message.text,&#10;        type: message.type || 'info', // 默认为info类型&#10;        duration: message.duration || 3000 // 默认持续3秒&#10;      };&#10;      &#10;      this.messages.push(newMessage);&#10;      &#10;      // 设置自动移除&#10;      setTimeout(() =&gt; {&#10;        this.removeMessage(id);&#10;      }, newMessage.duration);&#10;    },&#10;    removeMessage(id) {&#10;      const index = this.messages.findIndex(msg =&gt; msg.id === id);&#10;      if (index !== -1) {&#10;        this.messages.splice(index, 1);&#10;      }&#10;    }&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.message-popup-container {&#10;  position: fixed;&#10;  bottom: 20px;&#10;  left: 50%;&#10;  transform: translateX(-50%);&#10;  z-index: var(--z-message);&#10;  display: flex;&#10;  flex-direction: column-reverse; /* 新消息显示在上面 */&#10;  align-items: center;&#10;  pointer-events: none; /* 防止阻挡其他元素的交互 */&#10;}&#10;&#10;.message-popup {&#10;  padding: 10px 20px;&#10;  margin: 5px 0;&#10;  border-radius: 5px;&#10;  color: white;&#10;  font-weight: bold;&#10;  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);&#10;  opacity: 0.9;&#10;  pointer-events: auto; /* 允许消息本身的交互 */&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.message-popup.info {&#10;  background-color: #2196F3; /* 蓝色 */&#10;}&#10;&#10;.message-popup.success {&#10;  background-color: #4CAF50; /* 绿色 */&#10;}&#10;&#10;.message-popup.warning {&#10;  background-color: #FF9800; /* 橙色 */&#10;}&#10;&#10;.message-popup.error {&#10;  background-color: #F44336; /* 红色 */&#10;}&#10;&#10;/* 进入和离开动画 */&#10;.message-popup-enter-active, .message-popup-leave-active {&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.message-popup-enter-from {&#10;  opacity: 0;&#10;  transform: translateY(20px);&#10;}&#10;&#10;.message-popup-leave-to {&#10;  opacity: 0;&#10;  transform: translateY(-20px);&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/NamedEntity.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/NamedEntity.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;span &#10;    class=&quot;named-entity&quot;&#10;    :style=&quot;{ color: entityColor }&quot;&#10;    @mouseenter=&quot;showTooltip&quot;&#10;    @mouseleave=&quot;hideTooltip&quot;&#10;  &gt;&#10;    {{ entityIcon }}&#10;    {{ entityName }}&#10;  &lt;/span&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import namedEntities from '../data/namedEntities.js';&#10;&#10;export default {&#10;  name: 'NamedEntity',&#10;  props: {&#10;    entityName: {&#10;      type: String,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      tooltip: {&#10;        show: false,&#10;        text: '',&#10;        name: '',&#10;        color: '',&#10;        x: 0,&#10;        y: 0&#10;      }&#10;    };&#10;  },&#10;  computed: {&#10;    entityInfo() {&#10;      return namedEntities[this.entityName] || {};&#10;    },&#10;    entityIcon() {&#10;      return this.entityInfo.icon || '❓';&#10;    },&#10;    entityColor() {&#10;      return this.entityInfo.color || '#000000';&#10;    },&#10;    entityDescription() {&#10;      return this.entityInfo.description || '未知实体';&#10;    },&#10;    entityDisplayName() {&#10;      return this.entityInfo.name || this.entityName;&#10;    }&#10;  },&#10;  methods: {&#10;    showTooltip(event) {&#10;      // 检查实体是否有描述信息&#10;      if (!this.entityInfo.description) return;&#10;      &#10;      // 获取实体名称和描述&#10;      const entityInfo = namedEntities[this.entityName] || {};&#10;      const entityDisplayName = entityInfo.name || this.entityName;&#10;      const entityDescription = entityInfo.description || '未知实体';&#10;      const entityColor = entityInfo.color || '#000000';&#10;      &#10;      // 设置tooltip内容，包含实体名称和描述&#10;      this.tooltip.text = entityDescription;&#10;      this.tooltip.name = entityDisplayName;&#10;      this.tooltip.color = entityColor;&#10;      this.tooltip.x = event.clientX;&#10;      this.tooltip.y = event.clientY;&#10;      &#10;      // 创建并显示tooltip元素&#10;      this.createTooltip();&#10;    },&#10;    hideTooltip() {&#10;      // 移除tooltip元素&#10;      this.removeTooltip();&#10;    },&#10;    createTooltip() {&#10;      // 移除已存在的tooltip&#10;      this.removeTooltip();&#10;      &#10;      // 创建tooltip元素&#10;      const tooltipElement = document.createElement('div');&#10;      tooltipElement.className = 'named-entity-tooltip';&#10;      tooltipElement.innerHTML = `&#10;        &lt;div class=&quot;tooltip-name&quot; style=&quot;color: ${this.tooltip.color}&quot;&gt;${this.tooltip.name}&lt;/div&gt;&#10;        &lt;div class=&quot;tooltip-description&quot;&gt;${this.tooltip.text}&lt;/div&gt;&#10;      `;&#10;      tooltipElement.style.left = this.tooltip.x + 'px';&#10;      tooltipElement.style.top = this.tooltip.y + 'px';&#10;      &#10;      // 添加到body中&#10;      document.body.appendChild(tooltipElement);&#10;      &#10;      // 保存引用以便后续移除&#10;      this.tooltip.element = tooltipElement;&#10;    },&#10;    removeTooltip() {&#10;      if (this.tooltip.element &amp;&amp; this.tooltip.element.parentNode) {&#10;        this.tooltip.element.parentNode.removeChild(this.tooltip.element);&#10;        this.tooltip.element = null;&#10;      }&#10;    }&#10;  },&#10;  beforeUnmount() {&#10;    // 组件销毁前移除tooltip&#10;    this.removeTooltip();&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.named-entity {&#10;  display: inline-block;&#10;  font-size: 16px;&#10;  cursor: help;&#10;  margin: 0 2px;&#10;  font-weight: bold;&#10;}&#10;&lt;/style&gt;&#10;&#10;&lt;style&gt;&#10;/* 全局样式，确保tooltip显示在最上层 */&#10;.named-entity-tooltip {&#10;  position: fixed;&#10;  background-color: rgba(0, 0, 0, 0.8);&#10;  color: white;&#10;  padding: 10px;&#10;  border-radius: 4px;&#10;  font-size: 14px;&#10;  z-index: 10000;&#10;  max-width: 300px;&#10;  word-wrap: break-word;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);&#10;}&#10;&#10;.named-entity-tooltip .tooltip-name {&#10;  font-weight: bold;&#10;  margin-bottom: 5px;&#10;  font-size: 16px;&#10;}&#10;&#10;.named-entity-tooltip .tooltip-description {&#10;  font-size: 14px;&#10;  color: white;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;span &#10;    class=&quot;named-entity&quot;&#10;    :style=&quot;{ color: entityColor }&quot;&#10;    @mouseenter=&quot;showTooltip&quot;&#10;    @mouseleave=&quot;hideTooltip&quot;&#10;  &gt;&#10;    {{ entityIcon }}&#10;    {{ entityName }}&#10;  &lt;/span&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import namedEntities from '../data/namedEntities.js';&#10;&#10;export default {&#10;  name: 'NamedEntity',&#10;  props: {&#10;    entityName: {&#10;      type: String,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      tooltip: {&#10;        show: false,&#10;        text: '',&#10;        name: '',&#10;        color: '',&#10;        x: 0,&#10;        y: 0&#10;      }&#10;    };&#10;  },&#10;  computed: {&#10;    entityInfo() {&#10;      return namedEntities[this.entityName] || {};&#10;    },&#10;    entityIcon() {&#10;      return this.entityInfo.icon || '❓';&#10;    },&#10;    entityColor() {&#10;      return this.entityInfo.color || '#000000';&#10;    },&#10;    entityDescription() {&#10;      return this.entityInfo.description || '未知实体';&#10;    },&#10;    entityDisplayName() {&#10;      return this.entityInfo.name || this.entityName;&#10;    }&#10;  },&#10;  methods: {&#10;    showTooltip(event) {&#10;      // 检查实体是否有描述信息&#10;      if (!this.entityInfo.description) return;&#10;      &#10;      // 获取实体名称和描述&#10;      const entityInfo = namedEntities[this.entityName] || {};&#10;      const entityDisplayName = entityInfo.name || this.entityName;&#10;      const entityDescription = entityInfo.description || '未知实体';&#10;      const entityColor = entityInfo.color || '#000000';&#10;      &#10;      // 设置tooltip内容，包含实体名称和描述&#10;      this.tooltip.text = entityDescription;&#10;      this.tooltip.name = entityDisplayName;&#10;      this.tooltip.color = entityColor;&#10;      this.tooltip.x = event.clientX;&#10;      this.tooltip.y = event.clientY;&#10;      &#10;      // 创建并显示tooltip元素&#10;      this.createTooltip();&#10;    },&#10;    hideTooltip() {&#10;      // 移除tooltip元素&#10;      this.removeTooltip();&#10;    },&#10;    createTooltip() {&#10;      // 移除已存在的tooltip&#10;      this.removeTooltip();&#10;      &#10;      // 创建tooltip元素&#10;      const tooltipElement = document.createElement('div');&#10;      tooltipElement.className = 'named-entity-tooltip';&#10;      tooltipElement.innerHTML = `&#10;        &lt;div class=&quot;tooltip-name&quot; style=&quot;color: ${this.tooltip.color}&quot;&gt;${this.tooltip.name}&lt;/div&gt;&#10;        &lt;div class=&quot;tooltip-description&quot;&gt;${this.tooltip.text}&lt;/div&gt;&#10;      `;&#10;      tooltipElement.style.left = this.tooltip.x + 'px';&#10;      tooltipElement.style.top = this.tooltip.y + 'px';&#10;      &#10;      // 添加到body中&#10;      document.body.appendChild(tooltipElement);&#10;      &#10;      // 保存引用以便后续移除&#10;      this.tooltip.element = tooltipElement;&#10;    },&#10;    removeTooltip() {&#10;      if (this.tooltip.element &amp;&amp; this.tooltip.element.parentNode) {&#10;        this.tooltip.element.parentNode.removeChild(this.tooltip.element);&#10;        this.tooltip.element = null;&#10;      }&#10;    }&#10;  },&#10;  beforeUnmount() {&#10;    // 组件销毁前移除tooltip&#10;    this.removeTooltip();&#10;  }&#10;};&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.named-entity {&#10;  display: inline-block;&#10;  font-size: 16px;&#10;  cursor: help;&#10;  margin: 0 2px;&#10;  font-weight: bold;&#10;}&#10;&lt;/style&gt;&#10;&#10;&lt;style&gt;&#10;/* 全局样式，确保tooltip在常规内容上方但低于特效/对话等 */&#10;.named-entity-tooltip {&#10;  position: fixed;&#10;  background-color: rgba(0, 0, 0, 0.8);&#10;  color: white;&#10;  padding: 10px;&#10;  border-radius: 4px;&#10;  font-size: 14px;&#10;  z-index: var(--z-tooltip);&#10;  max-width: 300px;&#10;  word-wrap: break-word;&#10;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);&#10;}&#10;&#10;.named-entity-tooltip .tooltip-name {&#10;  font-weight: bold;&#10;  margin-bottom: 5px;&#10;  font-size: 16px;&#10;}&#10;&#10;.named-entity-tooltip .tooltip-description {&#10;  font-size: 14px;&#10;  color: white;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/ParticleEffectManager.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/ParticleEffectManager.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;particle-effect-manager&quot;&gt;&#10;    &lt;div &#10;      v-for=&quot;particle in particles&quot; &#10;      :key=&quot;particle.id&quot;&#10;      class=&quot;particle&quot;&#10;      :style=&quot;getParticleStyle(particle)&quot;&#10;    &gt;&#10;      &lt;!-- 粒子文本 --&gt;&#10;      &lt;span v-if=&quot;particle.text&quot; class=&quot;particle-text&quot;&gt;{{ particle.text }}&lt;/span&gt;&#10;      &lt;!-- 粒子贴图 --&gt;&#10;      &lt;img v-if=&quot;particle.texture&quot; :src=&quot;particle.texture&quot; :style=&quot;getTextureStyle(particle)&quot; class=&quot;particle-texture&quot; /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js'&#10;&#10;export default {&#10;  name: 'ParticleEffectManager',&#10;  data() {&#10;    return {&#10;      particles: [],&#10;      nextId: 1,&#10;      animationFrameId: null&#10;    }&#10;  },&#10;  mounted() {&#10;    // 监听spawn-particles事件&#10;    frontendEventBus.on('spawn-particles', this.spawnParticles);&#10;&#10;    // 开始动画循环&#10;    this.animate();&#10;  },&#10;  beforeUnmount() {&#10;    // 清理事件监听&#10;    frontendEventBus.off('spawn-particles', this.spawnParticles);&#10;&#10;    // 取消动画循环&#10;    if (this.animationFrameId) {&#10;      cancelAnimationFrame(this.animationFrameId);&#10;    }&#10;  },&#10;  methods: {&#10;    /**&#10;     * 监听事件总线上的spawnParticles事件&#10;     * @param {Array} particles - 粒子数组&#10;     */&#10;    spawnParticles(particles) {&#10;      particles.forEach(particle =&gt; {&#10;        // 添加唯一ID和初始时间&#10;        particle.id = this.nextId++;&#10;        particle.startTime = performance.now();&#10;        particle.lastUpdateTime = performance.now();&#10;        &#10;        // 设置默认值&#10;        particle.x = particle.x || particle.absoluteX || 0;&#10;        particle.y = particle.y || particle.absoluteY || 0;&#10;        particle.vx = particle.vx || 0;&#10;        particle.vy = particle.vy || 0;&#10;        particle.life = particle.life || 1000; // 默认生命周期1秒&#10;        particle.gravity = particle.gravity || 0;&#10;        particle.customForce = particle.customForce || null; // 自定义受力函数&#10;        particle.customTrajectory = particle.customTrajectory || null; // 自定义轨迹函数&#10;        particle.size = particle.size || 5; // 默认大小&#10;        particle.opacity = particle.opacity !== undefined ? particle.opacity : 1; // 默认不透明度&#10;        particle.fadeIn = particle.fadeIn !== undefined ? particle.fadeIn : false; // 默认无fade in&#10;        particle.opacityFade = particle.opacityFade !== undefined ? particle.opacityFade : true; // 默认fade&#10;        particle.sizeFade = particle.sizeFade !== undefined ? particle.sizeFade : true; // 默认fade&#10;        particle.rotation = particle.rotation || 0; // 默认旋转角度&#10;        particle.drag = particle.drag !== undefined ? particle.drag : 0; // 默认drag为0&#10;        particle.zIndex = particle.zIndex !== undefined ? particle.zIndex : 1; // 默认z-index为1&#10;        particle.update = particle.update || null; // 自定义更新函数&#10;        particle.text = particle.text || null; // 文本内容，可以包含emoji&#10;        particle.texture = particle.texture || null; // 贴图&#10;        particle.extraStyles = particle.extraStyles || {}; // 额外样式&#10;        &#10;        // 添加到粒子数组&#10;        this.particles.push(particle);&#10;      });&#10;    },&#10;    &#10;    /**&#10;     * 动画循环&#10;     */&#10;    animate() {&#10;      const currentTime = performance.now();&#10;      &#10;      // 更新粒子&#10;      this.particles = this.particles.filter(particle =&gt; {&#10;        const elapsed = currentTime - particle.startTime;&#10;        const delta = currentTime - particle.lastUpdateTime;&#10;        particle.lastUpdateTime = currentTime;&#10;        &#10;        // 检查是否超过生命周期&#10;        if (elapsed &gt; particle.life) {&#10;          return false; // 移除粒子&#10;        }&#10;        &#10;        // 更新粒子状态&#10;        this.updateParticle(particle, currentTime, delta / 1000); // 转换为秒&#10;        &#10;        return true; // 保留粒子&#10;      });&#10;      &#10;      // 继续动画循环&#10;      this.animationFrameId = requestAnimationFrame(this.animate);&#10;    },&#10;    &#10;    /**&#10;     * 更新单个粒子的状态&#10;     * @param {Object} particle - 粒子对象&#10;     * @param {number} deltaTime - 间隔时间（秒）&#10;     */&#10;    updateParticle(particle, currentTime, deltaTime) {&#10;      // 如果有自定义轨迹函数，优先使用&#10;      if (typeof particle.customTrajectory === 'function') {&#10;        particle.customTrajectory(particle, deltaTime);&#10;      } else {&#10;        // 使用内置位置更新逻辑&#10;&#10;        // 应用自定义受力逻辑&#10;        if (typeof particle.customForce === 'function') {&#10;          const force = particle.customForce(particle, deltaTime);&#10;          particle.vx += force.x * deltaTime;&#10;          particle.vy += force.y * deltaTime;&#10;        }&#10;        &#10;        // 应用重力&#10;        particle.vy += particle.gravity * deltaTime;&#10;        &#10;        // 应用drag（阻力）&#10;        if (particle.drag &gt; 0) {&#10;          const dragFactor = Math.pow(Math.max(1 - particle.drag, 0.0001), deltaTime);&#10;          particle.vx *= dragFactor;&#10;          particle.vy *= dragFactor;&#10;        }&#10;        &#10;        // 更新位置&#10;        particle.x += particle.vx * deltaTime;&#10;        particle.y += particle.vy * deltaTime;&#10;      }&#10;&#10;      // 更新Opacity&#10;      if (particle.opacityFade) {&#10;        const elapsed = currentTime - particle.startTime;&#10;        const t = (particle.life - elapsed) / particle.life;&#10;        particle.opacity = particle.fadeIn ? (Math.min(1 - t, t) * 2) : (1 - t);&#10;      }&#10;      &#10;      // 更新其他属性（如大小、颜色、不透明度等）&#10;      if (particle.update) {&#10;        particle.update(particle, deltaTime);&#10;      }&#10;    },&#10;    &#10;    /**&#10;     * 获取粒子的样式&#10;     * @param {Object} particle - 粒子对象&#10;     * @returns {Object} 样式对象&#10;     */&#10;    getParticleStyle(particle) {&#10;      let fadedSize = particle.size;&#10;      if(particle.sizeFade) {&#10;        fadedSize *= (particle.life - (performance.now() - particle.startTime)) / particle.life;&#10;      }&#10;      const generatedStyles = {&#10;        position: 'absolute',&#10;        left: particle.x + 'px',&#10;        top: particle.y + 'px',&#10;        width: fadedSize + 'px',&#10;        height: fadedSize + 'px',&#10;        backgroundColor: particle.color || 'none',&#10;        opacity: particle.opacity,&#10;        transform: `rotate(${particle.rotation}deg)`,&#10;        zIndex: particle.zIndex&#10;      };&#10;      // 如果particle有extraStyles，合并到generatedStyles&#10;      if (particle.extraStyles) {&#10;        Object.assign(generatedStyles, particle.extraStyles);&#10;      }&#10;      return generatedStyles;&#10;    },&#10;    &#10;    /**&#10;     * 获取贴图的样式&#10;     * @param {Object} particle - 粒子对象&#10;     * @returns {Object} 样式对象&#10;     */&#10;    getTextureStyle(particle) {&#10;      return {&#10;        width: '100%',&#10;        height: '100%',&#10;        // 可以添加更多贴图样式属性&#10;      };&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.particle-effect-manager {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  pointer-events: none; /* 确保粒子不影响用户交互 */&#10;  z-index: 2; /* 设置较低的z-index，让技能卡片能够遮住粒子，但是不能低于Enemy和Player panel。 */&#10;  overflow: hidden; /* 防止粒子溢出 */&#10;}&#10;&#10;.particle {&#10;  position: absolute;&#10;  /* 其他样式在getParticleStyle中动态设置 */&#10;}&#10;&#10;.particle-text {&#10;  font-size: inherit;&#10;  line-height: 1;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  width: 100%;&#10;  height: 100%;&#10;}&#10;&#10;.particle-texture {&#10;  width: 100%;&#10;  height: 100%;&#10;  object-fit: contain;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;particle-effect-manager&quot;&gt;&#10;    &lt;div &#10;      v-for=&quot;particle in particles&quot; &#10;      :key=&quot;particle.id&quot;&#10;      class=&quot;particle&quot;&#10;      :style=&quot;getParticleStyle(particle)&quot;&#10;    &gt;&#10;      &lt;!-- 粒子文本 --&gt;&#10;      &lt;span v-if=&quot;particle.text&quot; class=&quot;particle-text&quot;&gt;{{ particle.text }}&lt;/span&gt;&#10;      &lt;!-- 粒子贴图 --&gt;&#10;      &lt;img v-if=&quot;particle.texture&quot; :src=&quot;particle.texture&quot; :style=&quot;getTextureStyle(particle)&quot; class=&quot;particle-texture&quot; /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import frontendEventBus from '../frontendEventBus.js'&#10;&#10;export default {&#10;  name: 'ParticleEffectManager',&#10;  data() {&#10;    return {&#10;      particles: [],&#10;      nextId: 1,&#10;      animationFrameId: null&#10;    }&#10;  },&#10;  mounted() {&#10;    // 监听spawn-particles事件&#10;    frontendEventBus.on('spawn-particles', this.spawnParticles);&#10;&#10;    // 开始动画循环&#10;    this.animate();&#10;  },&#10;  beforeUnmount() {&#10;    // 清理事件监听&#10;    frontendEventBus.off('spawn-particles', this.spawnParticles);&#10;&#10;    // 取消动画循环&#10;    if (this.animationFrameId) {&#10;      cancelAnimationFrame(this.animationFrameId);&#10;    }&#10;  },&#10;  methods: {&#10;    /**&#10;     * 监听事件总线上的spawnParticles事件&#10;     * @param {Array} particles - 粒子数组&#10;     */&#10;    spawnParticles(particles) {&#10;      particles.forEach(particle =&gt; {&#10;        // 添加唯一ID和初始时间&#10;        particle.id = this.nextId++;&#10;        particle.startTime = performance.now();&#10;        particle.lastUpdateTime = performance.now();&#10;        &#10;        // 设置默认值&#10;        particle.x = particle.x || particle.absoluteX || 0;&#10;        particle.y = particle.y || particle.absoluteY || 0;&#10;        particle.vx = particle.vx || 0;&#10;        particle.vy = particle.vy || 0;&#10;        particle.life = particle.life || 1000; // 默认生命周期1秒&#10;        particle.gravity = particle.gravity || 0;&#10;        particle.customForce = particle.customForce || null; // 自定义受力函数&#10;        particle.customTrajectory = particle.customTrajectory || null; // 自定义轨迹函数&#10;        particle.size = particle.size || 5; // 默认大小&#10;        particle.opacity = particle.opacity !== undefined ? particle.opacity : 1; // 默认不透明度&#10;        particle.fadeIn = particle.fadeIn !== undefined ? particle.fadeIn : false; // 默认无fade in&#10;        particle.opacityFade = particle.opacityFade !== undefined ? particle.opacityFade : true; // 默认fade&#10;        particle.sizeFade = particle.sizeFade !== undefined ? particle.sizeFade : true; // 默认fade&#10;        particle.rotation = particle.rotation || 0; // 默认旋转角度&#10;        particle.drag = particle.drag !== undefined ? particle.drag : 0; // 默认drag为0&#10;        particle.zIndex = particle.zIndex !== undefined ? particle.zIndex : 1; // 默认z-index为1&#10;        particle.update = particle.update || null; // 自定义更新函数&#10;        particle.text = particle.text || null; // 文本内容，可以包含emoji&#10;        particle.texture = particle.texture || null; // 贴图&#10;        particle.extraStyles = particle.extraStyles || {}; // 额外样式&#10;        &#10;        // 添加到粒子数组&#10;        this.particles.push(particle);&#10;      });&#10;    },&#10;    &#10;    /**&#10;     * 动画循环&#10;     */&#10;    animate() {&#10;      const currentTime = performance.now();&#10;      &#10;      // 更新粒子&#10;      this.particles = this.particles.filter(particle =&gt; {&#10;        const elapsed = currentTime - particle.startTime;&#10;        const delta = currentTime - particle.lastUpdateTime;&#10;        particle.lastUpdateTime = currentTime;&#10;        &#10;        // 检查是否超过生命周期&#10;        if (elapsed &gt; particle.life) {&#10;          return false; // 移除粒子&#10;        }&#10;        &#10;        // 更新粒子状态&#10;        this.updateParticle(particle, currentTime, delta / 1000); // 转换为秒&#10;        &#10;        return true; // 保留粒子&#10;      });&#10;      &#10;      // 继续动画循环&#10;      this.animationFrameId = requestAnimationFrame(this.animate);&#10;    },&#10;    &#10;    /**&#10;     * 更新单个粒子的状态&#10;     * @param {Object} particle - 粒子对象&#10;     * @param {number} deltaTime - 间隔时间（秒）&#10;     */&#10;    updateParticle(particle, currentTime, deltaTime) {&#10;      // 如果有自定义轨迹函数，优先使用&#10;      if (typeof particle.customTrajectory === 'function') {&#10;        particle.customTrajectory(particle, deltaTime);&#10;      } else {&#10;        // 使用内置位置更新逻辑&#10;&#10;        // 应用自定义受力逻辑&#10;        if (typeof particle.customForce === 'function') {&#10;          const force = particle.customForce(particle, deltaTime);&#10;          particle.vx += force.x * deltaTime;&#10;          particle.vy += force.y * deltaTime;&#10;        }&#10;        &#10;        // 应用重力&#10;        particle.vy += particle.gravity * deltaTime;&#10;        &#10;        // 应用drag（阻力）&#10;        if (particle.drag &gt; 0) {&#10;          const dragFactor = Math.pow(Math.max(1 - particle.drag, 0.0001), deltaTime);&#10;          particle.vx *= dragFactor;&#10;          particle.vy *= dragFactor;&#10;        }&#10;        &#10;        // 更新位置&#10;        particle.x += particle.vx * deltaTime;&#10;        particle.y += particle.vy * deltaTime;&#10;      }&#10;&#10;      // 更新Opacity&#10;      if (particle.opacityFade) {&#10;        const elapsed = currentTime - particle.startTime;&#10;        const t = (particle.life - elapsed) / particle.life;&#10;        particle.opacity = particle.fadeIn ? (Math.min(1 - t, t) * 2) : (1 - t);&#10;      }&#10;      &#10;      // 更新其他属性（如大小、颜色、不透明度等）&#10;      if (particle.update) {&#10;        particle.update(particle, deltaTime);&#10;      }&#10;    },&#10;    &#10;    /**&#10;     * 获取粒子的样式&#10;     * @param {Object} particle - 粒子对象&#10;     * @returns {Object} 样式对象&#10;     */&#10;    getParticleStyle(particle) {&#10;      let fadedSize = particle.size;&#10;      if(particle.sizeFade) {&#10;        fadedSize *= (particle.life - (performance.now() - particle.startTime)) / particle.life;&#10;      }&#10;      const generatedStyles = {&#10;        position: 'absolute',&#10;        left: particle.x + 'px',&#10;        top: particle.y + 'px',&#10;        width: fadedSize + 'px',&#10;        height: fadedSize + 'px',&#10;        backgroundColor: particle.color || 'none',&#10;        opacity: particle.opacity,&#10;        transform: `rotate(${particle.rotation}deg)`,&#10;        zIndex: particle.zIndex&#10;      };&#10;      // 如果particle有extraStyles，合并到generatedStyles&#10;      if (particle.extraStyles) {&#10;        Object.assign(generatedStyles, particle.extraStyles);&#10;      }&#10;      return generatedStyles;&#10;    },&#10;    &#10;    /**&#10;     * 获取贴图的样式&#10;     * @param {Object} particle - 粒子对象&#10;     * @returns {Object} 样式对象&#10;     */&#10;    getTextureStyle(particle) {&#10;      return {&#10;        width: '100%',&#10;        height: '100%',&#10;        // 可以添加更多贴图样式属性&#10;      };&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.particle-effect-manager {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  pointer-events: none; /* 确保粒子不影响用户交互 */&#10;  z-index: var(--z-particles);&#10;  overflow: hidden; /* 防止粒子溢出 */&#10;}&#10;&#10;.particle {&#10;  position: absolute;&#10;  /* 其他样式在getParticleStyle中动态设置 */&#10;}&#10;&#10;.particle-text {&#10;  font-size: inherit;&#10;  line-height: 1;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  width: 100%;&#10;  height: 100%;&#10;}&#10;&#10;.particle-texture {&#10;  width: 100%;&#10;  height: 100%;&#10;  object-fit: contain;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/RestScreen.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/RestScreen.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;rest-screen&quot; :class=&quot;{'remi-present-rest-screen': gameState.isRemiPresent}&quot;&gt;&#10;    &lt;div class=&quot;rest-screen-content&quot;&gt;&#10;      &lt;h1 class=&quot;rest-title&quot;&gt;{{ gameState.isRemiPresent ? '好好休息！' : '休整阶段'}}&lt;/h1&gt;&#10;      &#10;      &lt;div class=&quot;content-wrapper&quot;&gt;&#10;        &lt;!-- 左侧固定大小面板容器 --&gt;&#10;        &lt;div class=&quot;left-panel-container&quot;&gt;&#10;          &lt;!-- 金钱奖励面板 --&gt;&#10;          &lt;MoneyRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'money'&quot;&#10;            :amount=&quot;gameState.rewards.money&quot;&#10;            @claimed=&quot;onMoneyRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 突破奖励面板 --&gt;&#10;          &lt;BreakthroughRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'breakthrough'&quot;&#10;            @claimed=&quot;onBreakthroughRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 技能奖励面板 --&gt;&#10;          &lt;SkillRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'skill'&quot;&#10;            :skills=&quot;gameState.rewards.skills&quot;&#10;            @close=&quot;closeSkillRewardPanel&quot;&#10;            @selected-skill-reward=&quot;onSkillRewardSelected&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 能力奖励面板 --&gt;&#10;          &lt;AbilityRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'ability'&quot;&#10;            :abilities=&quot;gameState.rewards.abilities&quot;&#10;            @selected-ability-reward=&quot;onAbilityRewardSelected&quot;&#10;            @close=&quot;closeAbilityRewardPanel&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 商店面板 --&gt;&#10;          &lt;ShopPanel&#10;        :is-visible=&quot;currentRewardPanel === 'shop'&quot;&#10;        :shop-items=&quot;gameState.shopItems&quot;&#10;        :game-state=&quot;gameState&quot;&#10;        @close=&quot;closeShopPanel&quot;&#10;      /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;!-- 右侧玩家状态面板 --&gt;&#10;        &lt;PlayerStatusPanel :player=&quot;gameState.player&quot; :restScreen=&quot;true&quot;/&gt;&#10;      &lt;/div&gt;&#10;      &#10;      &lt;SkillSlotSelectionPanel&#10;        :is-visible=&quot;skillSlotSelectionPanelVisible&quot;&#10;        :skill-slots=&quot;gameState.player.skillSlots&quot;&#10;        :skill=&quot;claimingSkill&quot;&#10;        @select-slot=&quot;onSkillSlotSelected&quot;&#10;        @close=&quot;closeSkillSlotSelectionPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import AbilityRewardPanel from './AbilityRewardPanel.vue';&#10;import SkillRewardPanel from './SkillRewardPanel.vue';&#10;import SkillSlotSelectionPanel from './SkillSlotSelectionPanel.vue';&#10;import ShopPanel from './ShopPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import MoneyRewardPanel from './MoneyRewardPanel.vue';&#10;import BreakthroughRewardPanel from './BreakthroughRewardPanel.vue';&#10;import frontendEventBus from &quot;../frontendEventBus&quot;;&#10;import backendEventBus, { EventNames } from &quot;../backendEventBus&quot;;&#10;&#10;export default {&#10;  name: 'RestScreen',&#10;  components: {&#10;    ColoredText,&#10;    AbilityRewardPanel,&#10;    SkillRewardPanel,&#10;    SkillSlotSelectionPanel,&#10;    ShopPanel,&#10;    PlayerStatusPanel,&#10;    MoneyRewardPanel,&#10;    BreakthroughRewardPanel&#10;  },&#10;  props: {&#10;    gameState: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      currentRewardPanel: '', // 'money', 'breakthrough', 'skill', 'ability', 'shop' or empty&#10;      skillSlotSelectionPanelVisible: false,&#10;      claimingSkill: null,&#10;      rewardPanels: [],&#10;      currentRewardIndex: 0&#10;    }&#10;  },&#10;  mounted() {&#10;    // 初始化奖励面板队列&#10;    this.initRewardPanels();&#10;    // 显示第一个奖励面板&#10;    this.showNextRewardPanel();&#10;    // 监听后端商品购买，弹出UI消息&#10;    backendEventBus.on(EventNames.Shop.ITEM_PURCHASED, (purchasedItem) =&gt; {&#10;      frontendEventBus.emit(&quot;pop-message&quot;, {&#10;        id: 'item-purchased',&#10;        text: `购买了物品：${purchasedItem.name}`&#10;      });&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    backendEventBus.off &amp;&amp; backendEventBus.off(EventNames.Shop.ITEM_PURCHASED);&#10;  },&#10;  methods: {&#10;    initRewardPanels() {&#10;      this.rewardPanels = [];&#10;      &#10;      // 按顺序添加奖励面板&#10;      if (this.gameState.rewards.money &gt; 0) {&#10;        this.rewardPanels.push('money');&#10;      }&#10;      &#10;      if (this.gameState.rewards.breakthrough) {&#10;        this.rewardPanels.push('breakthrough');&#10;      }&#10;      &#10;      if (this.gameState.rewards.skills.length &gt; 0) {&#10;        this.rewardPanels.push('skill');&#10;      }&#10;      &#10;      if (this.gameState.rewards.abilities.length &gt; 0) {&#10;        this.rewardPanels.push('ability');&#10;      }&#10;      &#10;      // 总是添加商店面板&#10;      this.rewardPanels.push('shop'); &#10;    },&#10;    &#10;    showNextRewardPanel() {&#10;      // 先隐藏当前面板&#10;      this.currentRewardPanel = 'none';&#10;      // 稍等片刻后，再显示下一个面板&#10;      setTimeout(()=&gt; {&#10;        if (this.currentRewardIndex &lt; this.rewardPanels.length) {&#10;          this.currentRewardPanel = this.rewardPanels[this.currentRewardIndex];&#10;        } else {&#10;          // 所有奖励面板都已显示完毕&#10;          this.currentRewardPanel = '';&#10;        }&#10;      }, 500);&#10;    },&#10;    &#10;    onMoneyRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    onBreakthroughRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeSkillRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeAbilityRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;&#10;    onSkillRewardSelected(currentSkill) {&#10;      // 简化后的自动升级逻辑：如果奖励技能带有 upgradedFrom，直接替换来源技能&#10;      if(currentSkill.isUpgradeCandidate &amp;&amp; currentSkill.upgradedFrom) {&#10;        const slots = this.gameState.player.skillSlots;&#10;        const sourceSlotIndex = slots.findIndex(s =&gt; s &amp;&amp; s.name === currentSkill.upgradedFrom);&#10;        if(sourceSlotIndex !== -1) {&#10;          const oldSkill = slots[sourceSlotIndex];&#10;          backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;            skill: currentSkill,&#10;            slotIndex: sourceSlotIndex,&#10;            clearRewards: false&#10;          });&#10;          frontendEventBus.emit('pop-message', {&#10;            id: 'skill-upgraded',&#10;            text: `技能升级：${oldSkill.name} -&gt; ${currentSkill.name}`&#10;          });&#10;          this.closeSkillRewardPanel();&#10;          return;&#10;        }&#10;      }&#10;      // 回退：未能自动升级则进入槽位选择&#10;      this.claimingSkill = currentSkill;&#10;      setTimeout(() =&gt; { this.skillSlotSelectionPanelVisible = true; }, 300);&#10;    },&#10;    closeSkillSlotSelectionPanel() {&#10;      this.skillSlotSelectionPanelVisible = false;&#10;    },&#10;    onSkillSlotSelected(slotIndex) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;        skill: this.claimingSkill,&#10;        slotIndex,&#10;        clearRewards: false&#10;      });&#10;      // 关闭面板&#10;      this.closeSkillSlotSelectionPanel();&#10;      this.closeSkillRewardPanel();&#10;    },&#10;    onAbilityRewardSelected(ability) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_ABILITY, {&#10;        ability,&#10;        clearRewards: false&#10;      });&#10;      this.closeAbilityRewardPanel();&#10;    },&#10;    closeShopPanel() {&#10;      // 结束休整阶段，开始下一场战斗（后端流程监听）&#10;      backendEventBus.emit(EventNames.Rest.FINISH);&#10;    }&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.rest-screen {&#10;  height: 100%;&#10;  width: 100%;&#10;  background-size: cover;&#10;}&#10;&#10;.remi-present-rest-screen {&#10;  background-image: url('@assets/images/shop-background.png');&#10;}&#10;&#10;.rest-screen-content {&#10;  margin: 0 auto;&#10;  padding: 20px;&#10;  max-width: 1200px;&#10;}&#10;&#10;.content-wrapper {&#10;  display: flex;&#10;  flex-direction: row;&#10;  gap: 20px;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;}&#10;&#10;.rest-title {&#10;  font-size: 2em;&#10;  margin-bottom: 20px;&#10;  color: #eef7ff;&#10;}&#10;&#10;.left-panel-container {&#10;  width: 800px;&#10;  height: 220px;&#10;  position: relative;&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;rest-screen&quot; :class=&quot;{'remi-present-rest-screen': gameState.isRemiPresent}&quot;&gt;&#10;    &lt;div class=&quot;rest-screen-content&quot;&gt;&#10;      &lt;h1 class=&quot;rest-title&quot;&gt;{{ gameState.isRemiPresent ? '好好休息！' : '休整阶段'}}&lt;/h1&gt;&#10;      &#10;      &lt;div class=&quot;content-wrapper&quot;&gt;&#10;        &lt;!-- 左侧固定大小面板容器 --&gt;&#10;        &lt;div class=&quot;left-panel-container&quot;&gt;&#10;          &lt;!-- 金钱奖励面板 --&gt;&#10;          &lt;MoneyRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'money'&quot;&#10;            :amount=&quot;gameState.rewards.money&quot;&#10;            @claimed=&quot;onMoneyRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 突破奖励面板 --&gt;&#10;          &lt;BreakthroughRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'breakthrough'&quot;&#10;            @claimed=&quot;onBreakthroughRewardClaimed&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 技能奖励面板 --&gt;&#10;          &lt;SkillRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'skill'&quot;&#10;            :skills=&quot;gameState.rewards.skills&quot;&#10;            @close=&quot;closeSkillRewardPanel&quot;&#10;            @selected-skill-reward=&quot;onSkillRewardSelected&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 能力奖励面板 --&gt;&#10;          &lt;AbilityRewardPanel&#10;            :is-visible=&quot;currentRewardPanel === 'ability'&quot;&#10;            :abilities=&quot;gameState.rewards.abilities&quot;&#10;            @selected-ability-reward=&quot;onAbilityRewardSelected&quot;&#10;            @close=&quot;closeAbilityRewardPanel&quot;&#10;          /&gt;&#10;          &#10;          &lt;!-- 商店面板 --&gt;&#10;          &lt;ShopPanel&#10;        :is-visible=&quot;currentRewardPanel === 'shop'&quot;&#10;        :shop-items=&quot;gameState.shopItems&quot;&#10;        :game-state=&quot;gameState&quot;&#10;        @close=&quot;closeShopPanel&quot;&#10;      /&gt;&#10;        &lt;/div&gt;&#10;        &#10;        &lt;!-- 右侧玩家状态面板 --&gt;&#10;        &lt;PlayerStatusPanel :player=&quot;gameState.player&quot; :restScreen=&quot;true&quot;/&gt;&#10;      &lt;/div&gt;&#10;      &#10;      &lt;SkillSlotSelectionPanel&#10;        :is-visible=&quot;skillSlotSelectionPanelVisible&quot;&#10;        :skill-slots=&quot;gameState.player.skillSlots&quot;&#10;        :skill=&quot;claimingSkill&quot;&#10;        @select-slot=&quot;onSkillSlotSelected&quot;&#10;        @close=&quot;closeSkillSlotSelectionPanel&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import AbilityRewardPanel from './AbilityRewardPanel.vue';&#10;import SkillRewardPanel from './SkillRewardPanel.vue';&#10;import SkillSlotSelectionPanel from './SkillSlotSelectionPanel.vue';&#10;import ShopPanel from './ShopPanel.vue';&#10;import PlayerStatusPanel from './PlayerStatusPanel.vue';&#10;import MoneyRewardPanel from './MoneyRewardPanel.vue';&#10;import BreakthroughRewardPanel from './BreakthroughRewardPanel.vue';&#10;import frontendEventBus from &quot;../frontendEventBus&quot;;&#10;import backendEventBus, { EventNames } from &quot;../backendEventBus&quot;;&#10;&#10;export default {&#10;  name: 'RestScreen',&#10;  components: {&#10;    ColoredText,&#10;    AbilityRewardPanel,&#10;    SkillRewardPanel,&#10;    SkillSlotSelectionPanel,&#10;    ShopPanel,&#10;    PlayerStatusPanel,&#10;    MoneyRewardPanel,&#10;    BreakthroughRewardPanel&#10;  },&#10;  props: {&#10;    gameState: {&#10;      type: Object,&#10;      required: true&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      currentRewardPanel: '', // 'money', 'breakthrough', 'skill', 'ability', 'shop' or empty&#10;      skillSlotSelectionPanelVisible: false,&#10;      claimingSkill: null,&#10;      rewardPanels: [],&#10;      currentRewardIndex: 0&#10;    }&#10;  },&#10;  mounted() {&#10;    // 初始化奖励面板队列&#10;    this.initRewardPanels();&#10;    // 显示第一个奖励面板&#10;    this.showNextRewardPanel();&#10;    // 监听后端商品购买，弹出UI消息&#10;    backendEventBus.on(EventNames.Shop.ITEM_PURCHASED, (purchasedItem) =&gt; {&#10;      frontendEventBus.emit(&quot;pop-message&quot;, {&#10;        id: 'item-purchased',&#10;        text: `购买了物品：${purchasedItem.name}`&#10;      });&#10;    });&#10;  },&#10;  beforeUnmount() {&#10;    backendEventBus.off &amp;&amp; backendEventBus.off(EventNames.Shop.ITEM_PURCHASED);&#10;  },&#10;  methods: {&#10;    initRewardPanels() {&#10;      this.rewardPanels = [];&#10;      &#10;      // 按顺序添加奖励面板&#10;      if (this.gameState.rewards.money &gt; 0) {&#10;        this.rewardPanels.push('money');&#10;      }&#10;      &#10;      if (this.gameState.rewards.breakthrough) {&#10;        this.rewardPanels.push('breakthrough');&#10;      }&#10;      &#10;      if (this.gameState.rewards.skills.length &gt; 0) {&#10;        this.rewardPanels.push('skill');&#10;      }&#10;      &#10;      if (this.gameState.rewards.abilities.length &gt; 0) {&#10;        this.rewardPanels.push('ability');&#10;      }&#10;      &#10;      // 总是添加商店面板&#10;      this.rewardPanels.push('shop'); &#10;    },&#10;    &#10;    showNextRewardPanel() {&#10;      // 先隐藏当前面板&#10;      this.currentRewardPanel = 'none';&#10;      // 稍等片刻后，再显示下一个面板&#10;      setTimeout(()=&gt; {&#10;        if (this.currentRewardIndex &lt; this.rewardPanels.length) {&#10;          this.currentRewardPanel = this.rewardPanels[this.currentRewardIndex];&#10;        } else {&#10;          // 所有奖励面板都已显示完毕&#10;          this.currentRewardPanel = '';&#10;        }&#10;      }, 500);&#10;    },&#10;    &#10;    onMoneyRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    onBreakthroughRewardClaimed() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeSkillRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;    closeAbilityRewardPanel() {&#10;      this.currentRewardIndex++;&#10;      this.showNextRewardPanel();&#10;    },&#10;&#10;    onSkillRewardSelected(currentSkill) {&#10;      // 简化后的自动升级逻辑：如果奖励技能带有 upgradedFrom，直接替换来源技能&#10;      if(currentSkill.isUpgradeCandidate &amp;&amp; currentSkill.upgradedFrom) {&#10;        const slots = this.gameState.player.skillSlots;&#10;        const sourceSlotIndex = slots.findIndex(s =&gt; s &amp;&amp; s.name === currentSkill.upgradedFrom);&#10;        if(sourceSlotIndex !== -1) {&#10;          const oldSkill = slots[sourceSlotIndex];&#10;          backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;            skill: currentSkill,&#10;            slotIndex: sourceSlotIndex,&#10;            clearRewards: false&#10;          });&#10;          frontendEventBus.emit('pop-message', {&#10;            id: 'skill-upgraded',&#10;            text: `技能升级：${oldSkill.name} -&gt; ${currentSkill.name}`&#10;          });&#10;          this.closeSkillRewardPanel();&#10;          return;&#10;        }&#10;      }&#10;      // 回退：未能自动升级则进入槽位选择&#10;      this.claimingSkill = currentSkill;&#10;      setTimeout(() =&gt; { this.skillSlotSelectionPanelVisible = true; }, 300);&#10;    },&#10;    closeSkillSlotSelectionPanel() {&#10;      this.skillSlotSelectionPanelVisible = false;&#10;    },&#10;    onSkillSlotSelected(slotIndex) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_SKILL, {&#10;        skill: this.claimingSkill,&#10;        slotIndex,&#10;        clearRewards: false&#10;      });&#10;      // 关闭面板&#10;      this.closeSkillSlotSelectionPanel();&#10;      this.closeSkillRewardPanel();&#10;    },&#10;    onAbilityRewardSelected(ability) {&#10;      backendEventBus.emit(EventNames.Rest.CLAIM_ABILITY, {&#10;        ability,&#10;        clearRewards: false&#10;      });&#10;      this.closeAbilityRewardPanel();&#10;    },&#10;    closeShopPanel() {&#10;      // 结束休整阶段，开始下一场战斗（后端流程监听）&#10;      backendEventBus.emit(EventNames.Rest.FINISH);&#10;    }&#10;&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.rest-screen {&#10;  height: 100%;&#10;  width: 100%;&#10;  background-size: cover;&#10;}&#10;&#10;.remi-present-rest-screen {&#10;  background-image: url('@assets/images/shop-background.png');&#10;}&#10;&#10;.rest-screen-content {&#10;  margin: 0 auto;&#10;  padding: 20px;&#10;  max-width: 1200px;&#10;}&#10;&#10;.content-wrapper {&#10;  display: flex;&#10;  flex-direction: row;&#10;  gap: 20px;&#10;  justify-content: center;&#10;  align-items: flex-start;&#10;}&#10;&#10;.rest-title {&#10;  font-size: 2em;&#10;  margin-bottom: 20px;&#10;  color: #eef7ff;&#10;}&#10;&#10;.left-panel-container {&#10;  width: 800px;&#10;  height: 220px;&#10;  position: relative;&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SkillCard.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SkillCard.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div &#10;    :class=&quot;['skill-card', { disabled: disabled }]&quot;&#10;    @click=&quot;onClick&quot;&#10;    @mouseenter=&quot;onMouseEnter&quot;&#10;    @mouseleave=&quot;onMouseLeave&quot;&#10;    :style=&quot;skillCardStyle&quot;&#10;  &gt;&#10;    &lt;div class=&quot;skill-card-background-paper&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;skill-card-background-image&quot; :style=&quot;{backgroundImage:`url(${skillCardImageUrl})`}&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;upgrade-badge&quot; v-if=&quot;skill.isUpgradeCandidate&quot;&gt;升级&lt;/div&gt;&#10;    &lt;div&#10;      v-if=&quot;hovered &amp;&amp; skill.isUpgradeCandidate &amp;&amp; skill.upgradedFrom&quot;&#10;      class=&quot;upgrade-replace-tooltip&quot;&#10;    &gt;将替换：{{ skill.upgradedFrom }}&lt;/div&gt;&#10;    &lt;div class=&quot;mana-cost&quot; v-if=&quot;skill.manaCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;mana-icon&quot;&gt;&lt;/span&gt;&#10;      &lt;span class=&quot;mana-value&quot; :class=&quot;{ 'insufficient-mana': playerMana &lt; skill.manaCost }&quot;&gt;{{ skill.manaCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;action-cost&quot; v-if=&quot;skill.actionPointCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;action-icon&quot;&gt;⚡&lt;/span&gt;&#10;      &lt;span class=&quot;action-value&quot;&gt;{{ skill.actionPointCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;skill-tier&quot;&gt;{{ getSkillTierLabel(skill.tier) }}&lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-subtitle', {'hovered': hovered}]&quot; v-if=&quot;skill.subtitle&quot;&gt; {{skill.subtitle}} &lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-card-panel']&quot;&gt;&#10;      &lt;div class=&quot;skill-name&quot; :style=&quot;{color: skillNameColor, borderColor: skillBackgroundColor}&quot;&gt;&#10;        {{ skill.name + (skill.power &lt; 0 ? '（' + skill.power + '）' : '') + (skill.power &gt; 0 ? '（+' + skill.power + '）' : '') }}&lt;/div&gt;&#10;      &lt;div class=&quot;skill-description&quot;&gt;&#10;        &lt;ColoredText :text=&quot;skillDescription&quot; /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;skill-uses&quot;&gt;&#10;        &lt;ColoredText v-if=&quot;skill.coldDownTurns != 0 &amp;&amp; skill.remainingUses != skill.maxUses &amp;&amp; !previewMode&quot; :text=&quot;`/named{重整} ${skill.remainingColdDownTurns}/${skill.coldDownTurns}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.coldDownTurns != 0&quot; :text=&quot;`/named{重整} ${skill.coldDownTurns} 回合`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.remainingUses != Infinity&quot; :text=&quot;`/named{消耗}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;br /&gt;&#10;        &lt;strong v-if=&quot;skill.maxUses === Infinity &amp;&amp; skill.coldDownTurns == 0&quot;&gt;无限&lt;/strong&gt;&#10;        &lt;span v-else-if=&quot;previewMode&quot;&gt;(装填 {{ skill.maxUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;        &lt;span v-else&gt;(装填 {{ skill.remainingUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import {getSkillTierColor, getSkillTierLabel} from '../utils/tierUtils.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;&#10;export default {&#10;  name: 'SkillCard',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    skill: {&#10;      type: Object,&#10;      required: true&#10;    },&#10;    player: {&#10;      type: Object,&#10;      required: false,&#10;      default: null&#10;    },&#10;    disabled: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    playerMana: {&#10;      type: Number,&#10;      default: Infinity&#10;    },&#10;    previewMode: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      hovered: false,&#10;    };&#10;  },&#10;  computed: {&#10;    skillDescription() {&#10;      // 动态根据玩家/技能当前状态生成描述&#10;      if (this.player &amp;&amp; typeof this.skill?.regenerateDescription === 'function') {&#10;        return this.skill.regenerateDescription(this.player);&#10;      }&#10;      if (typeof this.skill?.getDescription === 'function') {&#10;        return this.skill.getDescription();&#10;      }&#10;      return this.skill?.description || '';&#10;    },&#10;    skillNameColor() {&#10;      if(this.skill.power &lt; 0) {&#10;        return 'red';&#10;      } else if(this.skill.power &gt; 0) {&#10;        return 'green';&#10;      } else {&#10;        return 'black';&#10;      }&#10;    },&#10;    skillCardStyle () {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      const backgroundColor = this.adjustColorBrightness(color, 40);&#10;      const borderColor = this.adjustColorBrightness(color, -40);&#10;      return {&#10;        backgroundColor: backgroundColor,&#10;        borderColor: borderColor&#10;      };&#10;    },&#10;    skillBackgroundColor() {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      return this.adjustColorBrightness(color, 50);&#10;    },&#10;    skillCardImageUrl () {&#10;      let imageName = this.skill.image;&#10;      if(imageName) {} else {&#10;        imageName = `0`;&#10;        if (this.skill.tier &gt;= 2) imageName = '1';&#10;        if (this.skill.tier &gt;= 4) imageName = '2';&#10;        if (this.skill.tier &gt;= 6) imageName = '3';&#10;        if (this.skill.tier &gt;= 8) imageName = '4';&#10;        imageName = `${this.skill.type}-${imageName}.png`;&#10;      }&#10;      return new URL(`../assets/cards/${imageName}`, import.meta.url).href;&#10;    }&#10;  },&#10;  mounted() {&#10;    // 不再监听update-skill-descriptions事件，改由computed自动更新&#10;  },&#10;  beforeUnmount() {&#10;    // 无事件需要移除&#10;  },&#10;  methods: {&#10;    getSkillTierLabel,&#10;    adjustColorBrightness(color, percent) {&#10;      // 移除可能存在的#号&#10;      let hex = color.replace(/#/g, '');&#10;&#10;      // 验证颜色格式是否正确&#10;      if (hex.length !== 6) {&#10;        throw new Error('无效的颜色格式，请使用6位十六进制颜色，如&quot;#AACC12&quot;');&#10;      }&#10;&#10;      // 将十六进制转换为RGB分量&#10;      let r = parseInt(hex.substring(0, 2), 16);&#10;      let g = parseInt(hex.substring(2, 4), 16);&#10;      let b = parseInt(hex.substring(4, 6), 16);&#10;&#10;      // 计算调整值（基于百分比）&#10;      const factor = percent / 100;&#10;&#10;      // 调整每个颜色分量的亮度&#10;      r = Math.round(r + (255 - r) * factor);&#10;      g = Math.round(g + (255 - g) * factor);&#10;      b = Math.round(b + (255 - b) * factor);&#10;&#10;      // 确保值在0-255范围内&#10;      r = Math.min(255, Math.max(0, r));&#10;      g = Math.min(255, Math.max(0, g));&#10;      b = Math.min(255, Math.max(0, b));&#10;&#10;      // 将RGB转回十六进制，并确保两位表示&#10;      const toHex = (c) =&gt; {&#10;        const hex = c.toString(16);&#10;        return hex.length === 1 ? '0' + hex : hex;&#10;      };&#10;&#10;      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();&#10;    },&#10;    onClick(event) {&#10;      if (!this.disabled) {&#10;        // 播放技能激活动画&#10;        this.playActivationAnimation();&#10;        &#10;        this.$emit('skill-card-clicked', this.skill, event);&#10;      }&#10;    },&#10;    &#10;    onMouseEnter() {&#10;      this.hovered = true;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-start', this.skill);&#10;    },&#10;    &#10;    onMouseLeave() {&#10;      this.hovered = false;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-end', this.skill);&#10;    },&#10;    // 播放技能激活动画&#10;    playActivationAnimation() {&#10;      const card = this.$el;&#10;      if (!card) return;&#10;      &#10;      // 根据技能tier确定动画强度&#10;      const tier = this.skill.tier || 0;&#10;      const intensity = 2;&#10;      &#10;      // 添加动画类&#10;      card.classList.add('activating');&#10;      &#10;      // 设置动画样式&#10;      card.style.animationDuration = `${0.25 / intensity}s`;&#10;      &#10;      // 播放粒子特效&#10;      this.playParticleEffect(tier, card);&#10;      &#10;      // 动画结束后清理&#10;      setTimeout(() =&gt; {&#10;        card.classList.remove('activating');&#10;        card.style.animationDuration = '';&#10;      }, 500 / intensity);&#10;    },&#10;    // 播放粒子特效&#10;    playParticleEffect(tier, card) {&#10;      // 根据tier确定粒子参数&#10;      const tierSettings = {&#10;        '-1': { count: 5, size: 3, color: '#333333' },   // curses&#10;        '0': { count: 15, size: 3, color: '#000000' },     // D&#10;        '1': { count: 20, size: 4, color: '#41db39' },     // C-&#10;        '2': { count: 30, size: 5, color: '#41db39' },    // C+&#10;        '3': { count: 40, size: 6, color: '#759eff' },    // B-&#10;        '4': { count: 50, size: 7, color: '#759eff' },    // B&#10;        '5': { count: 60, size: 8, color: '#d072ff' },    // B+&#10;        '6': { count: 60, size: 9, color: '#d072ff' },    // A-&#10;        '7': { count: 60, size: 10, color: '#ff9059' },   // A&#10;        '8': { count: 60, size: 11, color: '#ff9059' },   // A+&#10;        '9': { count: 60, size: 12, color: '#ff0000' }    // S&#10;      };&#10;      &#10;      const settings = tierSettings[tier] || tierSettings['0'];&#10;      &#10;      // 创建粒子数组&#10;      const particles = [];&#10;      &#10;      // 获取卡片的绝对位置&#10;      const cardRect = card.getBoundingClientRect();&#10;      &#10;      // 生成粒子&#10;      for (let i = 0; i &lt; settings.count; i++) {&#10;        // 随机运动方向和距离，确保粒子向四周逸散&#10;        const distance = 30 + Math.random() * 70; // 随机距离(30-100px)&#10;        const velocity = 10 + Math.random() * 20; // 随机速度&#10;        &#10;        // 计算卡牌边缘的随机起始位置（相对坐标）&#10;        const edge = Math.floor(Math.random() * 4); // 0:上, 1:右, 2:下, 3:左&#10;        let startX, startY;&#10;        &#10;        switch (edge) {&#10;          case 0: // 上边缘&#10;            startX = Math.random() * cardRect.width; // 使用实际卡片宽度&#10;            startY = 0;&#10;            break;&#10;          case 1: // 右边缘&#10;            startX = cardRect.width;&#10;            startY = Math.random() * cardRect.height; // 使用实际卡片高度&#10;            break;&#10;          case 2: // 下边缘&#10;            startX = Math.random() * cardRect.width;&#10;            startY = cardRect.height;&#10;            break;&#10;          case 3: // 左边缘&#10;            startX = 0;&#10;            startY = Math.random() * cardRect.height;&#10;            break;&#10;        }&#10;&#10;        // 计算飞离卡牌的方向&#10;        const deltaCenterX = startX - cardRect.width / 2;&#10;        const deltaCenterY = startY - cardRect.height / 2;&#10;        const angle = Math.random() * 0.2 + Math.atan2(deltaCenterY, deltaCenterX); // 随机角度&#10;        &#10;        // 将相对坐标转换为绝对坐标&#10;        const absoluteX = cardRect.left + startX;&#10;        const absoluteY = cardRect.top + startY;&#10;        &#10;        const particle = {&#10;          x: absoluteX, // 绝对位置&#10;          y: absoluteY, // 绝对位置&#10;          vx: Math.cos(angle) * velocity,&#10;          vy: Math.sin(angle) * velocity,&#10;          life: 1000, // 生命周期1秒&#10;          color: settings.color,&#10;          size: settings.size,&#10;          opacity: 1,&#10;          opacityFade: true,&#10;          gravity: 0, // 可以根据需要添加重力&#10;          zIndex: 0 // 刚好能被skill card panel遮住&#10;        };&#10;        &#10;        particles.push(particle);&#10;      }&#10;      &#10;      // 通过事件总线触发粒子特效&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-card-panel {&#10;  z-index: 1;&#10;  width: 150px;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 16px;&#10;  padding:2px;&#10;  border-radius: 8px;&#10;  border-width: 3px;&#10;  border-style: solid;&#10;  margin: 0 auto 8px auto;&#10;}&#10;&#10;.skill-description {&#10;  font-size: 14px;&#10;  margin-bottom: 8px;&#10;  text-align: center;&#10;}&#10;&#10;.skill-uses {&#10;  font-size: 12px;&#10;  color: #666;&#10;}&#10;&#10;.skill-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.mana-cost {&#10;  position: absolute;&#10;  top: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.mana-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.mana-value {&#10;  font-weight: bold;&#10;  color: #2196f3;&#10;  font-size: 16px;&#10;}&#10;&#10;.mana-value.insufficient-mana {&#10;  color: #f44336;&#10;}&#10;&#10;.action-cost {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.action-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.action-value {&#10;  font-weight: bold;&#10;  color: #ff9800;&#10;  font-size: 16px;&#10;}&#10;&#10;.skill-subtitle {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  right: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  color: rgba(200, 200, 200, 0.7);&#10;  font-size: 12px;&#10;  font-style: italic;&#10;  transition: 0.5s ease;&#10;}&#10;.skill-subtitle.hovered {&#10;  color: black;&#10;  background-color: rgba(255, 255, 255, 0.7);&#10;}&#10;&#10;.skill-card {&#10;  width: 192px;&#10;  height: 260px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  /* transition: all 0.3s ease; */&#10;  position: relative;&#10;  transition: all 0.3s ease;&#10;&#10;  border: 3px solid #eee;&#10;  border-radius: 5px;&#10;}&#10;&#10;.skill-card:hover {&#10;  transform: translateY(-2px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.skill-card.disabled {&#10;  filter: brightness(50%);&#10;  cursor: not-allowed;&#10;  transform: none;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;}&#10;&#10;/* 垫在skill-card上，用来铺上一个白色背景*/&#10;.skill-card-background-paper {&#10;  position: absolute;&#10;  width: 180px;&#10;  height: 240px;&#10;  background-color: white;&#10;}&#10;&#10;.skill-card-background-image {&#10;  position: absolute;&#10;  width: 212px;&#10;  height: 280px;&#10;  background-origin: content-box;&#10;  background-position: center;&#10;  background-repeat: no-repeat;&#10;  background-size: cover;&#10;}&#10;&#10;/* 技能激活动画关键帧 */&#10;@keyframes skillActivation {&#10;  0% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;  50% {&#10;    transform: scale(1.1);&#10;    box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);&#10;    filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;}&#10;&#10;.skill-card.activating {&#10;  z-index: 100;&#10;  animation-name: skillActivation;&#10;  animation-timing-function: ease-in-out;&#10;  animation-fill-mode: forwards;&#10;}&#10;&#10;.upgrade-badge {&#10;  position: absolute;&#10;  top: 4px;&#10;  left: 4px;&#10;  background: linear-gradient(135deg, #ffcc33, #ff8800);&#10;  color: #222;&#10;  font-weight: bold;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  font-size: 12px;&#10;  box-shadow: 0 0 4px rgba(0,0,0,0.4);&#10;  z-index: 2;&#10;}&#10;.upgrade-replace-tooltip {&#10;  position: absolute;&#10;  bottom: -6px;&#10;  left: 50%;&#10;  transform: translate(-50%, 100%);&#10;  background: rgba(255,255,255,0.95);&#10;  color: #222;&#10;  padding: 4px 8px;&#10;  border-radius: 6px;&#10;  font-size: 12px;&#10;  font-weight: 600;&#10;  white-space: nowrap;&#10;  box-shadow: 0 2px 6px rgba(0,0,0,0.25);&#10;  border: 1px solid #e0e0e0;&#10;  z-index: 10;&#10;  pointer-events: none;&#10;  animation: fadeIn 0.18s ease-out;&#10;}&#10;@keyframes fadeIn {&#10;  from { opacity: 0; transform: translate(-50%, 120%); }&#10;  to { opacity: 1; transform: translate(-50%, 100%); }&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div &#10;    :class=&quot;['skill-card', { disabled: disabled }]&quot;&#10;    @click=&quot;onClick&quot;&#10;    @mouseenter=&quot;onMouseEnter&quot;&#10;    @mouseleave=&quot;onMouseLeave&quot;&#10;    :style=&quot;skillCardStyle&quot;&#10;  &gt;&#10;    &lt;div class=&quot;skill-card-background-paper&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;skill-card-background-image&quot; :style=&quot;{backgroundImage:`url(${skillCardImageUrl})`}&quot;&gt;&lt;/div&gt;&#10;    &lt;div class=&quot;upgrade-badge&quot; v-if=&quot;skill.isUpgradeCandidate&quot;&gt;升级&lt;/div&gt;&#10;    &lt;div&#10;      v-if=&quot;hovered &amp;&amp; skill.isUpgradeCandidate &amp;&amp; skill.upgradedFrom&quot;&#10;      class=&quot;upgrade-replace-tooltip&quot;&#10;    &gt;将替换：{{ skill.upgradedFrom }}&lt;/div&gt;&#10;    &lt;div class=&quot;mana-cost&quot; v-if=&quot;skill.manaCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;mana-icon&quot;&gt;&lt;/span&gt;&#10;      &lt;span class=&quot;mana-value&quot; :class=&quot;{ 'insufficient-mana': playerMana &lt; skill.manaCost }&quot;&gt;{{ skill.manaCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;action-cost&quot; v-if=&quot;skill.actionPointCost &gt; 0&quot;&gt;&#10;      &lt;span class=&quot;action-icon&quot;&gt;⚡&lt;/span&gt;&#10;      &lt;span class=&quot;action-value&quot;&gt;{{ skill.actionPointCost }}&lt;/span&gt;&#10;    &lt;/div&gt;&#10;    &lt;div class=&quot;skill-tier&quot;&gt;{{ getSkillTierLabel(skill.tier) }}&lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-subtitle', {'hovered': hovered}]&quot; v-if=&quot;skill.subtitle&quot;&gt; {{skill.subtitle}} &lt;/div&gt;&#10;    &lt;div :class=&quot;['skill-card-panel']&quot;&gt;&#10;      &lt;div class=&quot;skill-name&quot; :style=&quot;{color: skillNameColor, borderColor: skillBackgroundColor}&quot;&gt;&#10;        {{ skill.name + (skill.power &lt; 0 ? '（' + skill.power + '）' : '') + (skill.power &gt; 0 ? '（+' + skill.power + '）' : '') }}&lt;/div&gt;&#10;      &lt;div class=&quot;skill-description&quot;&gt;&#10;        &lt;ColoredText :text=&quot;skillDescription&quot; /&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;skill-uses&quot;&gt;&#10;        &lt;ColoredText v-if=&quot;skill.coldDownTurns != 0 &amp;&amp; skill.remainingUses != skill.maxUses &amp;&amp; !previewMode&quot; :text=&quot;`/named{重整} ${skill.remainingColdDownTurns}/${skill.coldDownTurns}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.coldDownTurns != 0&quot; :text=&quot;`/named{重整} ${skill.coldDownTurns} 回合`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;ColoredText v-else-if=&quot;skill.remainingUses != Infinity&quot; :text=&quot;`/named{消耗}`&quot;&gt;&lt;/ColoredText&gt;&#10;        &lt;br /&gt;&#10;        &lt;strong v-if=&quot;skill.maxUses === Infinity &amp;&amp; skill.coldDownTurns == 0&quot;&gt;无限&lt;/strong&gt;&#10;        &lt;span v-else-if=&quot;previewMode&quot;&gt;(装填 {{ skill.maxUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;        &lt;span v-else&gt;(装填 {{ skill.remainingUses }}/{{ skill.maxUses }})&lt;/span&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import ColoredText from './ColoredText.vue';&#10;import {getSkillTierColor, getSkillTierLabel} from '../utils/tierUtils.js';&#10;import frontendEventBus from '../frontendEventBus.js';&#10;&#10;&#10;export default {&#10;  name: 'SkillCard',&#10;  components: {&#10;    ColoredText&#10;  },&#10;  props: {&#10;    skill: {&#10;      type: Object,&#10;      required: true&#10;    },&#10;    player: {&#10;      type: Object,&#10;      required: false,&#10;      default: null&#10;    },&#10;    disabled: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    playerMana: {&#10;      type: Number,&#10;      default: Infinity&#10;    },&#10;    previewMode: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    // 新增：当为 true 时，点击卡牌不触发本地 CSS 激活动画（交由全局 overlay/GSAP 处理）&#10;    suppressActivationAnimationOnClick: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  data() {&#10;    return {&#10;      hovered: false,&#10;    };&#10;  },&#10;  computed: {&#10;    skillDescription() {&#10;      // 动态根据玩家/技能当前状态生成描述&#10;      if (this.player &amp;&amp; typeof this.skill?.regenerateDescription === 'function') {&#10;        return this.skill.regenerateDescription(this.player);&#10;      }&#10;      if (typeof this.skill?.getDescription === 'function') {&#10;        return this.skill.getDescription();&#10;      }&#10;      return this.skill?.description || '';&#10;    },&#10;    skillNameColor() {&#10;      if(this.skill.power &lt; 0) {&#10;        return 'red';&#10;      } else if(this.skill.power &gt; 0) {&#10;        return 'green';&#10;      } else {&#10;        return 'black';&#10;      }&#10;    },&#10;    skillCardStyle () {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      const backgroundColor = this.adjustColorBrightness(color, 40);&#10;      const borderColor = this.adjustColorBrightness(color, -40);&#10;      return {&#10;        backgroundColor: backgroundColor,&#10;        borderColor: borderColor&#10;      };&#10;    },&#10;    skillBackgroundColor() {&#10;      const color = getSkillTierColor(this.skill.tier);&#10;      return this.adjustColorBrightness(color, 50);&#10;    },&#10;    skillCardImageUrl () {&#10;      let imageName = this.skill.image;&#10;      if(imageName) {} else {&#10;        imageName = `0`;&#10;        if (this.skill.tier &gt;= 2) imageName = '1';&#10;        if (this.skill.tier &gt;= 4) imageName = '2';&#10;        if (this.skill.tier &gt;= 6) imageName = '3';&#10;        if (this.skill.tier &gt;= 8) imageName = '4';&#10;        imageName = `${this.skill.type}-${imageName}.png`;&#10;      }&#10;      return new URL(`../assets/cards/${imageName}`, import.meta.url).href;&#10;    }&#10;  },&#10;  mounted() {&#10;    // 不再监听update-skill-descriptions事件，改由computed自动更新&#10;  },&#10;  beforeUnmount() {&#10;    // 无事件需要移除&#10;  },&#10;  methods: {&#10;    getSkillTierLabel,&#10;    adjustColorBrightness(color, percent) {&#10;      // 移除可能存在的#号&#10;      let hex = color.replace(/#/g, '');&#10;&#10;      // 验证颜色格式是否正确&#10;      if (hex.length !== 6) {&#10;        throw new Error('无效的颜色格式，请使用6位十六进制颜色，如&quot;#AACC12&quot;');&#10;      }&#10;&#10;      // 将十六进制转换为RGB分量&#10;      let r = parseInt(hex.substring(0, 2), 16);&#10;      let g = parseInt(hex.substring(2, 4), 16);&#10;      let b = parseInt(hex.substring(4, 6), 16);&#10;&#10;      // 计算调整值（基于百分比）&#10;      const factor = percent / 100;&#10;&#10;      // 调整每个颜色分量的亮度&#10;      r = Math.round(r + (255 - r) * factor);&#10;      g = Math.round(g + (255 - g) * factor);&#10;      b = Math.round(b + (255 - b) * factor);&#10;&#10;      // 确保值在0-255范围内&#10;      r = Math.min(255, Math.max(0, r));&#10;      g = Math.min(255, Math.max(0, g));&#10;      b = Math.min(255, Math.max(0, b));&#10;&#10;      // 将RGB转回十六进制，并确保两位表示&#10;      const toHex = (c) =&gt; {&#10;        const hex = c.toString(16);&#10;        return hex.length === 1 ? '0' + hex : hex;&#10;      };&#10;&#10;      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();&#10;    },&#10;    onClick(event) {&#10;      if (!this.disabled) {&#10;        // 仅当未开启抑制时才播放本地 CSS 激活动画&#10;        if (!this.suppressActivationAnimationOnClick) {&#10;          this.playActivationAnimation();&#10;        }&#10;        this.$emit('skill-card-clicked', this.skill, event);&#10;      }&#10;    },&#10;    &#10;    onMouseEnter() {&#10;      this.hovered = true;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-start', this.skill);&#10;    },&#10;    &#10;    onMouseLeave() {&#10;      this.hovered = false;&#10;      if (this.previewMode) return;&#10;      frontendEventBus.emit('skill-card-hover-end', this.skill);&#10;    },&#10;    // 播放技能激活动画&#10;    playActivationAnimation() {&#10;      const card = this.$el;&#10;      if (!card) return;&#10;      &#10;      // 根据技能tier确定动画强度&#10;      const tier = this.skill.tier || 0;&#10;      const intensity = 2;&#10;      &#10;      // 添加动画类&#10;      card.classList.add('activating');&#10;      &#10;      // 设置动画样式&#10;      card.style.animationDuration = `${0.25 / intensity}s`;&#10;      &#10;      // 播放粒子特效&#10;      this.playParticleEffect(tier, card);&#10;      &#10;      // 动画结束后清理&#10;      setTimeout(() =&gt; {&#10;        card.classList.remove('activating');&#10;        card.style.animationDuration = '';&#10;      }, 500 / intensity);&#10;    },&#10;    // 播放粒子特效&#10;    playParticleEffect(tier, card) {&#10;      // 根据tier确定粒子参数&#10;      const tierSettings = {&#10;        '-1': { count: 5, size: 3, color: '#333333' },   // curses&#10;        '0': { count: 15, size: 3, color: '#000000' },     // D&#10;        '1': { count: 20, size: 4, color: '#41db39' },     // C-&#10;        '2': { count: 30, size: 5, color: '#41db39' },    // C+&#10;        '3': { count: 40, size: 6, color: '#759eff' },    // B-&#10;        '4': { count: 50, size: 7, color: '#759eff' },    // B&#10;        '5': { count: 60, size: 8, color: '#d072ff' },    // B+&#10;        '6': { count: 60, size: 9, color: '#d072ff' },    // A-&#10;        '7': { count: 60, size: 10, color: '#ff9059' },   // A&#10;        '8': { count: 60, size: 11, color: '#ff9059' },   // A+&#10;        '9': { count: 60, size: 12, color: '#ff0000' }    // S&#10;      };&#10;      &#10;      const settings = tierSettings[tier] || tierSettings['0'];&#10;      &#10;      // 创建粒子数组&#10;      const particles = [];&#10;      &#10;      // 获取卡片的绝对位置&#10;      const cardRect = card.getBoundingClientRect();&#10;      &#10;      // 生成粒子&#10;      for (let i = 0; i &lt; settings.count; i++) {&#10;        // 随机运动方向和距离，确保粒子向四周逸散&#10;        const distance = 30 + Math.random() * 70; // 随机距离(30-100px)&#10;        const velocity = 10 + Math.random() * 20; // 随机速度&#10;        &#10;        // 计算卡牌边缘的随机起始位置（相对坐标）&#10;        const edge = Math.floor(Math.random() * 4); // 0:上, 1:右, 2:下, 3:左&#10;        let startX, startY;&#10;        &#10;        switch (edge) {&#10;          case 0: // 上边缘&#10;            startX = Math.random() * cardRect.width; // 使用实际卡片宽度&#10;            startY = 0;&#10;            break;&#10;          case 1: // 右边缘&#10;            startX = cardRect.width;&#10;            startY = Math.random() * cardRect.height; // 使用实际卡片高度&#10;            break;&#10;          case 2: // 下边缘&#10;            startX = Math.random() * cardRect.width;&#10;            startY = cardRect.height;&#10;            break;&#10;          case 3: // 左边缘&#10;            startX = 0;&#10;            startY = Math.random() * cardRect.height;&#10;            break;&#10;        }&#10;&#10;        // 计算飞离卡牌的方向&#10;        const deltaCenterX = startX - cardRect.width / 2;&#10;        const deltaCenterY = startY - cardRect.height / 2;&#10;        const angle = Math.random() * 0.2 + Math.atan2(deltaCenterY, deltaCenterX); // 随机角度&#10;        &#10;        // 将相对坐标转换为绝对坐标&#10;        const absoluteX = cardRect.left + startX;&#10;        const absoluteY = cardRect.top + startY;&#10;        &#10;        const particle = {&#10;          x: absoluteX, // 绝对位置&#10;          y: absoluteY, // 绝对位置&#10;          vx: Math.cos(angle) * velocity,&#10;          vy: Math.sin(angle) * velocity,&#10;          life: 1000, // 生命周期1秒&#10;          color: settings.color,&#10;          size: settings.size,&#10;          opacity: 1,&#10;          opacityFade: true,&#10;          gravity: 0, // 可以根据需要添加重力&#10;          zIndex: 0 // 刚好能被skill card panel遮住&#10;        };&#10;        &#10;        particles.push(particle);&#10;      }&#10;      &#10;      // 通过事件总线触发粒子特效&#10;      frontendEventBus.emit('spawn-particles', particles);&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-card-panel {&#10;  z-index: 1;&#10;  width: 150px;&#10;  padding: 15px;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 16px;&#10;  padding:2px;&#10;  border-radius: 8px;&#10;  border-width: 3px;&#10;  border-style: solid;&#10;  margin: 0 auto 8px auto;&#10;}&#10;&#10;.skill-description {&#10;  font-size: 14px;&#10;  margin-bottom: 8px;&#10;  text-align: center;&#10;}&#10;&#10;.skill-uses {&#10;  font-size: 12px;&#10;  color: #666;&#10;}&#10;&#10;.skill-tier {&#10;  position: absolute;&#10;  top: 5px;&#10;  right: 5px;&#10;  font-weight: bold;&#10;  font-size: 18px;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;}&#10;&#10;.mana-cost {&#10;  position: absolute;&#10;  top: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.mana-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.mana-value {&#10;  font-weight: bold;&#10;  color: #2196f3;&#10;  font-size: 16px;&#10;}&#10;&#10;.mana-value.insufficient-mana {&#10;  color: #f44336;&#10;}&#10;&#10;.action-cost {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  left: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  background-color: rgba(255, 255, 255, 0.8);&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;}&#10;&#10;.action-icon {&#10;  font-size: 16px;&#10;  margin-right: 4px;&#10;}&#10;&#10;.action-value {&#10;  font-weight: bold;&#10;  color: #ff9800;&#10;  font-size: 16px;&#10;}&#10;&#10;.skill-subtitle {&#10;  position: absolute;&#10;  bottom: 5px;&#10;  right: 5px;&#10;  display: flex;&#10;  align-items: center;&#10;  z-index: 2;&#10;  padding: 2px 6px;&#10;  color: rgba(200, 200, 200, 0.7);&#10;  font-size: 12px;&#10;  font-style: italic;&#10;  transition: 0.5s ease;&#10;}&#10;.skill-subtitle.hovered {&#10;  color: black;&#10;  background-color: rgba(255, 255, 255, 0.7);&#10;}&#10;&#10;.skill-card {&#10;  width: 192px;&#10;  height: 260px;&#10;  cursor: pointer;&#10;  display: flex;&#10;  flex-direction: column;&#10;  justify-content: center;&#10;  align-items: center;&#10;  /* transition: all 0.3s ease; */&#10;  position: relative;&#10;  transition: all 0.3s ease;&#10;&#10;  border: 3px solid #eee;&#10;  border-radius: 5px;&#10;}&#10;&#10;.skill-card:hover {&#10;  transform: translateY(-2px);&#10;  box-shadow: 0 4px 8px rgba(0,0,0,0.15);&#10;}&#10;&#10;.skill-card.disabled {&#10;  filter: brightness(50%);&#10;  cursor: not-allowed;&#10;  transform: none;&#10;  box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;}&#10;&#10;/* 垫在skill-card上，用来铺上一个白色背景*/&#10;.skill-card-background-paper {&#10;  position: absolute;&#10;  width: 180px;&#10;  height: 240px;&#10;  background-color: white;&#10;}&#10;&#10;.skill-card-background-image {&#10;  position: absolute;&#10;  width: 212px;&#10;  height: 280px;&#10;  background-origin: content-box;&#10;  background-position: center;&#10;  background-repeat: no-repeat;&#10;  background-size: cover;&#10;}&#10;&#10;/* 技能激活动画关键帧 */&#10;@keyframes skillActivation {&#10;  0% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;  50% {&#10;    transform: scale(1.1);&#10;    box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);&#10;    filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));&#10;  }&#10;  100% {&#10;    transform: scale(1);&#10;    box-shadow: 0 2px 4px rgba(0,0,0,0.1);&#10;  }&#10;}&#10;&#10;.skill-card.activating {&#10;  z-index: 100;&#10;  animation-name: skillActivation;&#10;  animation-timing-function: ease-in-out;&#10;  animation-fill-mode: forwards;&#10;}&#10;&#10;.upgrade-badge {&#10;  position: absolute;&#10;  top: 4px;&#10;  left: 4px;&#10;  background: linear-gradient(135deg, #ffcc33, #ff8800);&#10;  color: #222;&#10;  font-weight: bold;&#10;  padding: 2px 6px;&#10;  border-radius: 4px;&#10;  font-size: 12px;&#10;  box-shadow: 0 0 4px rgba(0,0,0,0.4);&#10;  z-index: 2;&#10;}&#10;.upgrade-replace-tooltip {&#10;  position: absolute;&#10;  bottom: -6px;&#10;  left: 50%;&#10;  transform: translate(-50%, 100%);&#10;  background: rgba(255,255,255,0.95);&#10;  color: #222;&#10;  padding: 4px 8px;&#10;  border-radius: 6px;&#10;  font-size: 12px;&#10;  font-weight: 600;&#10;  white-space: nowrap;&#10;  box-shadow: 0 2px 6px rgba(0,0,0,0.25);&#10;  border: 1px solid #e0e0e0;&#10;  z-index: 10;&#10;  pointer-events: none;&#10;  animation: fadeIn 0.18s ease-out;&#10;}&#10;@keyframes fadeIn {&#10;  from { opacity: 0; transform: translate(-50%, 120%); }&#10;  to { opacity: 1; transform: translate(-50%, 100%); }&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SkillRewardPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SkillRewardPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;skill-reward-panel-wrapper&quot;&gt;&#10;    &lt;div class=&quot;skill-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#10;      &lt;h2&gt;选择一个技能！&lt;/h2&gt;&#10;      &lt;div class=&quot;skill-cards&quot;&gt;&#10;        &lt;SkillCard&#10;          v-for=&quot;(skill, index) in skills&quot; &#10;          :key=&quot;'skill-' + index&quot;&#10;          :skill=&quot;skill&quot;&#10;          :preview-mode=&quot;true&quot;&#10;          @skill-card-clicked=&quot;onSkillCardClicked&quot;&#10;        /&gt;&#10;      &lt;/div&gt;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition-group&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import SkillCard from './SkillCard.vue';&#10;export default {&#10;  name: 'SkillRewardPanel',&#10;  components: {&#10;    SkillCard&#10;  },&#10;  props: {&#10;    skills: {&#10;      type: Array,&#10;      default: () =&gt; []&#10;    },&#10;    isVisible: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  methods: {&#10;    onSkillCardClicked(skill) {&#10;      this.$emit('selected-skill-reward', skill);&#10;    },&#10;    closePanel() {&#10;      this.$emit('close');&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-reward-panel {&#10;  border: 1px solid #4caf50; /* 绿色边框 */&#10;  padding: 20px;&#10;  background: linear-gradient(135deg, #e8f5e9, #c8e6c9); /* 绿色渐变背景 */&#10;  max-width: 80%;&#10;  margin: 20px auto;&#10;  box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);&#10;  border-radius: 8px;&#10;}&#10;&#10;.skill-reward-panel h2 {&#10;  text-align: center;&#10;  margin-bottom: 20px;&#10;  color: #2e7d32; /* 深绿色文字 */&#10;}&#10;&#10;.skill-cards {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 20px;&#10;  margin: 20px 0;&#10;  justify-content: center;&#10;}&#10;&#10;.skill-name {&#10;  font-weight: bold;&#10;  font-size: 1.2em;&#10;  margin-bottom: 10px;&#10;  color: #333;&#10;}&#10;&#10;.skill-description {&#10;  color: #666;&#10;  margin-bottom: 10px;&#10;}&#10;&#10;.skill-tier {&#10;  font-style: italic;&#10;  color: #999;&#10;}&#10;&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;  background-color: #4caf50; /* 绿色按钮 */&#10;  color: white;&#10;  border: none;&#10;  border-radius: 4px;&#10;}&#10;&#10;button:hover:not(:disabled) {&#10;  background-color: #43a047; /* 深一点的绿色 */&#10;}&#10;&#10;/* 滑动进入和退出动画 */&#10;.slide-enter-active, .slide-leave-active {&#10;  transition: all 0.5s ease;&#10;}&#10;&#10;.slide-enter-from {&#10;  transform: translateY(100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-leave-to {&#10;  transform: translateY(-100%);&#10;  opacity: 0;&#10;}&#10;&#10;.slide-enter-to, .slide-leave-from {&#10;  transform: translateY(0);&#10;  opacity: 1;&#10;}&#10;&#10;/* 为transition-group添加样式 */&#10;.skill-reward-panel-wrapper {&#10;  display: flex;&#10;  justify-content: center;&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;transition-group name=&quot;slide&quot; tag=&quot;div&quot; class=&quot;skill-reward-panel-wrapper&quot;&gt;&#13;&#10;    &lt;div class=&quot;skill-reward-panel&quot; v-if=&quot;isVisible&quot; key=&quot;panel&quot;&gt;&#13;&#10;      &lt;h2&gt;选择一个技能！&lt;/h2&gt;&#13;&#10;      &lt;div class=&quot;skill-cards&quot;&gt;&#13;&#10;        &lt;SkillCard&#13;&#10;          v-for=&quot;(skill, index) in skills&quot; &#13;&#10;          :key=&quot;skill.uniqueID&quot;&#13;&#10;          :skill=&quot;skill&quot;&#13;&#10;          :preview-mode=&quot;true&quot;&#13;&#10;          @skill-card-clicked=&quot;onSkillCardClicked&quot;&#13;&#10;        /&gt;&#13;&#10;      &lt;/div&gt;&#13;&#10;      &lt;button @click=&quot;closePanel&quot;&gt;放弃&lt;/button&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  &lt;/transition-group&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import SkillCard from './SkillCard.vue';&#13;&#10;export default {&#13;&#10;  name: 'SkillRewardPanel',&#13;&#10;  components: {&#13;&#10;    SkillCard&#13;&#10;  },&#13;&#10;  props: {&#13;&#10;    skills: {&#13;&#10;      type: Array,&#13;&#10;      default: () =&gt; []&#13;&#10;    },&#13;&#10;    isVisible: {&#13;&#10;      type: Boolean,&#13;&#10;      default: false&#13;&#10;    }&#13;&#10;  },&#13;&#10;  methods: {&#13;&#10;    onSkillCardClicked(skill) {&#13;&#10;      this.$emit('selected-skill-reward', skill);&#13;&#10;    },&#13;&#10;    closePanel() {&#13;&#10;      this.$emit('close');&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.skill-reward-panel {&#13;&#10;  border: 1px solid #4caf50; /* 绿色边框 */&#13;&#10;  padding: 20px;&#13;&#10;  background: linear-gradient(135deg, #e8f5e9, #c8e6c9); /* 绿色渐变背景 */&#13;&#10;  max-width: 80%;&#13;&#10;  margin: 20px auto;&#13;&#10;  box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);&#13;&#10;  border-radius: 8px;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-reward-panel h2 {&#13;&#10;  text-align: center;&#13;&#10;  margin-bottom: 20px;&#13;&#10;  color: #2e7d32; /* 深绿色文字 */&#13;&#10;}&#13;&#10;&#13;&#10;.skill-cards {&#13;&#10;  display: flex;&#13;&#10;  flex-wrap: wrap;&#13;&#10;  gap: 20px;&#13;&#10;  margin: 20px 0;&#13;&#10;  justify-content: center;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-name {&#13;&#10;  font-weight: bold;&#13;&#10;  font-size: 1.2em;&#13;&#10;  margin-bottom: 10px;&#13;&#10;  color: #333;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-description {&#13;&#10;  color: #666;&#13;&#10;  margin-bottom: 10px;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-tier {&#13;&#10;  font-style: italic;&#13;&#10;  color: #999;&#13;&#10;}&#13;&#10;&#13;&#10;button {&#13;&#10;  padding: 10px 15px;&#13;&#10;  margin: 5px;&#13;&#10;  cursor: pointer;&#13;&#10;  background-color: #4caf50; /* 绿色按钮 */&#13;&#10;  color: white;&#13;&#10;  border: none;&#13;&#10;  border-radius: 4px;&#13;&#10;}&#13;&#10;&#13;&#10;button:hover:not(:disabled) {&#13;&#10;  background-color: #43a047; /* 深一点的绿色 */&#13;&#10;}&#13;&#10;&#13;&#10;/* 滑动进入和退出动画 */&#13;&#10;.slide-enter-active, .slide-leave-active {&#13;&#10;  transition: all 0.5s ease;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-enter-from {&#13;&#10;  transform: translateY(100%);&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-leave-to {&#13;&#10;  transform: translateY(-100%);&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.slide-enter-to, .slide-leave-from {&#13;&#10;  transform: translateY(0);&#13;&#10;  opacity: 1;&#13;&#10;}&#13;&#10;&#13;&#10;/* 为transition-group添加样式 */&#13;&#10;.skill-reward-panel-wrapper {&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/SkillSlotSelectionPanel.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/SkillSlotSelectionPanel.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;transition name=&quot;overlay-fade&quot;&gt;&#10;    &lt;div class=&quot;skill-slot-selection-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#10;      &lt;transition name=&quot;panel-scale&quot;&gt;&#10;        &lt;div class=&quot;skill-slot-selection-panel&quot; v-if=&quot;isVisible&quot;&gt;&#10;          &lt;h2&gt;选择技能槽&lt;/h2&gt;&#10;          &lt;SkillCard&#10;          :skill=&quot;skill&quot;&#10;          :preview-mode=&quot;true&quot;&#10;          /&gt;&#10;          &lt;p&gt;选择一个技能槽来安装新技能&lt;/p&gt;&#10;          &lt;div class=&quot;skill-slots&quot;&gt;&#10;            &lt;SkillSlot&#10;              v-for=&quot;(slot, index) in skillSlots&quot;&#10;              :key=&quot;index&quot;&#10;              :skill=&quot;slot&quot;&#10;              :index=&quot;index&quot;&#10;              @slot-clicked=&quot;selectSlot&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;          &lt;button @click=&quot;closePanel&quot;&gt;取消&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/transition&gt;&#10;    &lt;/div&gt;&#10;  &lt;/transition&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import SkillSlot from './SkillSlot.vue';&#10;import SkillCard from './SkillCard.vue';&#10;&#10;export default {&#10;  name: 'SkillSlotSelectionPanel',&#10;  components: {&#10;    SkillSlot,&#10;    SkillCard&#10;  },&#10;  props: {&#10;    skill: {&#10;      type: Object,&#10;      default: null&#10;    },&#10;    skillSlots: {&#10;      type: Array,&#10;      required: true&#10;    },&#10;    isVisible: {&#10;      type: Boolean,&#10;      default: false&#10;    }&#10;  },&#10;  methods: {&#10;    selectSlot(index) {&#10;      this.$emit('select-slot', index);&#10;    },&#10;    closePanel() {&#10;      this.$emit('close');&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.skill-slot-selection-overlay {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  width: 100%;&#10;  height: 100%;&#10;  background-color: rgba(0, 0, 0, 0.5);&#10;  display: flex;&#10;  justify-content: center;&#10;  align-items: center;&#10;  z-index: 900; /* 确保在对话界面之下 */&#10;}&#10;&#10;.skill-slot-selection-panel {&#10;  border: 1px solid #ccc;&#10;  padding: 20px;&#10;  background-color: #f9f9f9;&#10;  max-width: 80%;&#10;  max-height: 80%;&#10;  overflow: visible;&#10;}&#10;&#10;.skill-slots {&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  gap: 20px;&#10;  margin: 20px 0;&#10;  justify-content: center;&#10;}&#10;&#10;button {&#10;  padding: 10px 15px;&#10;  margin: 5px;&#10;  cursor: pointer;&#10;}&#10;&#10;/* 覆盖层淡入淡出动画 */&#10;.overlay-fade-enter-active, .overlay-fade-leave-active {&#10;  transition: opacity 0.3s;&#10;}&#10;&#10;.overlay-fade-enter-from, .overlay-fade-leave-to {&#10;  opacity: 0;&#10;}&#10;&#10;.overlay-fade-enter-to, .overlay-fade-leave-from {&#10;  opacity: 1;&#10;}&#10;&#10;/* 面板缩放动画 */&#10;.panel-scale-enter-active, .panel-scale-leave-active {&#10;  transition: transform 0.3s;&#10;}&#10;&#10;.panel-scale-enter-from, .panel-scale-leave-to {&#10;  transform: scale(0.9);&#10;}&#10;&#10;.panel-scale-enter-to, .panel-scale-leave-from {&#10;  transform: scale(1);&#10;}&#10;&lt;/style&gt;" />
              <option name="updatedContent" value="&lt;template&gt;&#13;&#10;  &lt;transition name=&quot;overlay-fade&quot;&gt;&#13;&#10;    &lt;div class=&quot;skill-slot-selection-overlay&quot; v-if=&quot;isVisible&quot;&gt;&#13;&#10;      &lt;transition name=&quot;panel-scale&quot;&gt;&#13;&#10;        &lt;div class=&quot;skill-slot-selection-panel&quot; v-if=&quot;isVisible&quot;&gt;&#13;&#10;          &lt;h2&gt;选择技能槽&lt;/h2&gt;&#13;&#10;          &lt;SkillCard&#13;&#10;          :skill=&quot;skill&quot;&#13;&#10;          :preview-mode=&quot;true&quot;&#13;&#10;          /&gt;&#13;&#10;          &lt;p&gt;选择一个技能槽来安装新技能&lt;/p&gt;&#13;&#10;          &lt;div class=&quot;skill-slots&quot;&gt;&#13;&#10;            &lt;SkillSlot&#13;&#10;              v-for=&quot;(slot, index) in skillSlots&quot;&#13;&#10;              :key=&quot;index&quot;&#13;&#10;              :skill=&quot;slot&quot;&#13;&#10;              :index=&quot;index&quot;&#13;&#10;              @slot-clicked=&quot;selectSlot&quot;&#13;&#10;            /&gt;&#13;&#10;          &lt;/div&gt;&#13;&#10;          &lt;button @click=&quot;closePanel&quot;&gt;取消&lt;/button&gt;&#13;&#10;        &lt;/div&gt;&#13;&#10;      &lt;/transition&gt;&#13;&#10;    &lt;/div&gt;&#13;&#10;  &lt;/transition&gt;&#13;&#10;&lt;/template&gt;&#13;&#10;&#13;&#10;&lt;script&gt;&#13;&#10;import SkillSlot from './SkillSlot.vue';&#13;&#10;import SkillCard from './SkillCard.vue';&#13;&#10;&#13;&#10;export default {&#13;&#10;  name: 'SkillSlotSelectionPanel',&#13;&#10;  components: {&#13;&#10;    SkillSlot,&#13;&#10;    SkillCard&#13;&#10;  },&#13;&#10;  props: {&#13;&#10;    skill: {&#13;&#10;      type: Object,&#13;&#10;      default: null&#13;&#10;    },&#13;&#10;    skillSlots: {&#13;&#10;      type: Array,&#13;&#10;      required: true&#13;&#10;    },&#13;&#10;    isVisible: {&#13;&#10;      type: Boolean,&#13;&#10;      default: false&#13;&#10;    }&#13;&#10;  },&#13;&#10;  methods: {&#13;&#10;    selectSlot(index) {&#13;&#10;      this.$emit('select-slot', index);&#13;&#10;    },&#13;&#10;    closePanel() {&#13;&#10;      this.$emit('close');&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;&lt;/script&gt;&#13;&#10;&#13;&#10;&lt;style scoped&gt;&#13;&#10;.skill-slot-selection-overlay {&#13;&#10;  position: fixed;&#13;&#10;  top: 0;&#13;&#10;  left: 0;&#13;&#10;  width: 100%;&#13;&#10;  height: 100%;&#13;&#10;  background-color: rgba(0, 0, 0, 0.5);&#13;&#10;  display: flex;&#13;&#10;  justify-content: center;&#13;&#10;  align-items: center;&#13;&#10;  z-index: var(--z-overlay);&#13;&#10;}&#13;&#10;&#13;&#10;.skill-slot-selection-panel {&#13;&#10;  border: 1px solid #ccc;&#13;&#10;  padding: 20px;&#13;&#10;  background-color: #f9f9f9;&#13;&#10;  max-width: 80%;&#13;&#10;  max-height: 80%;&#13;&#10;  overflow: visible;&#13;&#10;}&#13;&#10;&#13;&#10;.skill-slots {&#13;&#10;  display: flex;&#13;&#10;  flex-wrap: wrap;&#13;&#10;  gap: 20px;&#13;&#10;  margin: 20px 0;&#13;&#10;  justify-content: center;&#13;&#10;}&#13;&#10;&#13;&#10;button {&#13;&#10;  padding: 10px 15px;&#13;&#10;  margin: 5px;&#13;&#10;  cursor: pointer;&#13;&#10;}&#13;&#10;&#13;&#10;/* 覆盖层淡入淡出动画 */&#13;&#10;.overlay-fade-enter-active, .overlay-fade-leave-active {&#13;&#10;  transition: opacity 0.3s;&#13;&#10;}&#13;&#10;&#13;&#10;.overlay-fade-enter-from, .overlay-fade-leave-to {&#13;&#10;  opacity: 0;&#13;&#10;}&#13;&#10;&#13;&#10;.overlay-fade-enter-to, .overlay-fade-leave-from {&#13;&#10;  opacity: 1;&#13;&#10;}&#13;&#10;&#13;&#10;/* 面板缩放动画 */&#13;&#10;.panel-scale-enter-active, .panel-scale-leave-active {&#13;&#10;  transition: transform 0.3s;&#13;&#10;}&#13;&#10;&#13;&#10;.panel-scale-enter-from, .panel-scale-leave-to {&#13;&#10;  transform: scale(0.9);&#13;&#10;}&#13;&#10;&#13;&#10;.panel-scale-enter-to, .panel-scale-leave-from {&#13;&#10;  transform: scale(1);&#13;&#10;}&#13;&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.js" />
              <option name="originalContent" value="import { createApp } from 'vue'&#10;import { createRouter, createWebHashHistory } from 'vue-router'&#10;import App from './App.vue'&#10;import GameApp from './GameApp.vue'&#10;import DebugApp from './DebugApp.vue'&#10;import TestEffectDisplay from './components/TestEffectDisplay.vue'&#10;import NamedEntityTest from './components/NamedEntityTest.vue'&#10;import './assets/main.css'&#10;import './assets/common.css'&#10;import SkillManager from './data/skillManager.js'&#10;import { initAnimationDispatcher } from './data/animationDispatcher.js'&#10;import {initGameFlowListeners} from &quot;./game&quot;;&#10;import AbilityManager from &quot;./data/abilityManager&quot;;&#10;&#10;// 创建路由&#10;const routes = [&#10;  { path: '/', component: GameApp },&#10;  { path: '/debug', component: DebugApp },&#10;  { path: '/test', component: TestEffectDisplay },&#10;  { path: '/named-test', component: NamedEntityTest }&#10;]&#10;&#10;const router = createRouter({&#10;  history: createWebHashHistory(),&#10;  routes&#10;})&#10;&#10;// 创建应用实例&#10;const app = createApp(App)&#10;&#10;// 使用路由&#10;app.use(router)&#10;&#10;// 初始化动画调度器（一次）&#10;initAnimationDispatcher();&#10;&#10;// 加载所有技能&#10;SkillManager.loadAllSkills().then(skillManager =&gt; {&#10;  // 将skillManager实例添加到全局属性中，以便在应用中使用&#10;  app.config.globalProperties.$skillManager = skillManager;&#10;&#10;  // 加载所有ability&#10;  AbilityManager.loadAllAbilities().then(abilityManager =&gt; {&#10;    app.config.globalProperties.$abilityManager = abilityManager;&#10;    app.mount('#app');&#10;  });&#10;  // 挂载应用&#10;});&#10;&#10;&#10;// 初始化后端游戏流程在backendEventBus上的监听器&#10;initGameFlowListeners();" />
              <option name="updatedContent" value="import { createApp } from 'vue'&#13;&#10;import { createRouter, createWebHashHistory } from 'vue-router'&#13;&#10;import App from './App.vue'&#13;&#10;import GameApp from './GameApp.vue'&#13;&#10;import DebugApp from './DebugApp.vue'&#13;&#10;import TestEffectDisplay from './components/TestEffectDisplay.vue'&#13;&#10;import NamedEntityTest from './components/NamedEntityTest.vue'&#13;&#10;import './assets/main.css'&#13;&#10;import './assets/common.css'&#13;&#10;import './assets/zLayers.css'&#13;&#10;import SkillManager from './data/skillManager.js'&#13;&#10;import { initAnimationDispatcher } from './data/animationDispatcher.js'&#13;&#10;import {initGameFlowListeners} from &quot;./game&quot;;&#13;&#10;import AbilityManager from &quot;./data/abilityManager&quot;;&#13;&#10;&#13;&#10;// 创建路由&#13;&#10;const routes = [&#13;&#10;  { path: '/', component: GameApp },&#13;&#10;  { path: '/debug', component: DebugApp },&#13;&#10;  { path: '/test', component: TestEffectDisplay },&#13;&#10;  { path: '/named-test', component: NamedEntityTest }&#13;&#10;]&#13;&#10;&#13;&#10;const router = createRouter({&#13;&#10;  history: createWebHashHistory(),&#13;&#10;  routes&#13;&#10;})&#13;&#10;&#13;&#10;// 创建应用实例&#13;&#10;const app = createApp(App)&#13;&#10;&#13;&#10;// 使用路由&#13;&#10;app.use(router)&#13;&#10;&#13;&#10;// 初始化动画调度器（一次）&#13;&#10;initAnimationDispatcher();&#13;&#10;&#13;&#10;// 加载所有技能&#13;&#10;SkillManager.loadAllSkills().then(skillManager =&gt; {&#13;&#10;  // 将skillManager实例添加到全局属性中，以便在应用中使用&#13;&#10;  app.config.globalProperties.$skillManager = skillManager;&#13;&#10;&#13;&#10;  // 加载所有ability&#13;&#10;  AbilityManager.loadAllAbilities().then(abilityManager =&gt; {&#13;&#10;    app.config.globalProperties.$abilityManager = abilityManager;&#13;&#10;    app.mount('#app');&#13;&#10;  });&#13;&#10;  // 挂载应用&#13;&#10;});&#13;&#10;&#13;&#10;&#13;&#10;// 初始化后端游戏流程在backendEventBus上的监听器&#13;&#10;initGameFlowListeners();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/utils/animationOrchestrator.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/utils/animationOrchestrator.js" />
              <option name="originalContent" value="// 全局动画编排器（DOM + GSAP）&#10;// 职责：&#10;// - 初始化 overlay/anchors/ghost 容器引用&#10;// - 生成“幽灵”克隆元素并用 transform 动画&#10;// - 提供卡牌动画原语（飞行/渐隐/旋转/缩放等）与常用序列助手&#10;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import gsap from 'gsap';&#10;&#10;const defaultEase = 'power2.out';&#10;&#10;const orchestrator = {&#10;  overlayEl: null,&#10;  centerAnchorEl: null,&#10;  deckAnchorEl: null,&#10;  ghostContainerEl: null,&#10;&#10;  init({ overlayEl, centerAnchorEl, deckAnchorEl, ghostContainerEl }) {&#10;    this.overlayEl = overlayEl;&#10;    this.centerAnchorEl = centerAnchorEl;&#10;    this.deckAnchorEl = deckAnchorEl;&#10;    this.ghostContainerEl = ghostContainerEl;&#10;  },&#10;&#10;  // 工具：测量/克隆/计算&#10;  getRect(el) { return el?.getBoundingClientRect?.() || null; },&#10;  getAnchor(nameOrEl) {&#10;    if (!nameOrEl) return null;&#10;    if (typeof nameOrEl === 'string') {&#10;      if (nameOrEl === 'center') return this.centerAnchorEl;&#10;      if (nameOrEl === 'deck') return this.deckAnchorEl;&#10;      return null;&#10;    }&#10;    return nameOrEl;&#10;  },&#10;  getAnchorPoint(nameOrEl) {&#10;    const el = this.getAnchor(nameOrEl);&#10;    const r = this.getRect(el);&#10;    if (!r) return { x: window.innerWidth / 2, y: window.innerHeight / 2 };&#10;    return { x: r.left, y: r.top };&#10;  },&#10;  createGhostFromEl(startEl, startRect) {&#10;    if (!this.ghostContainerEl || !startEl || !startRect) return null;&#10;    const ghost = startEl.cloneNode(true);&#10;    Object.assign(ghost.style, {&#10;      position: 'absolute',&#10;      left: `${startRect.left}px`,&#10;      top: `${startRect.top}px`,&#10;      width: `${startRect.width}px`,&#10;      height: `${startRect.height}px`,&#10;      margin: '0',&#10;      transformOrigin: 'center center',&#10;      pointerEvents: 'none',&#10;    });&#10;    ghost.classList.add('animation-ghost');&#10;    this.ghostContainerEl.appendChild(ghost);&#10;    // 初始化transform基线，确保x/y可用&#10;    gsap.set(ghost, { x: 0, y: 0, force3D: true });&#10;    return ghost;&#10;  },&#10;  // 将屏幕点作为“卡牌中心”目标，换算为 transform x/y&#10;  offsetsToPoint(startRect, point) {&#10;    return {&#10;      x: point.x - startRect.left - startRect.width / 2,&#10;      y: point.y - startRect.top - startRect.height / 2&#10;    };&#10;  },&#10;&#10;  // 原语：对幽灵元素进行一次 tween（支持 x/y/scale/rotate/opacity 按段配置）&#10;  tweenGhost(ghost, props = {}, durationMs = 350, ease = defaultEase) {&#10;    const tweenProps = { ...props };&#10;    if (typeof tweenProps.opacity === 'number') tweenProps.autoAlpha = tweenProps.opacity;&#10;    delete tweenProps.opacity;&#10;    return gsap.to(ghost, { duration: Math.max(0.001, durationMs / 1000), ease, ...tweenProps });&#10;  },&#10;&#10;  // 高阶：按 steps 顺序执行动画（steps 支持 toPoint/toAnchor/delta/scale/rotate/opacity/holdMs）&#10;  async playCardSequence(startEl, steps = [], { hideStart = true } = {}) {&#10;    if (!startEl || !this.overlayEl) return;&#10;    const startRect = this.getRect(startEl);&#10;    if (!startRect) return;&#10;&#10;    const ghost = this.createGhostFromEl(startEl, startRect);&#10;    if (hideStart) { try { startEl.style.visibility = 'hidden'; } catch (_) {} }&#10;&#10;    const finish = () =&gt; {&#10;      try { ghost.remove(); } catch (_) {}&#10;      if (hideStart) { try { startEl.style.visibility = ''; } catch (_) {} }&#10;    };&#10;&#10;    const tl = gsap.timeline({ onComplete: finish });&#10;&#10;    for (const step of steps) {&#10;      const { duration = 350, ease = defaultEase, holdMs = 0 } = step;&#10;      const props = {};&#10;      if (step.toPoint) {&#10;        const o = this.offsetsToPoint(startRect, step.toPoint);&#10;        props.x = o.x; props.y = o.y;&#10;      } else if (step.toAnchor) {&#10;        const p = this.getAnchorPoint(step.toAnchor);&#10;        const o = this.offsetsToPoint(startRect, p);&#10;        props.x = o.x; props.y = o.y;&#10;      } else if (step.delta) {&#10;        // 相对位移：在已有 transform 基础上叠加（用 &quot;+=&quot;写法）&#10;        props.x = `+=${step.delta.dx || 0}`;&#10;        props.y = `+=${step.delta.dy || 0}`;&#10;      }&#10;      if (typeof step.scale === 'number') props.scale = step.scale;&#10;      if (typeof step.rotate === 'number') props.rotate = step.rotate;&#10;      if (typeof step.opacity === 'number') props.autoAlpha = step.opacity;&#10;&#10;      // tween&#10;      tl.to(ghost, { ...props, duration: Math.max(0.001, duration / 1000), ease });&#10;      // hold（使用 x:'+=0' 作为无变化 tween，保证时间线前进）&#10;      if (holdMs &gt; 0) tl.to(ghost, { x: '+=0', duration: holdMs / 1000, ease: 'none' });&#10;    }&#10;&#10;    await new Promise(resolve =&gt; {&#10;      tl.eventCallback('onComplete', () =&gt; { finish(); resolve(); });&#10;      tl.play(0);&#10;    });&#10;  },&#10;&#10;  // 常用序列助手&#10;  async seqFlyToCenter(startEl, { scale = 1.2, durationMs = 350, holdMs = 0 } = {}) {&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'center', scale, duration: durationMs, ease: 'power2.out', holdMs }&#10;    ]);&#10;  },&#10;  async seqCastAtCenter(startEl, { pulseScale = 1.35, pulseMs = 220, repeats = 1 } = {}) {&#10;    const steps = [];&#10;    for (let i = 0; i &lt; repeats; i++) {&#10;      steps.push({ scale: pulseScale, duration: pulseMs, ease: 'power2.out' });&#10;      steps.push({ scale: 1.2, duration: pulseMs, ease: 'power2.in' });&#10;    }&#10;    return this.playCardSequence(startEl, steps, { hideStart: false });&#10;  },&#10;  async seqFlyToDeckFade(startEl, { durationMs = 400 } = {}) {&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'deck', scale: 0.5, rotate: 20, duration: durationMs, ease: 'power2.in' },&#10;      { opacity: 0, duration: 120 }&#10;    ]);&#10;  },&#10;  async seqPlayToCenterThenDeck(startEl, { centerHoldMs = 350, totalMs = 900 } = {}) {&#10;    const first = 350;&#10;    const rest = Math.max(300, totalMs - first - centerHoldMs);&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'center', scale: 1.2, duration: first, ease: 'power2.out', holdMs: centerHoldMs },&#10;      { toAnchor: 'deck', scale: 0.5, rotate: 20, duration: rest, ease: 'power2.in' }&#10;    ]);&#10;  },&#10;&#10;  // 兼容旧接口&#10;  async flyCardToCenterThenToDeck({ startEl, hideStart = true, centerScale = 1.2, centerHoldMs = 350, totalMs = 900 }) {&#10;    return this.seqPlayToCenterThenDeck(startEl, { centerHoldMs, totalMs });&#10;  }&#10;};&#10;&#10;// 事件总线桥接：允许外部直接通过事件触发原语或序列&#10;frontendEventBus.on('animate-card-play', async (payload = {}) =&gt; {&#10;  try {&#10;    const el = payload.el || null;&#10;    if (!el) return;&#10;    if (Array.isArray(payload.steps) &amp;&amp; payload.steps.length) {&#10;      await orchestrator.playCardSequence(el, payload.steps, { hideStart: payload.hideStart !== false });&#10;    } else if (payload.kind === 'centerThenDeck') {&#10;      await orchestrator.seqPlayToCenterThenDeck(el, payload.options || {});&#10;    } else if (payload.kind === 'flyToCenter') {&#10;      await orchestrator.seqFlyToCenter(el, payload.options || {});&#10;    } else if (payload.kind === 'flyToDeckFade') {&#10;      await orchestrator.seqFlyToDeckFade(el, payload.options || {});&#10;    } else {&#10;      await orchestrator.seqPlayToCenterThenDeck(el, {});&#10;    }&#10;  } catch (_) {&#10;    console.log(_);&#10;  }&#10;});&#10;&#10;export default orchestrator;&#10;" />
              <option name="updatedContent" value="// 全局动画编排器（DOM + GSAP）&#10;// 职责：&#10;// - 初始化 overlay/anchors/ghost 容器引用&#10;// - 生成“幽灵”克隆元素并用 transform 动画&#10;// - 提供卡牌动画原语（飞行/渐隐/旋转/缩放等）与常用序列助手&#10;&#10;import frontendEventBus from '../frontendEventBus.js';&#10;import gsap from 'gsap';&#10;&#10;const defaultEase = 'power2.out';&#10;&#10;const orchestrator = {&#10;  overlayEl: null,&#10;  centerAnchorEl: null,&#10;  deckAnchorEl: null,&#10;  ghostContainerEl: null,&#10;&#10;  init({ overlayEl, centerAnchorEl, deckAnchorEl, ghostContainerEl }) {&#10;    this.overlayEl = overlayEl;&#10;    this.centerAnchorEl = centerAnchorEl;&#10;    this.deckAnchorEl = deckAnchorEl;&#10;    this.ghostContainerEl = ghostContainerEl;&#10;  },&#10;&#10;  // 工具：测量/克隆/计算&#10;  getRect(el) { return el?.getBoundingClientRect?.() || null; },&#10;  getAnchor(nameOrEl) {&#10;    if (!nameOrEl) return null;&#10;    if (typeof nameOrEl === 'string') {&#10;      if (nameOrEl === 'center') return this.centerAnchorEl;&#10;      if (nameOrEl === 'deck') return this.deckAnchorEl;&#10;      return null;&#10;    }&#10;    return nameOrEl;&#10;  },&#10;  getAnchorPoint(nameOrEl) {&#10;    const el = this.getAnchor(nameOrEl);&#10;    const r = this.getRect(el);&#10;    if (!r) return { x: window.innerWidth / 2, y: window.innerHeight / 2 };&#10;    return { x: r.left, y: r.top };&#10;  },&#10;  createGhostFromEl(startEl, startRect) {&#10;    if (!this.ghostContainerEl || !startEl || !startRect) return null;&#10;    const ghost = startEl.cloneNode(true);&#10;    Object.assign(ghost.style, {&#10;      position: 'absolute',&#10;      left: `${startRect.left}px`,&#10;      top: `${startRect.top}px`,&#10;      width: `${startRect.width}px`,&#10;      height: `${startRect.height}px`,&#10;      margin: '0',&#10;      transformOrigin: 'center center',&#10;      pointerEvents: 'none',&#10;    });&#10;    ghost.classList.add('animation-ghost');&#10;    this.ghostContainerEl.appendChild(ghost);&#10;    // 初始化transform基线，确保x/y可用&#10;    gsap.set(ghost, { x: 0, y: 0, force3D: true });&#10;    // 保险：禁用任何继承/克隆来的 CSS 动画，避免与 GSAP transform 冲突&#10;    ghost.classList.remove('activating');&#10;    ghost.style.animation = 'none';&#10;    ghost.style.animationName = 'none';&#10;    return ghost;&#10;  },&#10;  // 将屏幕点作为“卡牌中心”目标，换算为 transform x/y&#10;  offsetsToPoint(startRect, point) {&#10;    return {&#10;      x: point.x - startRect.left - startRect.width / 2,&#10;      y: point.y - startRect.top - startRect.height / 2&#10;    };&#10;  },&#10;&#10;  // 原语：对幽灵元素进行一次 tween（支持 x/y/scale/rotate/opacity 按段配置）&#10;  tweenGhost(ghost, props = {}, durationMs = 350, ease = defaultEase) {&#10;    const tweenProps = { ...props };&#10;    if (typeof tweenProps.opacity === 'number') tweenProps.autoAlpha = tweenProps.opacity;&#10;    delete tweenProps.opacity;&#10;    return gsap.to(ghost, { duration: Math.max(0.001, durationMs / 1000), ease, ...tweenProps });&#10;  },&#10;&#10;  // 高阶：按 steps 顺序执行动画（steps 支持 toPoint/toAnchor/delta/scale/rotate/opacity/holdMs）&#10;  async playCardSequence(startEl, steps = [], { hideStart = true } = {}) {&#10;    if (!startEl || !this.overlayEl) return;&#10;    const startRect = this.getRect(startEl);&#10;    if (!startRect) return;&#10;&#10;    const ghost = this.createGhostFromEl(startEl, startRect);&#10;    if (hideStart) { try { startEl.style.visibility = 'hidden'; } catch (_) {} }&#10;&#10;    const finish = () =&gt; {&#10;      try { ghost.remove(); } catch (_) {}&#10;      if (hideStart) { try { startEl.style.visibility = ''; } catch (_) {} }&#10;    };&#10;&#10;    const tl = gsap.timeline({ onComplete: finish });&#10;&#10;    for (const step of steps) {&#10;      const { duration = 350, ease = defaultEase, holdMs = 0 } = step;&#10;      const props = {};&#10;      if (step.toPoint) {&#10;        const o = this.offsetsToPoint(startRect, step.toPoint);&#10;        props.x = o.x; props.y = o.y;&#10;      } else if (step.toAnchor) {&#10;        const p = this.getAnchorPoint(step.toAnchor);&#10;        const o = this.offsetsToPoint(startRect, p);&#10;        props.x = o.x; props.y = o.y;&#10;      } else if (step.delta) {&#10;        // 相对位移：在已有 transform 基础上叠加（用 &quot;+=&quot;写法）&#10;        props.x = `+=${step.delta.dx || 0}`;&#10;        props.y = `+=${step.delta.dy || 0}`;&#10;      }&#10;      if (typeof step.scale === 'number') props.scale = step.scale;&#10;      if (typeof step.rotate === 'number') props.rotate = step.rotate;&#10;      if (typeof step.opacity === 'number') props.autoAlpha = step.opacity;&#10;&#10;      // tween&#10;      tl.to(ghost, { ...props, duration: Math.max(0.001, duration / 1000), ease });&#10;      // hold（使用 x:'+=0' 作为无变化 tween，保证时间线前进）&#10;      if (holdMs &gt; 0) tl.to(ghost, { x: '+=0', duration: holdMs / 1000, ease: 'none' });&#10;    }&#10;&#10;    await new Promise(resolve =&gt; {&#10;      tl.eventCallback('onComplete', () =&gt; { finish(); resolve(); });&#10;      tl.play(0);&#10;    });&#10;  },&#10;&#10;  // 常用序列助手&#10;  async seqFlyToCenter(startEl, { scale = 1.2, durationMs = 350, holdMs = 0 } = {}) {&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'center', scale, duration: durationMs, ease: 'power2.out', holdMs }&#10;    ]);&#10;  },&#10;  async seqCastAtCenter(startEl, { pulseScale = 1.35, pulseMs = 220, repeats = 1 } = {}) {&#10;    const steps = [];&#10;    for (let i = 0; i &lt; repeats; i++) {&#10;      steps.push({ scale: pulseScale, duration: pulseMs, ease: 'power2.out' });&#10;      steps.push({ scale: 1.2, duration: pulseMs, ease: 'power2.in' });&#10;    }&#10;    return this.playCardSequence(startEl, steps, { hideStart: false });&#10;  },&#10;  async seqFlyToDeckFade(startEl, { durationMs = 400 } = {}) {&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'deck', scale: 0.5, rotate: 20, duration: durationMs, ease: 'power2.in' },&#10;      { opacity: 0, duration: 120 }&#10;    ]);&#10;  },&#10;  async seqPlayToCenterThenDeck(startEl, { centerHoldMs = 350, totalMs = 900 } = {}) {&#10;    const first = 350;&#10;    const rest = Math.max(300, totalMs - first - centerHoldMs);&#10;    return this.playCardSequence(startEl, [&#10;      { toAnchor: 'center', scale: 1.2, duration: first, ease: 'power2.out', holdMs: centerHoldMs },&#10;      { toAnchor: 'deck', scale: 0.5, rotate: 20, duration: rest, ease: 'power2.in' }&#10;    ]);&#10;  },&#10;  async seqAppearFromDeckToEl(startEl, { durationMs = 450, startScale = 0.6, fade = true, id = null } = {}) {&#10;    if (!startEl || !this.overlayEl) return;&#10;    const startRect = this.getRect(startEl);&#10;    if (!startRect) return;&#10;&#10;    const deck = this.getAnchorPoint('deck');&#10;    const fromOffset = this.offsetsToPoint(startRect, deck);&#10;&#10;    const ghost = this.createGhostFromEl(startEl, startRect);&#10;    // 隐藏原件直到动画完成&#10;    try { startEl.style.visibility = 'hidden'; } catch (_) {}&#10;&#10;    // 初始化ghost在“牌库处”&#10;    gsap.set(ghost, { x: fromOffset.x, y: fromOffset.y, scale: startScale, autoAlpha: fade ? 0 : 1, force3D: true });&#10;&#10;    await new Promise(resolve =&gt; {&#10;      gsap.to(ghost, {&#10;        duration: Math.max(0.001, durationMs / 1000),&#10;        x: 0, y: 0, scale: 1, autoAlpha: 1,&#10;        ease: 'power2.out',&#10;        onComplete: () =&gt; {&#10;          try { ghost.remove(); } catch (_) {}&#10;          try { startEl.style.visibility = ''; } catch (_) {}&#10;          // 通知外部动画完成&#10;          try { frontendEventBus.emit('card-appear-finished', { id }); } catch (_) {}&#10;          resolve();&#10;        }&#10;      });&#10;    });&#10;  },&#10;&#10;  // 兼容旧接口&#10;  async flyCardToCenterThenToDeck({ startEl, hideStart = true, centerScale = 1.2, centerHoldMs = 350, totalMs = 900 }) {&#10;    return this.seqPlayToCenterThenDeck(startEl, { centerHoldMs, totalMs });&#10;  }&#10;};&#10;&#10;// 事件总线桥接：允许外部直接通过事件触发原语或序列&#10;frontendEventBus.on('animate-card-play', async (payload = {}) =&gt; {&#10;  try {&#10;    const el = payload.el || null;&#10;    if (!el) return;&#10;    if (Array.isArray(payload.steps) &amp;&amp; payload.steps.length) {&#10;      await orchestrator.playCardSequence(el, payload.steps, { hideStart: payload.hideStart !== false });&#10;    } else if (payload.kind === 'centerThenDeck') {&#10;      await orchestrator.seqPlayToCenterThenDeck(el, payload.options || {});&#10;    } else if (payload.kind === 'flyToCenter') {&#10;      await orchestrator.seqFlyToCenter(el, payload.options || {});&#10;    } else if (payload.kind === 'flyToDeckFade') {&#10;      await orchestrator.seqFlyToDeckFade(el, payload.options || {});&#10;    } else if (payload.kind === 'appearFromDeck') {&#10;      await orchestrator.seqAppearFromDeckToEl(el, payload.options || {});&#10;    } else {&#10;      await orchestrator.seqPlayToCenterThenDeck(el, {});&#10;    }&#10;  } catch (_) {}&#10;});&#10;&#10;export default orchestrator;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>