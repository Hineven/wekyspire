# 战斗流程

<cite>
**本文档中引用的文件**
- [battle.js](file://src/data/battle.js)
- [GameApp.vue](file://src/GameApp.vue)
- [game.js](file://src/game.js)
- [BattleScreen.vue](file://src/components/BattleScreen.vue)
- [backendEventBus.js](file://src/backendEventBus.js)
- [frontendEventBus.js](file://src/frontendEventBus.js)
- [gameState.js](file://src/data/gameState.js)
- [enemyFactory.js](file://src/data/enemyFactory.js)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构概览](#项目结构概览)
3. [核心组件分析](#核心组件分析)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介

本文档深入分析了RTVL游戏中的战斗流程系统，详细解析了从进入战斗到战斗结束的完整生命周期。战斗系统采用事件驱动架构，通过状态机模式管理各个战斗阶段，并实现了前后端状态同步机制。

战斗流程涵盖了战斗初始化、阶段切换、战斗终止条件等多个关键环节，确保了游戏体验的流畅性和一致性。系统支持多种战斗阶段，包括战斗准备、玩家回合、敌人回合和结算阶段，每个阶段都有明确的转换条件和处理逻辑。

## 项目结构概览

战斗系统的文件组织遵循清晰的分层架构：

```mermaid
graph TB
subgraph "核心数据层"
BattleJS[battle.js<br/>战斗逻辑核心]
GameState[gameState.js<br/>游戏状态管理]
EnemyFactory[enemyFactory.js<br/>敌人生成器]
end
subgraph "视图层"
GameApp[GameApp.vue<br/>主应用组件]
BattleScreen[BattleScreen.vue<br/>战斗界面]
BattleLog[BattleLogPanel.vue<br/>战斗日志]
end
subgraph "事件层"
BackendBus[backendEventBus.js<br/>后端事件总线]
FrontendBus[frontendEventBus.js<br/>前端事件总线]
end
subgraph "业务逻辑层"
GameLogic[game.js<br/>游戏流程控制]
BattleUtils[battleUtils.js<br/>战斗工具函数]
end
BattleJS --> GameApp
GameApp --> BattleScreen
BattleScreen --> BattleLog
BackendBus --> BattleJS
FrontendBus --> BattleScreen
GameLogic --> BattleJS
BattleUtils --> BattleJS
```

**图表来源**
- [battle.js](file://src/data/battle.js#L1-L553)
- [GameApp.vue](file://src/GameApp.vue#L1-L139)
- [game.js](file://src/game.js#L1-L119)

**章节来源**
- [battle.js](file://src/data/battle.js#L1-L50)
- [GameApp.vue](file://src/GameApp.vue#L1-L50)

## 核心组件分析

### 战斗状态管理器

战斗系统的核心是`battle.js`模块，它负责管理整个战斗生命周期：

```javascript
// 战斗初始化
export function enterBattleStage() {
  gameState.battleCount++;
  
  // 生成敌人
  generateEnemy(gameState);
  
  // 战前事件
  backendEventBus.emit(EventNames.Game.PRE_BATTLE, {
    battleCount: gameState.battleCount,
    player: gameState.player,
    enemy: gameState.enemy
  });
  
  // 切换游戏状态到战斗状态
  gameState.gameStage = 'battle';
  enqueueState(captureSnapshot(), 0);
  enqueueDelay(300, {tags: ['ui', 'mount']});
  
  // 进入游戏控制流
  backendEventBus.emit(EventNames.Battle.BATTLE_START);
}
```

### 事件驱动架构

战斗系统采用事件驱动架构，通过事件总线实现前后端通信：

```mermaid
sequenceDiagram
participant Game as "Game.js"
participant Battle as "Battle.js"
participant EventBus as "EventBus"
participant UI as "BattleScreen.vue"
Game->>Battle : enterBattleStage()
Battle->>Battle : generateEnemy()
Battle->>EventBus : emit(PRE_BATTLE)
Battle->>EventBus : emit(BATTLE_START)
Battle->>Battle : startBattle()
Battle->>EventBus : emit(PLAYER_TURN)
Battle->>UI : 更新界面状态
UI->>EventBus : emit(PLAYER_USE_SKILL)
EventBus->>Battle : useSkill()
Battle->>EventBus : emit(SKILL_USED)
Battle->>EventBus : emit(PLAYER_END_TURN)
Battle->>EventBus : emit(ENEMY_TURN)
Battle->>EventBus : emit(BATTLE_VICTORY)
```

**图表来源**
- [battle.js](file://src/data/battle.js#L15-L50)
- [game.js](file://src/game.js#L25-L45)
- [backendEventBus.js](file://src/backendEventBus.js#L33-L78)

**章节来源**
- [battle.js](file://src/data/battle.js#L15-L50)
- [game.js](file://src/game.js#L25-L45)

## 架构概览

战斗系统采用分层架构设计，确保了代码的可维护性和扩展性：

```mermaid
graph TD
subgraph "表现层"
A[GameApp.vue]
B[BattleScreen.vue]
C[UI组件]
end
subgraph "业务逻辑层"
D[game.js]
E[battle.js]
F[enemyFactory.js]
end
subgraph "数据层"
G[gameState.js]
H[skill.js]
I[player.js]
end
subgraph "事件通信层"
J[backendEventBus.js]
K[frontendEventBus.js]
end
A --> B
B --> C
D --> E
E --> F
E --> G
E --> H
E --> I
D --> J
E --> J
B --> K
K --> J
```

**图表来源**
- [GameApp.vue](file://src/GameApp.vue#L1-L30)
- [battle.js](file://src/data/battle.js#L1-L20)
- [game.js](file://src/game.js#L1-L20)

## 详细组件分析

### 战斗初始化流程

战斗初始化是一个多步骤的过程，涉及状态设置、敌人生成和事件触发：

```mermaid
flowchart TD
Start([enterBattleStage调用]) --> IncBattleCount["增加战斗计数<br/>gameState.battleCount++"]
IncBattleCount --> GenEnemy["生成敌人<br/>generateEnemy()"]
GenEnemy --> EmitPreBattle["触发PRE_BATTLE事件<br/>前置战斗事件"]
EmitPreBattle --> SetGameStage["设置游戏阶段<br/>gameState.gameStage = 'battle'"]
SetGameStage --> EnqueueState["排队状态更新<br/>enqueueState()"]
EnqueueState --> DelayMount["等待UI挂载<br/>enqueueDelay(300)"]
DelayMount --> EmitBattleStart["触发BATTLE_START事件<br/>开始战斗流程"]
EmitBattleStart --> End([初始化完成])
```

**图表来源**
- [battle.js](file://src/data/battle.js#L15-L35)

### 玩家回合管理

玩家回合管理包含回合开始、技能使用和回合结束三个主要阶段：

```mermaid
stateDiagram-v2
[*] --> 玩家回合开始
玩家回合开始 --> 准备阶段 : startPlayerTurn()
准备阶段 --> 补充行动力 : remainingActionPoints = maxActionPoints
补充行动力 --> 技能冷却 : frontierSkills.forEach(skill.coldDown())
技能冷却 --> 回合开始效果 : processStartOfTurnEffects()
回合开始效果 --> 锁定操作面板 : enqueueLockControl()
锁定操作面板 --> 填充前台技能 : fillFrontierSkills()
填充前台技能 --> 等待玩家操作 : 等待前端事件
等待玩家操作 --> 使用技能 : PLAYER_USE_SKILL
等待玩家操作 --> 结束回合 : PLAYER_END_TURN
使用技能 --> 处理技能效果 : activateSkill()
处理技能效果 --> 检查战斗胜利 : checkBattleVictory()
检查战斗胜利 --> 玩家回合结束 : 战斗未结束
检查战斗胜利 --> 战斗胜利 : 战斗结束
结束回合 --> 玩家回合结束 : endPlayerTurn()
玩家回合结束 --> 敌人回合 : ENEMY_TURN
敌人回合 --> [*]
战斗胜利 --> [*]
```

**图表来源**
- [battle.js](file://src/data/battle.js#L50-L150)

### 敌人回合处理

敌人回合处理模拟敌人的智能行为，包括行动决策和效果结算：

```mermaid
sequenceDiagram
participant Battle as "Battle.js"
participant Enemy as "Enemy"
participant Effects as "EffectProcessor"
participant EventBus as "EventBus"
Battle->>Battle : enemyTurn()
Battle->>Battle : 设置isEnemyTurn = true
Battle->>Battle : addEnemyActionLog()
Battle->>EventBus : emit(ENEMY_TURN_START)
Battle->>Effects : processStartOfTurnEffects(enemy)
Effects-->>Battle : 是否眩晕
alt 不眩晕
Battle->>Enemy : act(modifiedPlayer)
Enemy->>Enemy : 执行攻击逻辑
Enemy-->>Battle : 攻击完成
else 眩晕
Battle->>Battle : addSystemLog("敌人眩晕")
end
Battle->>EventBus : emit(ENEMY_ACTION_END)
Battle->>Effects : processEndOfTurnEffects(enemy)
Battle->>EventBus : emit(ENEMY_TURN_END)
Battle->>EventBus : emit(PLAYER_TURN)
```

**图表来源**
- [battle.js](file://src/data/battle.js#L300-L350)

### 战斗胜利处理

战斗胜利处理负责清理战场状态并触发相应的结算流程：

```javascript
function battleVictory(isVictory) {
  // 清理咏唱技能
  if (Array.isArray(gameState.player.activatedSkills) && gameState.player.activatedSkills.length) {
    for (const s of [...gameState.player.activatedSkills]) {
      try { s.onDisable(gameState.player, 'battleEnd'); } catch (_) {}
      backendEventBus.emit(EventNames.Player.ACTIVATED_SKILL_DISABLED, { skill: s, reason: 'battleEnd' });
    }
    gameState.player.activatedSkills = [];
  }
  
  // 卡牌离场
  gameState.player.skills.forEach(skill => {
    try { skill.onLeaveBattle(gameState.player); } catch (_) {}
  });
  
  // 清理技能列表
  gameState.player.frontierSkills = [];
  gameState.player.backupSkills = [];
  gameState.player.burntSkills = [];
  
  // 战斗结束事件
  backendEventBus.emit(EventNames.Game.POST_BATTLE, {
    battleCount: gameState.battleCount,
    player: gameState.player,
    enemy: gameState.enemy,
    isVictory: isVictory
  });
}
```

**章节来源**
- [battle.js](file://src/data/battle.js#L350-L400)

### 前后端状态同步

战斗系统通过事件总线实现前后端状态同步：

```mermaid
classDiagram
class BackendEventBus {
+emit(eventName, payload)
+on(eventName, handler)
+off(eventName, handler)
}
class FrontendEventBus {
+emit(eventName, payload)
+on(eventName, handler)
+off(eventName, handler)
}
class BattleScreen {
+props : player, enemy, isPlayerTurn, level
+data : logs
+methods : onAddBattleLog, onClearBattleLog
+mounted() : 注册事件监听
+beforeUnmount() : 移除事件监听
}
class GameApp {
+computed : isPlayerTurn
+data : gameState
+methods : restartGame()
+mounted() : 初始化动画编排器
}
BackendEventBus <|-- BattleScreen : 接收事件
FrontendEventBus <|-- BattleScreen : 发送事件
GameApp --> BattleScreen : 条件渲染
BattleScreen --> BackendEventBus : 事件处理
```

**图表来源**
- [BattleScreen.vue](file://src/components/BattleScreen.vue#L1-L50)
- [GameApp.vue](file://src/GameApp.vue#L1-L50)
- [backendEventBus.js](file://src/backendEventBus.js#L1-L20)

**章节来源**
- [BattleScreen.vue](file://src/components/BattleScreen.vue#L1-L112)
- [GameApp.vue](file://src/GameApp.vue#L1-L139)

## 依赖关系分析

战斗系统的依赖关系展现了清晰的分层架构：

```mermaid
graph LR
subgraph "外部依赖"
Mitt[mitt事件库]
Vue[Vue.js框架]
end
subgraph "内部模块"
Battle[battle.js]
Game[game.js]
GameApp[GameApp.vue]
BattleScreen[BattleScreen.vue]
EventBus[backendEventBus.js]
GameState[gameState.js]
EnemyFactory[enemyFactory.js]
end
Mitt --> EventBus
Vue --> GameApp
Vue --> BattleScreen
Game --> Battle
Battle --> EventBus
Battle --> GameState
Battle --> EnemyFactory
GameApp --> BattleScreen
BattleScreen --> EventBus
```

**图表来源**
- [battle.js](file://src/data/battle.js#L1-L10)
- [game.js](file://src/game.js#L1-L10)
- [backendEventBus.js](file://src/backendEventBus.js#L1-L5)

**章节来源**
- [battle.js](file://src/data/battle.js#L1-L15)
- [game.js](file://src/game.js#L1-L15)

## 性能考虑

战斗系统在设计时充分考虑了性能优化：

1. **事件队列机制**：使用动画指令助手实现异步动画处理
2. **状态快照**：通过captureSnapshot()减少不必要的状态计算
3. **延迟处理**：合理使用enqueueDelay()避免过度渲染
4. **内存管理**：及时清理战斗结束后的技能状态

## 故障排除指南

### 常见问题及解决方案

1. **战斗状态不一致**
   - 检查gameState.gameStage是否正确设置
   - 验证事件监听器是否正常注册
   - 确认enqueueState()调用时机

2. **技能使用失败**
   - 验证技能canUse()方法返回值
   - 检查玩家行动力是否充足
   - 确认技能是否存在于前台技能列表

3. **UI状态不同步**
   - 检查frontendEventBus事件发送
   - 验证BattleScreen组件事件监听
   - 确认props数据传递正确

**章节来源**
- [battle.js](file://src/data/battle.js#L450-L500)

## 结论

RTVL游戏的战斗流程系统展现了优秀的软件架构设计，通过事件驱动模式实现了前后端的松耦合集成。系统具有以下特点：

1. **模块化设计**：清晰的职责分离，便于维护和扩展
2. **状态机管理**：明确的战斗阶段转换，确保流程可控
3. **事件驱动**：高效的前后端通信机制
4. **错误处理**：完善的异常处理和状态恢复机制

这套战斗系统为游戏提供了稳定可靠的战斗体验，同时具备良好的可扩展性，能够支持未来的新功能开发。