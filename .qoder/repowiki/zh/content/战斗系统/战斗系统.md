# 战斗系统

<cite>
**本文档中引用的文件**
- [battle.js](file://src/data/battle.js)
- [effectProcessor.js](file://src/data/effectProcessor.js)
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js)
- [gameState.js](file://src/data/gameState.js)
- [player.js](file://src/data/player.js)
- [unit.js](file://src/data/unit.js)
- [skill.js](file://src/data/skill.js)
- [animationSequencer.js](file://src/data/animationSequencer.js)
- [battleUtils.js](file://src/data/battleUtils.js)
- [BattleScreen.vue](file://src/components/BattleScreen.vue)
- [ActionPanel.vue](file://src/components/ActionPanel.vue)
- [punch.js](file://src/data/skills/martial_arts/punch.js)
- [basic.js](file://src/data/enemies/basic.js)
- [boss.js](file://src/data/enemies/boss.js)
- [slimes.js](file://src/data/enemies/slimes.js)
- [enemyFactory.js](file://src/data/enemyFactory.js)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介

本战斗系统是一个复杂的回合制战斗引擎，采用前后端分离架构，实现了完整的战斗流程控制、技能系统、状态效果管理和动画调度。系统支持多种战斗阶段，包括战斗准备、玩家回合、敌人回合和战斗结束，并提供了丰富的状态效果叠加规则和优先级处理机制。

## 项目结构

战斗系统的核心文件组织如下：

```mermaid
graph TB
subgraph "战斗核心模块"
A[battle.js<br/>战斗流程控制]
B[effectProcessor.js<br/>效果处理]
C[animationInstructionHelpers.js<br/>动画指令]
D[animationSequencer.js<br/>动画序列器]
end
subgraph "状态管理"
E[gameState.js<br/>游戏状态]
F[player.js<br/>玩家状态]
G[unit.js<br/>单位基类]
end
subgraph "技能系统"
H[skill.js<br/>技能基类]
I[martial_arts/<br/>武术技能]
J[curse/<br/>诅咒技能]
end
subgraph "敌人系统"
K[enemy.js<br/>敌人基类]
L[enemies/basic.js<br/>普通敌人]
M[enemies/boss.js<br/>Boss敌人]
N[enemyFactory.js<br/>敌人工厂]
end
subgraph "前端组件"
O[BattleScreen.vue<br/>战斗界面]
P[ActionPanel.vue<br/>操作面板]
Q[技能组件<br/>技能卡片]
end
A --> B
A --> C
C --> D
E --> F
F --> G
H --> G
K --> G
L --> K
M --> K
N --> K
A --> O
O --> P
P --> Q
```

**图表来源**
- [battle.js](file://src/data/battle.js#L1-L50)
- [gameState.js](file://src/data/gameState.js#L1-L30)
- [player.js](file://src/data/player.js#L1-L50)

## 核心组件

### 战斗流程控制器 (battle.js)

战斗流程控制器是整个战斗系统的核心，负责管理战斗的各个阶段和回合转换。

```javascript
// 战斗开始流程
export function enterBattleStage() {
  gameState.battleCount++;
  generateEnemy(gameState);
  backendEventBus.emit(EventNames.Game.PRE_BATTLE, {
    battleCount: gameState.battleCount,
    player: gameState.player,
    enemy: gameState.enemy
  });
  gameState.gameStage = 'battle';
  enqueueState(captureSnapshot(), 0);
  enqueueDelay(300, {tags: ['ui', 'mount']});
  backendEventBus.emit(EventNames.Battle.BATTLE_START);
}
```

### 状态效果处理器 (effectProcessor.js)

效果处理器实现了复杂的状态效果叠加规则和优先级处理机制。

```javascript
export function processStartOfTurnEffects(target) {
  // 处理燃烧效果
  if (target.effects['燃烧'] > 0) {
    let damage = target.effects['燃烧'];
    damage -= target.effects['火焰抗性'] || 0;
    target.addEffect('燃烧', -1);
    if(damage > 0) {
      dealDamage(null, target, damage);
      enqueueDelay(400);
    }
  }
  
  // 处理眩晕效果
  if (target.effects['眩晕'] > 0) {
    target.addEffect('眩晕', -1);
    addEffectLog(`${target.name}处于眩晕状态，跳过回合！`);
    return true;
  }
  
  return false;
}
```

**章节来源**
- [battle.js](file://src/data/battle.js#L15-L50)
- [effectProcessor.js](file://src/data/effectProcessor.js#L15-L80)

## 架构概览

战斗系统采用分层架构设计，实现了清晰的职责分离：

```mermaid
graph TD
subgraph "表现层"
A[BattleScreen<br/>战斗界面]
B[ActionPanel<br/>操作面板]
C[技能卡片组件<br/>SkillCard]
end
subgraph "业务逻辑层"
D[战斗流程控制器<br/>battle.js]
E[效果处理器<br/>effectProcessor.js]
F[战斗工具函数<br/>battleUtils.js]
end
subgraph "状态管理层"
G[游戏状态管理<br/>gameState.js]
H[玩家状态<br/>player.js]
I[单位基类<br/>unit.js]
end
subgraph "动画层"
J[动画序列器<br/>animationSequencer.js]
K[动画指令助手<br/>animationInstructionHelpers.js]
end
subgraph "技能系统"
L[技能基类<br/>skill.js]
M[具体技能实现<br/>martial_arts/]
end
A --> D
B --> D
C --> L
D --> E
D --> F
D --> G
E --> G
F --> G
G --> H
H --> I
D --> J
J --> K
L --> I
```

**图表来源**
- [BattleScreen.vue](file://src/components/BattleScreen.vue#L1-L30)
- [ActionPanel.vue](file://src/components/ActionPanel.vue#L1-L30)
- [battle.js](file://src/data/battle.js#L1-L30)

## 详细组件分析

### 战斗主循环

战斗主循环实现了完整的回合制战斗流程，包括回合切换、行动点管理和技能执行顺序控制。

```mermaid
sequenceDiagram
participant Backend as 后端战斗控制器
participant Player as 玩家
participant Enemy as 敌人
participant Animation as 动画序列器
participant UI as 用户界面
Backend->>Backend : enterBattleStage()
Backend->>Backend : startBattle()
Backend->>Player : 初始化技能列表
Backend->>Animation : enqueueState()
Backend->>UI : 显示战斗界面
loop 玩家回合
Backend->>Backend : startPlayerTurn()
Backend->>Player : 补充行动点
Backend->>Player : 进行技能冷却
Backend->>Backend : processStartOfTurnEffects()
Backend->>UI : 解锁操作面板
Backend->>Player : fillFrontierSkills()
alt 玩家未眩晕
UI->>Backend : 玩家使用技能
Backend->>Backend : useSkill()
Backend->>Enemy : activateSkill()
Backend->>Animation : 播放技能动画
Backend->>Backend : endPlayerTurn()
else 玩家眩晕
Backend->>Backend : endPlayerTurn()
end
end
loop 敌人回合
Backend->>Backend : enemyTurn()
Backend->>Enemy : processStartOfTurnEffects()
Backend->>Player : 敌人行动
Backend->>Animation : 播放敌人动画
Backend->>Enemy : processEndOfTurnEffects()
end
Backend->>Backend : checkBattleVictory()
alt 战斗胜利
Backend->>Player : 清理状态
Backend->>Animation : 播放胜利动画
else 战斗失败
Backend->>Player : 清理状态
Backend->>Animation : 播放失败动画
end
```

**图表来源**
- [battle.js](file://src/data/battle.js#L50-L150)
- [battle.js](file://src/data/battle.js#L300-L400)

### 技能系统架构

技能系统采用面向对象设计，支持多种技能类型和复杂的技能效果。

```mermaid
classDiagram
class Skill {
+string name
+string type
+number tier
+number manaCost
+number actionPointCost
+number maxUses
+number remainingUses
+number coldDownTurns
+string cardMode
+use(player, enemy, stage) boolean
+consumeResources(player) void
+canUse(player) boolean
+coldDown(deltaStacks) void
+onBattleStart() void
+onEnterBattle(player) void
+onLeaveBattle(player) void
}
class Punch {
+number baseDamage
+number powerMultiplier
+get damage() number
+use(player, enemy) boolean
+regenerateDescription(player) string
}
class ExplosivePunch {
+get damage() number
+getDamage(enemy) number
+use(player, enemy) boolean
+regenerateDescription(player) string
}
class Player {
+number maxActionPoints
+number remainingActionPoints
+Skill[] frontierSkills
+Skill[] backupSkills
+Skill[] activatedSkills
+Skill[] burntSkills
+number currentShiftSkillActionPointCost
+canShiftSkill() boolean
+consumeActionPoints(amount) void
+gainActionPoint(amount) void
}
Skill <|-- Punch
Skill <|-- ExplosivePunch
Player --> Skill : manages
```

**图表来源**
- [skill.js](file://src/data/skill.js#L1-L100)
- [punch.js](file://src/data/skills/martial_arts/punch.js#L1-L50)
- [player.js](file://src/data/player.js#L50-L100)

### 状态效果管理系统

状态效果管理系统实现了复杂的效果叠加规则和优先级处理。

```mermaid
flowchart TD
A[回合开始效果处理] --> B{检查眩晕}
B --> |存在| C[跳过回合]
B --> |不存在| D{检查燃烧}
D --> |存在| E[计算燃烧伤害]
E --> F[应用燃烧伤害]
F --> G{检查吸热}
G --> |存在| H[移除燃烧层数]
G --> |不存在| I{检查聚气}
H --> I
I --> |存在| J[恢复魏启]
I --> |不存在| K{检查肌肉记忆}
J --> K
K --> |存在| L[冷却所有技能]
K --> |不存在| M{检查飞行}
L --> M
M --> |存在| N[获得闪避效果]
M --> |不存在| O[处理完所有效果]
P[回合结束效果处理] --> Q{检查吸收}
Q --> |存在| R[恢复魏启]
Q --> |不存在| S{检查中毒}
R --> S
S --> |存在| T[造成中毒伤害]
S --> |不存在| U{检查再生}
T --> U
U --> |存在| V[恢复生命值]
U --> |不存在| W[处理其他效果]
O --> P
C --> X[回合结束]
V --> W
W --> Y[效果处理完成]
```

**图表来源**
- [effectProcessor.js](file://src/data/effectProcessor.js#L15-L100)
- [effectProcessor.js](file://src/data/effectProcessor.js#L120-L200)

### 动画调度系统

动画调度系统实现了复杂的动画序列控制和状态同步机制。

```mermaid
stateDiagram-v2
[*] --> Pending : enqueueInstruction()
Pending --> Running : _pump()
Running --> Finished : finish() 或 timeout
Running --> Running : 动画播放中
Finished --> [*] : 清理指令
note right of Pending
指令等待条件：
- 所有 waitTags 的前序指令已完成
- 或 waitTags 包含 'all'
end note
note right of Running
动画执行阶段：
- 调用 start() 方法
- 设置超时计时器
- 等待前端完成通知
end note
```

**图表来源**
- [animationSequencer.js](file://src/data/animationSequencer.js#L50-L100)

**章节来源**
- [battle.js](file://src/data/battle.js#L200-L300)
- [effectProcessor.js](file://src/data/effectProcessor.js#L1-L100)
- [animationSequencer.js](file://src/data/animationSequencer.js#L1-L50)

### 敌人系统架构

敌人系统支持多种敌人类型和复杂的战斗行为。

```mermaid
classDiagram
class Enemy {
+string name
+number hp
+number maxHp
+number attack
+number defense
+number magic
+string type
+number battleIntensity
+number actionIndex
+act(player) void
+calculateDamage(attack, target) number
}
class Slime {
+string description
+act(player) void
}
class FireSlime {
+number burnDamage
+string description
+act(player) void
+calculateDamage(attack, player) number
}
class MEFM3 {
+boolean prepared
+boolean hpThresholdReached
+string subtitle
+string description
+act(player) void
}
class Karmura {
+boolean hpThresholdReached
+string subtitle
+string description
+act(player) void
}
Enemy <|-- Slime
Enemy <|-- FireSlime
Enemy <|-- MEFM3
Enemy <|-- Karmura
```

**图表来源**
- [basic.js](file://src/data/enemies/basic.js#L1-L50)
- [slimes.js](file://src/data/enemies/slimes.js#L1-L40)
- [boss.js](file://src/data/enemies/boss.js#L1-L50)

## 依赖关系分析

战斗系统的依赖关系体现了清晰的分层架构：

```mermaid
graph LR
subgraph "外部依赖"
A[Vue.js<br/>响应式框架]
B[EventBus<br/>事件总线]
C[AnimationSequencer<br/>动画序列器]
end
subgraph "战斗核心"
D[battle.js]
E[effectProcessor.js]
F[battleUtils.js]
end
subgraph "状态管理"
G[gameState.js]
H[player.js]
I[unit.js]
end
subgraph "技能系统"
J[skill.js]
K[martial_arts/]
L[curse/]
end
subgraph "敌人系统"
M[enemy.js]
N[enemies/basic.js]
O[enemies/boss.js]
P[enemyFactory.js]
end
A --> D
B --> D
C --> D
D --> E
D --> F
D --> G
E --> F
F --> G
G --> H
H --> I
J --> I
M --> I
N --> M
O --> M
P --> M
D --> J
D --> M
```

**图表来源**
- [battle.js](file://src/data/battle.js#L1-L10)
- [gameState.js](file://src/data/gameState.js#L1-L10)

**章节来源**
- [battle.js](file://src/data/battle.js#L1-L20)
- [gameState.js](file://src/data/gameState.js#L1-L30)

## 性能考虑

### 技能效果批量处理

系统采用了多种性能优化策略：

1. **状态快照机制**：通过`captureSnapshot()`和`applyProjectionToDisplay()`实现高效的前后端状态同步
2. **动画批处理**：使用动画序列器统一管理动画指令，避免频繁的DOM操作
3. **效果链式处理**：通过`processPostAttackEffects`和`processAttackTakenEffects`实现效果的链式处理

### 动画调度优化

```javascript
// 动画指令优化示例
export function enqueueAnimateCardById(payload = {}, { tags = ['ui'], waitTags, durationMs = Infinity, ...rest } = {}) {
  return enqueueInstruction({
    tags,
    waitTags: waitTags ?? computeWaitTags(rest),
    durationMs,
    start: ({ id, emit }) => {
      const token = id;
      const onFinished = (msg = {}) => {
        const t = msg?.token;
        if (t === token) {
          frontendEventBus.off('animation-card-by-id-finished', onFinished);
          frontendEventBus.emit('animation-instruction-finished', { id });
        }
      };
      frontendEventBus.on('animation-card-by-id-finished', onFinished);
      try { emit('animate-card-by-id', Object.assign({}, payload || {}, { completionToken: token })); }
      catch (_) { frontendEventBus.off('animation-card-by-id-finished', onFinished); }
    },
  });
}
```

### 内存管理

系统通过以下方式优化内存使用：

- 使用对象池模式管理技能实例
- 及时清理战斗结束后的状态数据
- 采用WeakMap避免内存泄漏

## 故障排除指南

### 常见问题诊断

1. **技能无法使用**
   - 检查行动点是否充足
   - 验证魏启消耗是否满足
   - 确认技能冷却状态

2. **动画播放异常**
   - 检查动画指令的waitTags配置
   - 验证前端事件总线连接
   - 确认动画序列器状态

3. **效果处理错误**
   - 检查效果名称拼写
   - 验证效果堆叠逻辑
   - 确认效果优先级处理

### 调试工具

系统提供了丰富的调试功能：

```javascript
// 启用调试模式
console.log('Starting battle with cultivated skills:', gameState.player.cultivatedSkills);
console.log(gameState.player.skills);

// 状态监控
backendEventBus.on('animation-instruction-finished', (payload = {}) => {
  const id = payload?.id;
  if (id) this.finish(id, 'frontend');
});
```

**章节来源**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)
- [battle.js](file://src/data/battle.js#L40-L60)

## 结论

本战斗系统展现了现代游戏开发中的最佳实践，通过清晰的架构设计、完善的错误处理和优秀的性能优化，为玩家提供了流畅而富有深度的战斗体验。系统的主要优势包括：

1. **模块化设计**：各组件职责明确，易于维护和扩展
2. **前后端分离**：清晰的职责分工，提高开发效率
3. **状态管理**：完善的前后端状态同步机制
4. **动画系统**：灵活的动画调度和状态管理
5. **扩展性强**：支持新的技能类型和敌人行为

未来的改进方向包括：
- 增强AI敌人的智能程度
- 优化大规模战斗的性能
- 扩展更多的战斗效果类型
- 改进动画系统的实时渲染能力