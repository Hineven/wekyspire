# 状态同步机制

<cite>
**本文档引用的文件**
- [frontendEventBus.js](file://src/frontendEventBus.js)
- [backendEventBus.js](file://src/backendEventBus.js)
- [gameState.js](file://src/data/gameState.js)
- [battle.js](file://src/data/battle.js)
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js)
- [BattleScreen.vue](file://src/components/battle/BattleScreen.vue)
- [MessagePopupScreen.vue](file://src/components/end/MessagePopupScreen.vue)
- [dialogues.js](file://src/data/dialogues.js)
</cite>

## 目录
1. [引言](#引言)
2. [事件总线架构](#事件总线架构)
3. [状态管理模型](#状态管理模型)
4. [后端事件处理流程](#后端事件处理流程)
5. [前端状态同步机制](#前端状态同步机制)
6. [UI组件响应式更新](#ui组件响应式更新)
7. [典型状态同步场景](#典型状态同步场景)
8. [事件去重与顺序保证](#事件去重与顺序保证)
9. [错误处理策略](#错误处理策略)
10. [结论](#结论)

## 引言
本项目采用前后端分离的状态管理架构，通过两个独立的事件总线（frontendEventBus 和 backendEventBus）实现高效的状态同步。该机制确保了游戏逻辑的纯净性与UI响应的实时性，同时提供了清晰的职责划分。本文档详细分析这一状态同步机制的设计与实现。

## 事件总线架构

### 事件总线设计
项目采用 mitt 库实现两个独立的事件总线：
- **backendEventBus**：负责核心游戏逻辑的状态变更通知和流程控制
- **frontendEventBus**：负责UI组件间的动画控制和视觉反馈

```mermaid
graph TB
subgraph "后端逻辑层"
BEB[backendEventBus]
GS[gameState.js]
B[battle.js]
D[dialogues.js]
end
subgraph "前端展示层"
FEB[frontendEventBus]
BS[BattleScreen.vue]
MPS[MessagePopupScreen.vue]
end
BEB --> |状态变更| GS
GS --> |投影同步| FEB
B --> |流程控制| BEB
D --> |对话触发| FEB
FEB --> |动画指令| BS
FEB --> |消息通知| MPS
```

**Diagram sources**
- [backendEventBus.js](file://src/backendEventBus.js#L1-L80)
- [frontendEventBus.js](file://src/frontendEventBus.js#L1-L8)

**Section sources**
- [backendEventBus.js](file://src/backendEventBus.js#L1-L80)
- [frontendEventBus.js](file://src/frontendEventBus.js#L1-L8)

### 事件类型定义
backendEventBus 定义了结构化的事件命名空间，涵盖游戏各个阶段：

```mermaid
classDiagram
class EventNames {
+Game : Object
+Player : Object
+PlayerOperations : Object
+Battle : Object
+Rest : Object
+Shop : Object
}
class GameEvents {
+PRE_GAME_START
+GAME_START
+ENTER_BATTLE_STAGE
+ENTER_REST_STAGE
+PRE_BATTLE
+POST_BATTLE
+GAME_OVER
}
class PlayerEvents {
+TIER_UPGRADED
+ABILITY_CLAIMED
+MONEY_CLAIMED
+SKILL_REWARD_CLAIMED
+FRONTIER_UPDATED
+ACTIVATED_SKILLS_UPDATED
+EFFECT_CHANGED
+SKILL_BURNT
+SKILL_DISCOVERED
+SKILL_USED
+SKILL_DROPPED
+SKILL_DRAWN
}
class PlayerOperationsEvents {
+PLAYER_USE_SKILL
+PLAYER_SHIFT_SKILL
+PLAYER_END_TURN
+PLAYER_STOP_ACTIVATED_SKILL
+CLAIM_MONEY
+CLAIM_SKILL
+CLAIM_ABILITY
+CLAIM_BREAKTHROUGH
+REORDER_SKILLS
+PURCHASE_ITEM
+FINISH
+DROP_REWARD
+CONFIRM_OVERLAY_SKILL_SELECTIONS
}
class BattleEvents {
+BATTLE_START
+PRE_PLAYER_TURN_START
+PLAYER_TURN_START
+PLAYER_TURN
+PLAYER_TURN_END
+POST_PLAYER_TURN_END
+ENEMY_TURN
+ENEMY_TURN_START
+ENEMY_ACTION_END
+ENEMY_TURN_END
+BATTLE_VICTORY
}
EventNames --> GameEvents : "包含"
EventNames --> PlayerEvents : "包含"
EventNames --> PlayerOperationsEvents : "包含"
EventNames --> BattleEvents : "包含"
```

**Diagram sources**
- [backendEventBus.js](file://src/backendEventBus.js#L5-L78)

## 状态管理模型

### 双状态系统
项目采用双状态系统实现前后端分离：

```mermaid
classDiagram
class gameState {
+gameStage : string
+restScreenStage : string
+isRemiPresent : boolean
+isVictory : boolean
+isEnemyTurn : boolean
+player : Player
+enemy : Object
+rewards : Object
+shopItems : Array
+battleCount : number
}
class Player {
+hp : number
+maxHp : number
+mana : number
+maxMana : number
+effects : Object
+shield : number
+cultivatedSkills : Array
+skills : Array
+frontierSkills : Array
+backupSkills : Array
+burntSkills : Array
+activatedSkills : Array
+remainingActionPoints : number
+currentShiftSkillActionPointCost : number
}
gameState --> Player : "包含"
class StateManagement {
+backendGameState : reactive
+displayGameState : reactive
+createGameState() : Object
+resetDisplayGameState() : void
+resetBackendGameState() : void
+resetAllGameStates() : void
}
```

**Section sources**
- [gameState.js](file://src/data/gameState.js#L1-L74)

### 状态同步流程
后端状态变更通过投影机制同步到前端：

```mermaid
sequenceDiagram
participant Backend as 后端逻辑
participant BEB as backendEventBus
participant GS as backendGameState
participant AHS as animationInstructionHelpers
participant DGS as displayGameState
participant FEB as frontendEventBus
Backend->>BEB : emit(事件)
BEB->>Backend : 触发监听器
Backend->>GS : 修改状态
GS->>AHS : watch(状态变化)
AHS->>AHS : scheduleEndOfTickCheck()
AHS->>AHS : enqueueState()
AHS->>DGS : applyProjectionToDisplay()
DGS->>FEB : 响应式更新
FEB->>UI : 通知组件更新
```

**Diagram sources**
- [gameState.js](file://src/data/gameState.js#L51-L74)
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

## 后端事件处理流程

### 战斗流程控制
后端事件总线驱动整个战斗流程：

```mermaid
flowchart TD
A[enterBattleStage] --> B[PRE_BATTLE]
B --> C[GAME_START]
C --> D[BATTLE_START]
D --> E[startBattle]
E --> F[PLAYER_TURN]
F --> G[startPlayerTurn]
G --> H[PRE_PLAYER_TURN_START]
H --> I[PLAYER_TURN_START]
I --> J[填充前台技能]
J --> K[等待玩家操作]
K --> L{玩家操作}
L --> M[PLAYER_USE_SKILL]
L --> N[PLAYER_SHIFT_SKILL]
L --> O[PLAYER_END_TURN]
M --> P[useSkill]
N --> Q[shiftSkill]
O --> R[endPlayerTurn]
R --> S[PLAYER_TURN_END]
S --> T[POST_PLAYER_TURN_END]
T --> U[ENEMY_TURN]
U --> V[enemyTurn]
V --> W[ENEMY_TURN_START]
W --> X[敌人行动]
X --> Y[ENEMY_ACTION_END]
Y --> Z[ENEMY_TURN_END]
Z --> F
```

**Diagram sources**
- [battle.js](file://src/data/battle.js#L30-L552)

**Section sources**
- [battle.js](file://src/data/battle.js#L30-L552)

### 事件监听注册
初始化战斗流程监听器：

```mermaid
classDiagram
class BattleFlowListeners {
+initializeBattleFlowListeners()
}
class EventHandlers {
+startBattle()
+startPlayerTurn()
+useSkill()
+endPlayerTurn()
+enemyTurn()
+battleVictory()
}
BattleFlowListeners --> EventHandlers : "注册"
class EventRegistration {
+BATTLE_START --> startBattle
+PLAYER_TURN --> startPlayerTurn
+PLAYER_USE_SKILL --> useSkill
+PLAYER_END_TURN --> endPlayerTurn
+ENEMY_TURN --> enemyTurn
+BATTLE_VICTORY --> battleVictory
}
```

**Section sources**
- [battle.js](file://src/data/battle.js#L400-L552)

## 前端状态同步机制

### 状态投影同步
通过 animationInstructionHelpers 实现状态同步：

```mermaid
flowchart TD
A[backendGameState变更] --> B[watch触发]
B --> C[backendStateDirty = true]
C --> D[scheduleEndOfTickCheck]
D --> E[setTimeout]
E --> F{backendStateDirty?}
F --> |是| G[enqueueState]
F --> |否| H[结束]
G --> I[captureSnapshot]
I --> J[animationSequencer.enqueueInstruction]
J --> K[applyProjectionToDisplay]
K --> L[displayGameState更新]
L --> M[Vue响应式更新]
```

**Section sources**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

### 同步指令队列
状态同步作为动画指令入队：

```mermaid
classDiagram
class AnimationSequencer {
+enqueueInstruction()
+instructionQueue : Array
}
class StateSyncInstruction {
+tags : ['state']
+waitTags : ['all']
+durationMs : 200
+start() : void
}
class UIInstruction {
+tags : ['ui']
+waitTags : ['state']
+durationMs : 0
+start() : void
}
AnimationSequencer --> StateSyncInstruction : "包含"
AnimationSequencer --> UIInstruction : "包含"
StateSyncInstruction --> UIInstruction : "waitTags"
```

**Section sources**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

## UI组件响应式更新

### 消息弹窗组件
MessagePopupScreen 监听前端事件总线：

```mermaid
sequenceDiagram
participant FE as 前端操作
participant FEB as frontendEventBus
participant MPS as MessagePopupScreen
participant UI as 用户界面
FE->>FEB : emit('pop-message', message)
FEB->>MPS : on('pop-message')
MPS->>MPS : addMessage(message)
MPS->>MPS : messages.push(newMessage)
MPS->>MPS : setTimeout(removeMessage)
MPS->>UI : 更新DOM
UI->>User : 显示消息
```

**Diagram sources**
- [MessagePopupScreen.vue](file://src/components/end/MessagePopupScreen.vue#L1-L61)

**Section sources**
- [MessagePopupScreen.vue](file://src/components/end/MessagePopupScreen.vue#L1-L61)

### 对话系统集成
dialogues.js 监听后端事件触发对话：

```mermaid
flowchart TD
A[registerListeners] --> B[监听SKILL_USED]
B --> C[SKILL_USED事件]
C --> D[getSkillUseDialog]
D --> E{isRemiPresent?}
E --> |是| F[enqueueUI('displayDialog')]
E --> |否| G[结束]
F --> H[frontendEventBus.emit('display-dialog')]
H --> I[DialogScreen.vue显示对话]
```

**Diagram sources**
- [dialogues.js](file://src/data/dialogues.js#L300-L343)

**Section sources**
- [dialogues.js](file://src/data/dialogues.js#L300-L343)

## 典型状态同步场景

### 回合切换场景
玩家结束回合时的状态同步流程：

```mermaid
sequenceDiagram
participant Player as 玩家
participant BS as BattleScreen
participant BEB as backendEventBus
participant GS as gameState
participant AHS as animationInstructionHelpers
Player->>BS : 点击结束回合
BS->>BEB : emit(PLAYER_END_TURN)
BEB->>endPlayerTurn : 触发监听器
endPlayerTurn->>GS : enqueueLockControl()
endPlayerTurn->>BEB : emit(PLAYER_TURN_END)
endPlayerTurn->>processEndOfTurnEffects : 结算效果
endPlayerTurn->>BEB : emit(POST_PLAYER_TURN_END)
endPlayerTurn->>BEB : emit(ENEMY_TURN)
enemyTurn->>GS : isEnemyTurn = true
GS->>AHS : 状态变更
AHS->>AHS : enqueueState()
AHS->>displayGameState : 同步状态
displayGameState->>UI : 响应式更新
```

**Section sources**
- [battle.js](file://src/data/battle.js#L300-L353)

### 技能使用场景
玩家使用技能时的状态同步流程：

```mermaid
sequenceDiagram
participant Player as 玩家
participant BS as BattleScreen
participant BEB as backendEventBus
participant GS as gameState
participant AHS as animationInstructionHelpers
Player->>BS : 点击技能卡
BS->>BEB : emit(PLAYER_USE_SKILL, skillID)
BEB->>useSkill : 触发监听器
useSkill->>GS : consumeResources()
useSkill->>activateSkill : 发动技能
activateSkill->>processSkillActivationEffects : 结算效果
activateSkill->>skill.use : 执行技能效果
useSkill->>BEB : emit(SKILL_USED)
useSkill->>handleSkillAfterUse : 后处理
handleSkillAfterUse->>dropSkillCard : 丢弃技能
handleSkillAfterUse->>BEB : emit(FRONTIER_UPDATED)
GS->>AHS : 状态变更
AHS->>AHS : enqueueState()
AHS->>displayGameState : 同步状态
displayGameState->>UI : 响应式更新
```

**Section sources**
- [battle.js](file://src/data/battle.js#L200-L300)

## 事件去重与顺序保证

### 事件去重机制
通过状态标记和定时器实现事件去重：

```mermaid
flowchart TD
A[backendGameState变更] --> B[watch触发]
B --> C[backendStateDirty = true]
C --> D{endOfTickStateSycnScheduled?}
D --> |否| E[endOfTickStateSycnScheduled = true]
D --> |是| F[直接返回]
E --> G[setTimeout(0)]
G --> H[执行enqueueState]
H --> I[backendStateDirty = false]
I --> J[endOfTickStateSycnScheduled = false]
```

**Section sources**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

### 顺序保证机制
通过指令队列的依赖关系保证执行顺序：

```mermaid
classDiagram
class Instruction {
+tags : Array
+waitTags : Array
+durationMs : number
+start() : void
}
class StateInstruction {
+tags : ['state']
+waitTags : ['all']
}
class UIInstruction {
+tags : ['ui']
+waitTags : ['state']
}
StateInstruction --> UIInstruction : "waitTags依赖"
class ExecutionOrder {
+1 : State同步指令
+2 : UI动画指令
+3 : 状态同步指令
+4 : 下一阶段UI指令
}
```

**Section sources**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

## 错误处理策略

### 事件监听错误处理
在事件处理中包含错误捕获：

```mermaid
flowchart TD
A[事件处理函数] --> B[try-catch包裹]
B --> C[执行核心逻辑]
C --> D{发生异常?}
D --> |是| E[console.error记录]
D --> |否| F[正常执行]
E --> G[继续执行后续逻辑]
F --> H[完成]
G --> H
class try-catch {
+try { ... }
+catch(err) { console.error(...) }
}
```

**Section sources**
- [battle.js](file://src/data/battle.js#L300-L353)
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

### 状态同步错误处理
状态投影过程中的错误处理：

```mermaid
sequenceDiagram
participant AHS as animationInstructionHelpers
participant GS as gameState
participant Console as 控制台
AHS->>GS : applyProjectionToDisplay()
GS->>AHS : 抛出异常
AHS->>Console : console.error('[animationInstructionHelpers] applyProjectionToDisplay failed : ', err)
AHS->>AHS : 继续执行后续指令
```

**Section sources**
- [animationInstructionHelpers.js](file://src/data/animationInstructionHelpers.js#L200-L250)

## 结论
本项目的状态同步机制通过精心设计的双事件总线架构和双状态系统，实现了高效、可靠的状态管理。backendEventBus 负责核心游戏逻辑的流程控制和状态变更通知，而 frontendEventBus 专注于UI层面的动画和视觉反馈。通过 reactive 状态管理和投影同步机制，确保了前后端状态的一致性，同时保持了逻辑层与展示层的清晰分离。该设计模式具有良好的可维护性和扩展性，为复杂游戏系统的状态管理提供了可靠的解决方案。