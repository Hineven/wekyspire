为了后续内容开发考量和代码质量优化，帮我重写后端的战斗中的结算逻辑。

重写后的后端战斗结算逻辑从目前通过技能多态和结算流程硬编码的方式切换到使用后端协程遍历“结算树”上“结算原语”进行执行的方式，从而更好地支持“效果取消”、“结算中异步输入和等待”的功能。

首先，我向你介绍一次结算运行的抽象概念：你可以假设结算过程为后端协程对一颗结算树进行深度优先遍历，结算树上的节点为元语。
元语代表一个后端结算的原子操作，元语有很多种，的执行逻辑是自定义的，一般而言，元语执行时，才会修改后端状态/动态生成和展开其子元语节点，任何一条元语节点都可以被取消，这影响源于是否可执行。
元语可以被执行，当且仅当其没有被取消且父元语可执行（或为空）。这代表着，在遍历的任意时刻，如果某条元语到根节点的路径上有任意元语被取消，那么它不应该被执行。
在结算的遍历过程中，每访问一个元语节点时，先判断此元语是否可执行，若可执行，则执行，并遍历其子元语。若不可执行，直接返回即可。

通过将整个结算流程抽象为一个协程不断执行一个指令队列中的所有指令，统一后端结算的多变逻辑，并通过元语的取消机制（不再执行）来支持各种“取消”操作的发生，通过协程的等待来支持需要前端用户异步输入的结算流程。


元语基类具有以下基础属性：
- execute()：执行函数，元语在执行函数完成后
- uniqueID
- parentInstruction
不同元语根据自身特性不同可能有额外成员。

常用的元语示例：
* 伤害结算元语`DealDamageBattleInstruction`，对应battleUtils内`dealDamage`函数所代表的元语，执行时，改变`target`护盾、生命等状态，向动画队列发送指令等，和`dealDamage`类似。
* 发动攻击元语句`LaunchAttackBattleInstruction`，对应battleUtils内`launchAttack`所代表的元语，执行时，计算攻击伤害，从而生成伤害结算元语，向指令队列头部插入，和其它附带作用。
* 技能效果发动元语`ActivateSkillBattleInstruction`，对应battleUtils内`activateSkill`所代表的元语，执行时，调用技能的技能效果函数（类似于现在技能的use函数），此函数一般会向指令队列头部插入更多元语。
等等。


一些额外提示：
* 目前，代码内并未区分技能的使用（消耗资源和卡牌、发动技能）和技能的发动（单纯发动技能），请在重构过程中帮我做出区分（分为useSkill和activateSkill，useSkill元语可展开为ConsumeSkillResourcesBattleInstruction、ActivateSkillBattleInstruction）。
）。
* 由于一些积弊，目前代码质量不是很好，这对开发造成了一定困难。因此，在重构中，请务必完整阅读相关代码，彻底理解后再动手。并且务必注重你的代码质量！请仔细思考和规划，避免写出维护困难的垃圾代码，但同时也要注意避免过度设计。
* 这是一个复杂的任务，不要低估它的难度，许多细节都需要考虑，许多核心实现方案都需要反复评估，请谨慎行动。